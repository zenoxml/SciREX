{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SciREX \ud83d\ude80","text":"<p>SciREX is a revolutionary scientific computing framework that bridges the gap between traditional machine learning and advanced scientific computing. Developed by Airex Lab, it empowers researchers and engineers to solve complex scientific problems with state-of-the-art machine learning techniques.</p> <p></p>"},{"location":"#scientific-machine-learning","title":"Scientific Machine Learning","text":"<p>At the heart of SciREX lies our advanced Scientific Machine Learning (SciML) capabilities. We're pioneering the fusion of physical knowledge with machine learning to create more accurate, efficient, and interpretable models.</p>"},{"location":"#featured-sciml-components","title":"Featured SciML Components","text":""},{"location":"#fastvpinns","title":"FastVPINNs","text":"<ul> <li> <p>Finite Elements (FE)</p> </li> <li> <p>Physics Modules</p> </li> <li> <p>Model</p> </li> <li> <p>Geometry</p> </li> </ul>"},{"location":"#traditional-machine-learning-suite","title":"Traditional Machine Learning Suite","text":"<p>While we excel in SciML, we maintain comprehensive support for traditional machine learning approaches:</p>"},{"location":"#clustering-classification","title":"Clustering &amp; Classification","text":"<ul> <li>Hierarchical clustering</li> <li>Spectral methods</li> <li>Deep learning</li> <li>Classification</li> <li>Ensemble methods</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>High Performance: Optimized implementations for both CPU and GPU</li> <li>Scalability: From  experiments to HPC </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code>pip install scirex\n</code></pre> <pre><code>import scirex as sx\n\n# Initializel\nmodel = sx.models\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tutorials/</li> <li>QuickStart Guide</li> <li>ML Tutorial</li> <li>FastVPINNs Examples</li> <li>API Reference/</li> <li>Core API</li> <li>Physics Modules</li> <li>ML Algorithms</li> </ul>"},{"location":"#community-support","title":"\ud83e\udd1d Community &amp; Support","text":"<p>Join our growing community of scientists, researchers, and engineers who are pushing the boundaries of scientific computing:</p> <ul> <li>GitHub Repository</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use SciREX in your research, please cite:</p> <pre><code>@software{scirex2025,\n  title={SciREX},\n  author={Airex Lab},\n  year={2025},\n  url={https://github.com/zenoxml/SciREX/tree/main}\n}\n</code></pre> Powered by Airex Lab (IISc) - Aritifical Intelligence Research Exellence Lab"},{"location":"api/core/dl/tensorflow_wrapper/","title":"tensorflow_wrapper","text":"<p>TensorFlow layer factory implementations.</p> <p>This module provides factory methods for creating TensorFlow/Keras layers with consistent configuration options. Currently supports Dense and Conv2D layers.</p> Key classes <ul> <li>TensorflowDense:  for Dense layers</li> <li>TensorflowConv2D:  for Conv2D layers</li> </ul> Example <p>dense_layer = TensorflowDense.create_layer(units=64, activation='relu') conv_layer = TensorflowConv2D.create_layer(filters=32, kernel_size=3)</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D","title":"<code>TensorflowConv2D</code>","text":"<p>Factory class for creating Keras Conv2D layers.</p> <p>Provides a static method for creating and configuring Keras Conv2D layers with consistent parameters.</p> Example Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>class TensorflowConv2D:\n    \"\"\"Factory class for creating Keras Conv2D layers.\n\n    Provides a static method for creating and configuring Keras Conv2D layers\n    with consistent parameters.\n\n    Example:\n        &gt;&gt;&gt; # Create a conv layer with 64 filters and 3x3 kernel\n        &gt;&gt;&gt; conv1 = TensorflowConv2D.create_layer(\n        ...     filters=64,\n        ...     kernel_size=3,\n        ...     activation='relu'\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a conv layer with 32 filters and 5x5 kernel\n        &gt;&gt;&gt; conv2 = TensorflowConv2D.create_layer(\n        ...     filters=32,\n        ...     kernel_size=(5, 5),\n        ...     activation='relu'\n        ... )\n    \"\"\"\n\n    @staticmethod\n    def create_layer(\n        filters: int,\n        kernel_size: Union[int, Tuple[int, int]],\n        activation: Optional[Union[str, callable]] = None,\n        kernel_initializer: str = \"glorot_uniform\",\n        bias_initializer: str = \"zeros\",\n        dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n    ) -&gt; tf.keras.layers.Conv2D:\n        \"\"\"Create and return a Keras Conv2D layer.\n\n        Args:\n            filters: Number of output filters\n            kernel_size: Size of convolution kernel\n            activation: Activation function to use\n            kernel_initializer: Initializer for kernel weights\n            bias_initializer: Initializer for bias vector\n            dtype: Data type for layer computations\n\n        Returns:\n            tf.keras.layers.Conv2D: The configured Conv2D layer\n        \"\"\"\n        return layers.Conv2D(\n            filters=filters,\n            kernel_size=kernel_size,\n            activation=activation,\n            kernel_initializer=kernel_initializer,\n            bias_initializer=bias_initializer,\n            dtype=dtype,\n        )\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D--create-a-conv-layer-with-64-filters-and-3x3-kernel","title":"Create a conv layer with 64 filters and 3x3 kernel","text":"<p>conv1 = TensorflowConv2D.create_layer( ...     filters=64, ...     kernel_size=3, ...     activation='relu' ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D--create-a-conv-layer-with-32-filters-and-5x5-kernel","title":"Create a conv layer with 32 filters and 5x5 kernel","text":"<p>conv2 = TensorflowConv2D.create_layer( ...     filters=32, ...     kernel_size=(5, 5), ...     activation='relu' ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D.create_layer","title":"<code>create_layer(filters, kernel_size, activation=None, kernel_initializer='glorot_uniform', bias_initializer='zeros', dtype=None)</code>  <code>staticmethod</code>","text":"<p>Create and return a Keras Conv2D layer.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>int</code> <p>Number of output filters</p> required <code>kernel_size</code> <code>Union[int, Tuple[int, int]]</code> <p>Size of convolution kernel</p> required <code>activation</code> <code>Optional[Union[str, callable]]</code> <p>Activation function to use</p> <code>None</code> <code>kernel_initializer</code> <code>str</code> <p>Initializer for kernel weights</p> <code>'glorot_uniform'</code> <code>bias_initializer</code> <code>str</code> <p>Initializer for bias vector</p> <code>'zeros'</code> <code>dtype</code> <code>Optional[Union[str, DType]]</code> <p>Data type for layer computations</p> <code>None</code> <p>Returns:</p> Type Description <code>Conv2D</code> <p>tf.keras.layers.Conv2D: The configured Conv2D layer</p> Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>@staticmethod\ndef create_layer(\n    filters: int,\n    kernel_size: Union[int, Tuple[int, int]],\n    activation: Optional[Union[str, callable]] = None,\n    kernel_initializer: str = \"glorot_uniform\",\n    bias_initializer: str = \"zeros\",\n    dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n) -&gt; tf.keras.layers.Conv2D:\n    \"\"\"Create and return a Keras Conv2D layer.\n\n    Args:\n        filters: Number of output filters\n        kernel_size: Size of convolution kernel\n        activation: Activation function to use\n        kernel_initializer: Initializer for kernel weights\n        bias_initializer: Initializer for bias vector\n        dtype: Data type for layer computations\n\n    Returns:\n        tf.keras.layers.Conv2D: The configured Conv2D layer\n    \"\"\"\n    return layers.Conv2D(\n        filters=filters,\n        kernel_size=kernel_size,\n        activation=activation,\n        kernel_initializer=kernel_initializer,\n        bias_initializer=bias_initializer,\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense","title":"<code>TensorflowDense</code>","text":"<p>Factory class for creating Keras Dense layers.</p> <p>Provides a static method for creating and configuring Keras Dense layers with consistent parameters.</p> Example Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>class TensorflowDense:\n    \"\"\"Factory class for creating Keras Dense layers.\n\n    Provides a static method for creating and configuring Keras Dense layers\n    with consistent parameters.\n\n    Example:\n        &gt;&gt;&gt; # Create a dense layer with 32 units and ReLU activation\n        &gt;&gt;&gt; dense1 = TensorflowDense.create_layer(\n        ...     units=32,\n        ...     activation='relu'\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create an output layer with 1 unit and no activation\n        &gt;&gt;&gt; dense2 = TensorflowDense.create_layer(\n        ...     units=1,\n        ...     activation=None\n        ... )\n    \"\"\"\n\n    @staticmethod\n    def create_layer(\n        units: int,\n        activation: Optional[Union[str, callable]] = None,\n        kernel_initializer: str = \"glorot_uniform\",\n        bias_initializer: str = \"zeros\",\n        dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n    ) -&gt; tf.keras.layers.Dense:\n        \"\"\"Create and return a Keras Dense layer.\n\n        Args:\n            units: Number of output units\n            activation: Activation function to use\n            kernel_initializer: Initializer for kernel weights\n            bias_initializer: Initializer for bias vector\n            dtype: Data type for layer computations\n\n        Returns:\n            tf.keras.layers.Dense: The configured Dense layer\n        \"\"\"\n        return layers.Dense(\n            units=units,\n            activation=activation,\n            kernel_initializer=kernel_initializer,\n            bias_initializer=bias_initializer,\n            dtype=dtype,\n        )\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense--create-a-dense-layer-with-32-units-and-relu-activation","title":"Create a dense layer with 32 units and ReLU activation","text":"<p>dense1 = TensorflowDense.create_layer( ...     units=32, ...     activation='relu' ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense--create-an-output-layer-with-1-unit-and-no-activation","title":"Create an output layer with 1 unit and no activation","text":"<p>dense2 = TensorflowDense.create_layer( ...     units=1, ...     activation=None ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense.create_layer","title":"<code>create_layer(units, activation=None, kernel_initializer='glorot_uniform', bias_initializer='zeros', dtype=None)</code>  <code>staticmethod</code>","text":"<p>Create and return a Keras Dense layer.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>int</code> <p>Number of output units</p> required <code>activation</code> <code>Optional[Union[str, callable]]</code> <p>Activation function to use</p> <code>None</code> <code>kernel_initializer</code> <code>str</code> <p>Initializer for kernel weights</p> <code>'glorot_uniform'</code> <code>bias_initializer</code> <code>str</code> <p>Initializer for bias vector</p> <code>'zeros'</code> <code>dtype</code> <code>Optional[Union[str, DType]]</code> <p>Data type for layer computations</p> <code>None</code> <p>Returns:</p> Type Description <code>Dense</code> <p>tf.keras.layers.Dense: The configured Dense layer</p> Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>@staticmethod\ndef create_layer(\n    units: int,\n    activation: Optional[Union[str, callable]] = None,\n    kernel_initializer: str = \"glorot_uniform\",\n    bias_initializer: str = \"zeros\",\n    dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n) -&gt; tf.keras.layers.Dense:\n    \"\"\"Create and return a Keras Dense layer.\n\n    Args:\n        units: Number of output units\n        activation: Activation function to use\n        kernel_initializer: Initializer for kernel weights\n        bias_initializer: Initializer for bias vector\n        dtype: Data type for layer computations\n\n    Returns:\n        tf.keras.layers.Dense: The configured Dense layer\n    \"\"\"\n    return layers.Dense(\n        units=units,\n        activation=activation,\n        kernel_initializer=kernel_initializer,\n        bias_initializer=bias_initializer,\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/","title":"Agglomerative","text":"<p>Module: agglomerative.py</p> <p>This module provides an Agglomerative Clustering implementation using scikit-learn. It includes automatic selection of the optimal number of clusters using silhouette scores, with an optional user override.</p> <p>Classes:</p> Name Description <code>Agglomerative</code> <p>Implements an agglomerative clustering approach with auto cluster selection.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.AgglomerativeClustering</li> <li>sklearn.metrics.silhouette_score</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic scanning of possible cluster counts (2..max_k)</li> <li>Silhouette-based selection of the best cluster count</li> <li>Optional user override of the chosen number of clusters</li> <li>Final model/labels accessible after <code>.fit(...)</code></li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative","title":"<code>Agglomerative</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>Agglomerative Clustering with automatic selection of the optimal cluster count via silhouette.</p> <p>Attributes:</p> Name Type Description <code>max_k</code> <code>int</code> <p>The maximum number of clusters to consider.</p> <code>optimal_k</code> <code>Optional[int]</code> <p>The chosen number of clusters after evaluating silhouette                        scores and optional user input.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>Final cluster count (same as optimal_k).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>class Agglomerative(Clustering):\n    \"\"\"\n    Agglomerative Clustering with automatic selection of the optimal cluster count via silhouette.\n\n    Attributes:\n        max_k (int): The maximum number of clusters to consider.\n        optimal_k (Optional[int]): The chosen number of clusters after evaluating silhouette\n                                   scores and optional user input.\n        n_clusters (Optional[int]): Final cluster count (same as optimal_k).\n    \"\"\"\n\n    def __init__(self, max_k: int = 10) -&gt; None:\n        \"\"\"\n        Initialize the Agglomerative clustering class.\n\n        Args:\n            max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n        \"\"\"\n        super().__init__(\"agglomerative\")\n        self.max_k = max_k\n        self.optimal_k: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the Agglomerative Clustering model with automatic cluster count selection.\n\n        Args:\n            X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples = X.shape[0]\n        k_values = range(2, self.max_k + 1)\n        silhouettes = []\n\n        # Subsample size for silhouette\n        silhouette_sample_size = min(1000, n_samples)\n\n        for k in k_values:\n            model = AgglomerativeClustering(\n                n_clusters=k,\n                linkage=\"average\",  # or 'ward', 'complete', 'single'\n            )\n            labels = model.fit_predict(X)\n            unique_labels = np.unique(labels)\n\n            # If there's only one cluster, silhouette is invalid\n            if len(unique_labels) &lt;= 1:\n                silhouettes.append(-1)\n                continue\n\n            # Subsample if data is large\n            if n_samples &gt; silhouette_sample_size:\n                indices = np.random.choice(\n                    n_samples, silhouette_sample_size, replace=False\n                )\n                silhouettes.append(silhouette_score(X[indices], labels[indices]))\n            else:\n                silhouettes.append(silhouette_score(X, labels))\n\n        # Choose best k from silhouette\n        self.optimal_k = k_values[np.argmax(silhouettes)]\n        print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n        # Optional user override\n        user_input = (\n            input(\"Do you want to input your own number of clusters? (y/n): \")\n            .strip()\n            .lower()\n        )\n        if user_input == \"y\":\n            k_input = int(\n                input(\n                    f\"Enter the number of clusters (k), current estimate is {self.optimal_k}: \"\n                )\n            )\n            if k_input &gt;= 2:\n                self.optimal_k = k_input\n            else:\n                print(\n                    \"Number of clusters must be at least 2. Using the estimated optimal_k.\"\n                )\n\n        # Final fit with optimal_k\n        self.model = AgglomerativeClustering(\n            n_clusters=self.optimal_k, linkage=\"average\"\n        )\n        self.labels = self.model.fit_predict(X)\n        self.n_clusters = len(np.unique(self.labels))\n\n        print(f\"Agglomerative Clustering fitted with k = {self.optimal_k}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted Agglomerative Clustering model.\n\n        Returns:\n            Dict[str, Any]:\n                A dictionary containing:\n                - model_type (str): \"agglomerative\"\n                - n_clusters (int): The final chosen cluster count\n        \"\"\"\n        return {\"model_type\": self.model_type, \"n_clusters\": self.optimal_k}\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative.__init__","title":"<code>__init__(max_k=10)</code>","text":"<p>Initialize the Agglomerative clustering class.</p> <p>Parameters:</p> Name Type Description Default <code>max_k</code> <code>int</code> <p>Maximum number of clusters to try. Defaults to 10.</p> <code>10</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>def __init__(self, max_k: int = 10) -&gt; None:\n    \"\"\"\n    Initialize the Agglomerative clustering class.\n\n    Args:\n        max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n    \"\"\"\n    super().__init__(\"agglomerative\")\n    self.max_k = max_k\n    self.optimal_k: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative.fit","title":"<code>fit(X)</code>","text":"<p>Fit the Agglomerative Clustering model with automatic cluster count selection.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Scaled feature matrix of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the Agglomerative Clustering model with automatic cluster count selection.\n\n    Args:\n        X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples = X.shape[0]\n    k_values = range(2, self.max_k + 1)\n    silhouettes = []\n\n    # Subsample size for silhouette\n    silhouette_sample_size = min(1000, n_samples)\n\n    for k in k_values:\n        model = AgglomerativeClustering(\n            n_clusters=k,\n            linkage=\"average\",  # or 'ward', 'complete', 'single'\n        )\n        labels = model.fit_predict(X)\n        unique_labels = np.unique(labels)\n\n        # If there's only one cluster, silhouette is invalid\n        if len(unique_labels) &lt;= 1:\n            silhouettes.append(-1)\n            continue\n\n        # Subsample if data is large\n        if n_samples &gt; silhouette_sample_size:\n            indices = np.random.choice(\n                n_samples, silhouette_sample_size, replace=False\n            )\n            silhouettes.append(silhouette_score(X[indices], labels[indices]))\n        else:\n            silhouettes.append(silhouette_score(X, labels))\n\n    # Choose best k from silhouette\n    self.optimal_k = k_values[np.argmax(silhouettes)]\n    print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n    # Optional user override\n    user_input = (\n        input(\"Do you want to input your own number of clusters? (y/n): \")\n        .strip()\n        .lower()\n    )\n    if user_input == \"y\":\n        k_input = int(\n            input(\n                f\"Enter the number of clusters (k), current estimate is {self.optimal_k}: \"\n            )\n        )\n        if k_input &gt;= 2:\n            self.optimal_k = k_input\n        else:\n            print(\n                \"Number of clusters must be at least 2. Using the estimated optimal_k.\"\n            )\n\n    # Final fit with optimal_k\n    self.model = AgglomerativeClustering(\n        n_clusters=self.optimal_k, linkage=\"average\"\n    )\n    self.labels = self.model.fit_predict(X)\n    self.n_clusters = len(np.unique(self.labels))\n\n    print(f\"Agglomerative Clustering fitted with k = {self.optimal_k}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted Agglomerative Clustering model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str): \"agglomerative\" - n_clusters (int): The final chosen cluster count</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted Agglomerative Clustering model.\n\n    Returns:\n        Dict[str, Any]:\n            A dictionary containing:\n            - model_type (str): \"agglomerative\"\n            - n_clusters (int): The final chosen cluster count\n    \"\"\"\n    return {\"model_type\": self.model_type, \"n_clusters\": self.optimal_k}\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/","title":"Base","text":"<p>Module: base.py</p> <p>This module provides the abstract base class for all clustering implementations in SciREX. It defines shared functionality for:     - Data preparation (loading from CSV and standard scaling)     - Clustering metric computation (silhouette, calinski-harabasz, davies-bouldin)     - 2D plotting using PCA for visualization</p> <p>Classes:</p> Name Description <code>Clustering</code> <p>Abstract base class that outlines common behavior for clustering algorithms.</p> Dependencies <ul> <li>numpy, pandas, matplotlib, sklearn</li> <li>abc, pathlib, time, typing (for structural and type support)</li> </ul> Key Features <ul> <li>Consistent interface for loading and preparing data</li> <li>Standard approach to computing and returning clustering metrics</li> <li>PCA-based 2D plotting routine for visualizing clusters in two dimensions</li> <li>Enforces subclasses to implement <code>fit</code> and <code>get_model_params</code></li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering","title":"<code>Clustering</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for clustering algorithms in the SciREX library.</p> This class provides <ul> <li>A consistent interface for loading and preparing data</li> <li>A standard approach to computing and returning clustering metrics</li> <li>A PCA-based 2D plotting routine for visualizing clusters</li> </ul> Subclasses must <ol> <li>Implement the <code>fit(X: np.ndarray) -&gt; None</code> method, which should populate <code>self.labels</code>.</li> <li>Implement the <code>get_model_params() -&gt; Dict[str, Any]</code> method, which returns a dict    of model parameters for logging/debugging.</li> </ol> <p>Attributes:</p> Name Type Description <code>model_type</code> <code>str</code> <p>The name or identifier of the clustering model (e.g., \"kmeans\", \"dbscan\").</p> <code>random_state</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>labels</code> <code>Optional[ndarray]</code> <p>Array of cluster labels assigned to each sample after fitting.</p> <code>plots_dir</code> <code>Path</code> <p>Directory where cluster plots will be saved.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>class Clustering(ABC):\n    \"\"\"\n    Abstract base class for clustering algorithms in the SciREX library.\n\n    This class provides:\n      - A consistent interface for loading and preparing data\n      - A standard approach to computing and returning clustering metrics\n      - A PCA-based 2D plotting routine for visualizing clusters\n\n    Subclasses must:\n      1. Implement the `fit(X: np.ndarray) -&gt; None` method, which should populate `self.labels`.\n      2. Implement the `get_model_params() -&gt; Dict[str, Any]` method, which returns a dict\n         of model parameters for logging/debugging.\n\n    Attributes:\n        model_type (str): The name or identifier of the clustering model (e.g., \"kmeans\", \"dbscan\").\n        random_state (int): Random seed for reproducibility.\n        labels (Optional[np.ndarray]): Array of cluster labels assigned to each sample after fitting.\n        plots_dir (Path): Directory where cluster plots will be saved.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_type: str,\n        random_state: int = 42,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the base clustering class.\n\n        Args:\n            model_type (str): A string identifier for the clustering algorithm\n                              (e.g. \"kmeans\", \"dbscan\", etc.).\n            random_state (int, optional): Seed for reproducibility where applicable.\n                                          Defaults to 42.\n        \"\"\"\n        self.model_type = model_type\n        self.random_state = random_state\n\n        # Directory for saving plots\n        self.plots_dir = Path.cwd() / \"plots\"\n        self.plots_dir.mkdir(parents=True, exist_ok=True)\n\n        # Subclasses must set self.labels after fitting\n        self.labels: Optional[np.ndarray] = None\n\n    def prepare_data(self, path: str) -&gt; np.ndarray:\n        \"\"\"\n        Load and preprocess data from a CSV file, returning a scaled NumPy array.\n\n        This method:\n          1. Reads the CSV file into a pandas DataFrame.\n          2. Drops rows containing NaN values.\n          3. Selects only numeric columns from the DataFrame.\n          4. Scales these features using scikit-learn's StandardScaler.\n          5. Returns the scaled values as a NumPy array.\n\n        Args:\n            path (str): Filepath to the CSV data file.\n\n        Returns:\n            np.ndarray: A 2D array of shape (n_samples, n_features) containing\n                        standardized numeric data.\n\n        Raises:\n            ValueError: If no numeric columns are found in the data.\n        \"\"\"\n        df = pd.read_csv(Path(path))\n        df = df.dropna()\n        numeric_columns = df.select_dtypes(include=[np.number]).columns\n        if numeric_columns.empty:\n            raise ValueError(\"No numeric columns found in the data.\")\n        features = df[numeric_columns].values\n        return StandardScaler().fit_transform(features)\n\n    @abstractmethod\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the clustering model on a preprocessed dataset, assigning labels to `self.labels`.\n\n        Args:\n            X (np.ndarray): A 2D array of shape (n_samples, n_features) containing\n                            the data to be clustered.\n\n        Subclasses must implement this method. After fitting the model,\n        `self.labels` should be set to an array of cluster labels of shape (n_samples,).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Return model parameters for logging or debugging.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing key model parameters and\n                            potentially any learned attributes (e.g. number of clusters).\n        \"\"\"\n        pass\n\n    def plots(self, X: np.ndarray, labels: np.ndarray) -&gt; Tuple[Figure, Path]:\n        \"\"\"\n        Create a 2D scatter plot of clusters using PCA for dimensionality reduction.\n\n        Steps:\n          1. If X has &gt;=2 features, run PCA to reduce it to 2 components.\n          2. If X has only 1 feature, it is zero-padded to form a 2D embedding for plotting.\n          3. Each unique cluster label is plotted with a distinct color.\n          4. The figure is saved in `self.plots_dir` as `cluster_plot_{self.model_type}.png`.\n\n        Args:\n            X (np.ndarray): Data array of shape (n_samples, n_features).\n            labels (np.ndarray): Cluster labels for each sample.\n\n        Returns:\n            Tuple[Figure, Path]:\n              - The matplotlib Figure object.\n              - The path where the figure was saved (plot_path).\n\n        Notes:\n            Subclasses typically do not override this method. Instead, they rely on the\n            base implementation for consistent plotting.\n        \"\"\"\n        n_features = X.shape[1]\n        if n_features &gt;= 2:\n            pca = PCA(n_components=2, random_state=self.random_state)\n            X_pca = pca.fit_transform(X)\n        else:\n            # If there's only 1 feature, we simulate a second dimension with zeros\n            print(\"Dataset has only 1 feature. Zero-padding to 2D for visualization.\")\n            pca = PCA(n_components=1, random_state=self.random_state)\n            X_1d = pca.fit_transform(X)\n            X_pca = np.hstack([X_1d, np.zeros((X_1d.shape[0], 1))])\n\n        unique_labels = np.unique(labels)\n\n        fig = plt.figure(figsize=(8, 6), dpi=100)\n        ax = fig.add_subplot(111)\n\n        colors = plt.cm.rainbow(np.linspace(0, 1, len(unique_labels)))\n        for label, color in zip(unique_labels, colors):\n            mask = labels == label\n            ax.scatter(\n                X_pca[mask, 0],\n                X_pca[mask, 1],\n                color=(\"k\" if label == -1 else color),\n                label=f\"Cluster {label}\",\n                alpha=0.7,\n                s=60,\n            )\n\n        ax.set_xlabel(\"PCA Component 1\", fontsize=10)\n        ax.set_ylabel(\"PCA Component 2\", fontsize=10)\n        ax.legend(fontsize=8)\n        ax.set_title(\n            f\"{self.model_type.upper()} Clustering Results (2D PCA)\",\n            fontsize=12,\n            pad=15,\n        )\n        plt.tight_layout()\n\n        # Save the figure\n        plot_path = self.plots_dir / f\"cluster_plot_{self.model_type}.png\"\n        fig.savefig(plot_path, dpi=300, bbox_inches=\"tight\")\n        plt.close(fig)\n        return fig, plot_path\n\n    def run(\n        self, data: Optional[np.ndarray] = None, path: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Run the complete clustering pipeline: data loading/preprocessing,\n        fitting the model, and computing standard clustering metrics.\n\n        Args:\n            data (Optional[np.ndarray]): Preprocessed data array of shape (n_samples, n_features).\n            path (Optional[str]): Path to a CSV file from which to read data.\n                                  If `data` is not provided, this must be specified.\n\n        Returns:\n            Dict[str, Any]: A dictionary with the following keys:\n                - \"params\" (Dict[str, Any]): Model parameters from `self.get_model_params()`\n                - \"silhouette_score\" (float)\n                - \"calinski_harabasz_score\" (float)\n                - \"davies_bouldin_score\" (float)\n\n        Raises:\n            ValueError: If neither `data` nor `path` is provided, or if `self.labels`\n                        remains None after fitting (indicating a subclass didn't set it).\n        \"\"\"\n        if data is None and path is None:\n            raise ValueError(\"Either 'data' or 'path' must be provided.\")\n\n        # Load/prepare data if needed\n        X = data if data is not None else self.prepare_data(path)\n\n        # Fit the model\n        self.fit(X)\n\n        # Check labels\n        if self.labels is None:\n            raise ValueError(\"Model has not assigned labels. Did you implement fit()?\")\n\n        # Compute clustering metrics\n        silhouette = silhouette_score(X, self.labels)\n        calinski_harabasz = calinski_harabasz_score(X, self.labels)\n        davies_bouldin = davies_bouldin_score(X, self.labels)\n\n        # Return results\n        return {\n            \"params\": self.get_model_params(),\n            \"silhouette_score\": silhouette,\n            \"calinski_harabasz_score\": calinski_harabasz,\n            \"davies_bouldin_score\": davies_bouldin,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.__init__","title":"<code>__init__(model_type, random_state=42)</code>","text":"<p>Initialize the base clustering class.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>A string identifier for the clustering algorithm               (e.g. \"kmeans\", \"dbscan\", etc.).</p> required <code>random_state</code> <code>int</code> <p>Seed for reproducibility where applicable.                           Defaults to 42.</p> <code>42</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def __init__(\n    self,\n    model_type: str,\n    random_state: int = 42,\n) -&gt; None:\n    \"\"\"\n    Initialize the base clustering class.\n\n    Args:\n        model_type (str): A string identifier for the clustering algorithm\n                          (e.g. \"kmeans\", \"dbscan\", etc.).\n        random_state (int, optional): Seed for reproducibility where applicable.\n                                      Defaults to 42.\n    \"\"\"\n    self.model_type = model_type\n    self.random_state = random_state\n\n    # Directory for saving plots\n    self.plots_dir = Path.cwd() / \"plots\"\n    self.plots_dir.mkdir(parents=True, exist_ok=True)\n\n    # Subclasses must set self.labels after fitting\n    self.labels: Optional[np.ndarray] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.fit","title":"<code>fit(X)</code>  <code>abstractmethod</code>","text":"<p>Fit the clustering model on a preprocessed dataset, assigning labels to <code>self.labels</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) containing             the data to be clustered.</p> required <p>Subclasses must implement this method. After fitting the model, <code>self.labels</code> should be set to an array of cluster labels of shape (n_samples,).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>@abstractmethod\ndef fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the clustering model on a preprocessed dataset, assigning labels to `self.labels`.\n\n    Args:\n        X (np.ndarray): A 2D array of shape (n_samples, n_features) containing\n                        the data to be clustered.\n\n    Subclasses must implement this method. After fitting the model,\n    `self.labels` should be set to an array of cluster labels of shape (n_samples,).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.get_model_params","title":"<code>get_model_params()</code>  <code>abstractmethod</code>","text":"<p>Return model parameters for logging or debugging.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing key model parameters and             potentially any learned attributes (e.g. number of clusters).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>@abstractmethod\ndef get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Return model parameters for logging or debugging.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing key model parameters and\n                        potentially any learned attributes (e.g. number of clusters).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.plots","title":"<code>plots(X, labels)</code>","text":"<p>Create a 2D scatter plot of clusters using PCA for dimensionality reduction.</p> Steps <ol> <li>If X has &gt;=2 features, run PCA to reduce it to 2 components.</li> <li>If X has only 1 feature, it is zero-padded to form a 2D embedding for plotting.</li> <li>Each unique cluster label is plotted with a distinct color.</li> <li>The figure is saved in <code>self.plots_dir</code> as <code>cluster_plot_{self.model_type}.png</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Data array of shape (n_samples, n_features).</p> required <code>labels</code> <code>ndarray</code> <p>Cluster labels for each sample.</p> required <p>Returns:</p> Type Description <code>Tuple[Figure, Path]</code> <p>Tuple[Figure, Path]: - The matplotlib Figure object. - The path where the figure was saved (plot_path).</p> Notes <p>Subclasses typically do not override this method. Instead, they rely on the base implementation for consistent plotting.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def plots(self, X: np.ndarray, labels: np.ndarray) -&gt; Tuple[Figure, Path]:\n    \"\"\"\n    Create a 2D scatter plot of clusters using PCA for dimensionality reduction.\n\n    Steps:\n      1. If X has &gt;=2 features, run PCA to reduce it to 2 components.\n      2. If X has only 1 feature, it is zero-padded to form a 2D embedding for plotting.\n      3. Each unique cluster label is plotted with a distinct color.\n      4. The figure is saved in `self.plots_dir` as `cluster_plot_{self.model_type}.png`.\n\n    Args:\n        X (np.ndarray): Data array of shape (n_samples, n_features).\n        labels (np.ndarray): Cluster labels for each sample.\n\n    Returns:\n        Tuple[Figure, Path]:\n          - The matplotlib Figure object.\n          - The path where the figure was saved (plot_path).\n\n    Notes:\n        Subclasses typically do not override this method. Instead, they rely on the\n        base implementation for consistent plotting.\n    \"\"\"\n    n_features = X.shape[1]\n    if n_features &gt;= 2:\n        pca = PCA(n_components=2, random_state=self.random_state)\n        X_pca = pca.fit_transform(X)\n    else:\n        # If there's only 1 feature, we simulate a second dimension with zeros\n        print(\"Dataset has only 1 feature. Zero-padding to 2D for visualization.\")\n        pca = PCA(n_components=1, random_state=self.random_state)\n        X_1d = pca.fit_transform(X)\n        X_pca = np.hstack([X_1d, np.zeros((X_1d.shape[0], 1))])\n\n    unique_labels = np.unique(labels)\n\n    fig = plt.figure(figsize=(8, 6), dpi=100)\n    ax = fig.add_subplot(111)\n\n    colors = plt.cm.rainbow(np.linspace(0, 1, len(unique_labels)))\n    for label, color in zip(unique_labels, colors):\n        mask = labels == label\n        ax.scatter(\n            X_pca[mask, 0],\n            X_pca[mask, 1],\n            color=(\"k\" if label == -1 else color),\n            label=f\"Cluster {label}\",\n            alpha=0.7,\n            s=60,\n        )\n\n    ax.set_xlabel(\"PCA Component 1\", fontsize=10)\n    ax.set_ylabel(\"PCA Component 2\", fontsize=10)\n    ax.legend(fontsize=8)\n    ax.set_title(\n        f\"{self.model_type.upper()} Clustering Results (2D PCA)\",\n        fontsize=12,\n        pad=15,\n    )\n    plt.tight_layout()\n\n    # Save the figure\n    plot_path = self.plots_dir / f\"cluster_plot_{self.model_type}.png\"\n    fig.savefig(plot_path, dpi=300, bbox_inches=\"tight\")\n    plt.close(fig)\n    return fig, plot_path\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.prepare_data","title":"<code>prepare_data(path)</code>","text":"<p>Load and preprocess data from a CSV file, returning a scaled NumPy array.</p> This method <ol> <li>Reads the CSV file into a pandas DataFrame.</li> <li>Drops rows containing NaN values.</li> <li>Selects only numeric columns from the DataFrame.</li> <li>Scales these features using scikit-learn's StandardScaler.</li> <li>Returns the scaled values as a NumPy array.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Filepath to the CSV data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A 2D array of shape (n_samples, n_features) containing         standardized numeric data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no numeric columns are found in the data.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def prepare_data(self, path: str) -&gt; np.ndarray:\n    \"\"\"\n    Load and preprocess data from a CSV file, returning a scaled NumPy array.\n\n    This method:\n      1. Reads the CSV file into a pandas DataFrame.\n      2. Drops rows containing NaN values.\n      3. Selects only numeric columns from the DataFrame.\n      4. Scales these features using scikit-learn's StandardScaler.\n      5. Returns the scaled values as a NumPy array.\n\n    Args:\n        path (str): Filepath to the CSV data file.\n\n    Returns:\n        np.ndarray: A 2D array of shape (n_samples, n_features) containing\n                    standardized numeric data.\n\n    Raises:\n        ValueError: If no numeric columns are found in the data.\n    \"\"\"\n    df = pd.read_csv(Path(path))\n    df = df.dropna()\n    numeric_columns = df.select_dtypes(include=[np.number]).columns\n    if numeric_columns.empty:\n        raise ValueError(\"No numeric columns found in the data.\")\n    features = df[numeric_columns].values\n    return StandardScaler().fit_transform(features)\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.run","title":"<code>run(data=None, path=None)</code>","text":"<p>Run the complete clustering pipeline: data loading/preprocessing, fitting the model, and computing standard clustering metrics.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[ndarray]</code> <p>Preprocessed data array of shape (n_samples, n_features).</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Path to a CSV file from which to read data.                   If <code>data</code> is not provided, this must be specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary with the following keys: - \"params\" (Dict[str, Any]): Model parameters from <code>self.get_model_params()</code> - \"silhouette_score\" (float) - \"calinski_harabasz_score\" (float) - \"davies_bouldin_score\" (float)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>data</code> nor <code>path</code> is provided, or if <code>self.labels</code>         remains None after fitting (indicating a subclass didn't set it).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def run(\n    self, data: Optional[np.ndarray] = None, path: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run the complete clustering pipeline: data loading/preprocessing,\n    fitting the model, and computing standard clustering metrics.\n\n    Args:\n        data (Optional[np.ndarray]): Preprocessed data array of shape (n_samples, n_features).\n        path (Optional[str]): Path to a CSV file from which to read data.\n                              If `data` is not provided, this must be specified.\n\n    Returns:\n        Dict[str, Any]: A dictionary with the following keys:\n            - \"params\" (Dict[str, Any]): Model parameters from `self.get_model_params()`\n            - \"silhouette_score\" (float)\n            - \"calinski_harabasz_score\" (float)\n            - \"davies_bouldin_score\" (float)\n\n    Raises:\n        ValueError: If neither `data` nor `path` is provided, or if `self.labels`\n                    remains None after fitting (indicating a subclass didn't set it).\n    \"\"\"\n    if data is None and path is None:\n        raise ValueError(\"Either 'data' or 'path' must be provided.\")\n\n    # Load/prepare data if needed\n    X = data if data is not None else self.prepare_data(path)\n\n    # Fit the model\n    self.fit(X)\n\n    # Check labels\n    if self.labels is None:\n        raise ValueError(\"Model has not assigned labels. Did you implement fit()?\")\n\n    # Compute clustering metrics\n    silhouette = silhouette_score(X, self.labels)\n    calinski_harabasz = calinski_harabasz_score(X, self.labels)\n    davies_bouldin = davies_bouldin_score(X, self.labels)\n\n    # Return results\n    return {\n        \"params\": self.get_model_params(),\n        \"silhouette_score\": silhouette,\n        \"calinski_harabasz_score\": calinski_harabasz,\n        \"davies_bouldin_score\": davies_bouldin,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/","title":"Dbscan","text":"<p>Module: dbscan.py</p> <p>This module provides a DBSCAN (Density-Based Spatial Clustering of Applications with Noise) implementation using scikit-learn's DBSCAN class.</p> <p>It includes an optional automated heuristic for estimating <code>eps</code> and <code>min_samples</code> by analyzing neighborhood distances. The user can override these defaults before fitting.</p> <p>Classes:</p> Name Description <code>Dbscan</code> <p>Implements DBSCAN with a simple heuristic for <code>eps</code> and <code>min_samples</code>.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.DBSCAN</li> <li>sklearn.neighbors.NearestNeighbors</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic estimation of <code>eps</code> via median k-distances</li> <li>Automatic estimation of <code>min_samples</code> via log2(n) heuristic</li> <li>Optional user override for both parameters</li> <li>Counting of discovered clusters and noise points</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan","title":"<code>Dbscan</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>DBSCAN clustering algorithm with optional automatic estimation of <code>eps</code> and <code>min_samples</code>.</p> <p>Attributes:</p> Name Type Description <code>eps</code> <code>Optional[float]</code> <p>The maximum neighborhood distance after estimation/user input.</p> <code>min_samples</code> <code>Optional[int]</code> <p>The number of samples in a neighborhood for                          a point to be considered a core point.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>The number of clusters found (excluding noise).</p> <code>n_noise</code> <code>Optional[int]</code> <p>The number of noise points labeled as -1 by DBSCAN.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>class Dbscan(Clustering):\n    \"\"\"\n    DBSCAN clustering algorithm with optional automatic estimation of `eps` and `min_samples`.\n\n    Attributes:\n        eps (Optional[float]): The maximum neighborhood distance after estimation/user input.\n        min_samples (Optional[int]): The number of samples in a neighborhood for\n                                     a point to be considered a core point.\n        n_clusters (Optional[int]): The number of clusters found (excluding noise).\n        n_noise (Optional[int]): The number of noise points labeled as -1 by DBSCAN.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the DBSCAN clustering model.\n\n        By default, `eps` and `min_samples` are not set until the user calls `.fit(...)`.\n        The final values are determined by a heuristic (plus optional user override).\n        \"\"\"\n        super().__init__(\"dbscan\")\n        self.eps: Optional[float] = None\n        self.min_samples: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n        self.n_noise: Optional[int] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the DBSCAN model to the data with a heuristic approach to determine eps and min_samples.\n\n        Args:\n            X (np.ndarray): Input data array of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples = X.shape[0]\n        rng = np.random.default_rng(self.random_state)\n\n        # Heuristic for min_samples\n        self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n        # Subsample for k-distance estimation\n        sample_size = min(1000, n_samples)\n        indices = rng.choice(n_samples, sample_size, replace=False)\n        X_sample = X[indices]\n\n        # Compute k-distance (k = min_samples)\n        nbrs = NearestNeighbors(n_neighbors=self.min_samples)\n        nbrs.fit(X_sample)\n        distances, _ = nbrs.kneighbors(X_sample)\n        k_distances = distances[\n            :, -1\n        ]  # Distance to the min_samples-th nearest neighbor\n        self.eps = float(np.median(k_distances))\n\n        print(\"Estimated parameters from heuristic:\")\n        print(f\"eps = {self.eps:.4f}, min_samples = {self.min_samples}\")\n\n        # Optional user override\n        user_input = (\n            input(\"Do you want to input your own 'eps' and 'min_samples'? (y/n): \")\n            .strip()\n            .lower()\n        )\n        if user_input == \"y\":\n            eps_input = input(f\"Enter 'eps' (current estimate is {self.eps:.4f}): \")\n            min_samples_input = input(\n                f\"Enter 'min_samples' (current estimate is {self.min_samples}): \"\n            )\n            self.eps = float(eps_input)\n            self.min_samples = int(min_samples_input)\n\n        # Fit DBSCAN\n        self.model = DBSCAN(eps=self.eps, min_samples=self.min_samples)\n        self.labels = self.model.fit_predict(X)\n\n        # Compute the number of clusters (excluding noise)\n        self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n        self.n_noise = np.count_nonzero(self.labels == -1)\n\n        print(\n            f\"DBSCAN fitted with eps = {self.eps:.4f}, min_samples = {self.min_samples}\"\n        )\n        print(f\"Number of clusters found: {self.n_clusters}\")\n        print(f\"Number of noise points: {self.n_noise}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted DBSCAN model.\n\n        Returns:\n            Dict[str, Any]:\n                A dictionary containing:\n                - model_type (str)\n                - eps (float)\n                - min_samples (int)\n                - n_clusters (int)\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"eps\": self.eps,\n            \"min_samples\": self.min_samples,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the DBSCAN clustering model.</p> <p>By default, <code>eps</code> and <code>min_samples</code> are not set until the user calls <code>.fit(...)</code>. The final values are determined by a heuristic (plus optional user override).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the DBSCAN clustering model.\n\n    By default, `eps` and `min_samples` are not set until the user calls `.fit(...)`.\n    The final values are determined by a heuristic (plus optional user override).\n    \"\"\"\n    super().__init__(\"dbscan\")\n    self.eps: Optional[float] = None\n    self.min_samples: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n    self.n_noise: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan.fit","title":"<code>fit(X)</code>","text":"<p>Fit the DBSCAN model to the data with a heuristic approach to determine eps and min_samples.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input data array of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the DBSCAN model to the data with a heuristic approach to determine eps and min_samples.\n\n    Args:\n        X (np.ndarray): Input data array of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples = X.shape[0]\n    rng = np.random.default_rng(self.random_state)\n\n    # Heuristic for min_samples\n    self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n    # Subsample for k-distance estimation\n    sample_size = min(1000, n_samples)\n    indices = rng.choice(n_samples, sample_size, replace=False)\n    X_sample = X[indices]\n\n    # Compute k-distance (k = min_samples)\n    nbrs = NearestNeighbors(n_neighbors=self.min_samples)\n    nbrs.fit(X_sample)\n    distances, _ = nbrs.kneighbors(X_sample)\n    k_distances = distances[\n        :, -1\n    ]  # Distance to the min_samples-th nearest neighbor\n    self.eps = float(np.median(k_distances))\n\n    print(\"Estimated parameters from heuristic:\")\n    print(f\"eps = {self.eps:.4f}, min_samples = {self.min_samples}\")\n\n    # Optional user override\n    user_input = (\n        input(\"Do you want to input your own 'eps' and 'min_samples'? (y/n): \")\n        .strip()\n        .lower()\n    )\n    if user_input == \"y\":\n        eps_input = input(f\"Enter 'eps' (current estimate is {self.eps:.4f}): \")\n        min_samples_input = input(\n            f\"Enter 'min_samples' (current estimate is {self.min_samples}): \"\n        )\n        self.eps = float(eps_input)\n        self.min_samples = int(min_samples_input)\n\n    # Fit DBSCAN\n    self.model = DBSCAN(eps=self.eps, min_samples=self.min_samples)\n    self.labels = self.model.fit_predict(X)\n\n    # Compute the number of clusters (excluding noise)\n    self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n    self.n_noise = np.count_nonzero(self.labels == -1)\n\n    print(\n        f\"DBSCAN fitted with eps = {self.eps:.4f}, min_samples = {self.min_samples}\"\n    )\n    print(f\"Number of clusters found: {self.n_clusters}\")\n    print(f\"Number of noise points: {self.n_noise}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted DBSCAN model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str) - eps (float) - min_samples (int) - n_clusters (int)</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted DBSCAN model.\n\n    Returns:\n        Dict[str, Any]:\n            A dictionary containing:\n            - model_type (str)\n            - eps (float)\n            - min_samples (int)\n            - n_clusters (int)\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"eps\": self.eps,\n        \"min_samples\": self.min_samples,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/","title":"GMM","text":"<p>Module: gmm.py</p> <p>This module provides a Gaussian Mixture Model (GMM) clustering implementation using scikit-learn's GaussianMixture. The Gmm class automatically estimates the optimal number of components (clusters) via silhouette scores. It then allows the user to confirm or override this choice.</p> <p>Classes:</p> Name Description <code>Gmm</code> <p>Gaussian Mixture Model clustering with automatic component selection.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.mixture.GaussianMixture</li> <li>sklearn.metrics.silhouette_score</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Scans [2..max_k] for the best silhouette score</li> <li>Optional user override of the chosen number of components</li> <li>Final model is stored, along with predicted cluster labels</li> <li>Ties into the base <code>Clustering</code> for plotting/metrics</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm","title":"<code>Gmm</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>Gaussian Mixture Model clustering with automatic component selection via silhouette scores.</p> <p>Attributes:</p> Name Type Description <code>max_k</code> <code>int</code> <p>Maximum number of components (clusters) to consider when searching          for the optimal mixture size.</p> <code>optimal_k</code> <code>Optional[int]</code> <p>The chosen (user-verified) number of components after fitting.</p> <code>model</code> <code>Optional[GaussianMixture]</code> <p>The underlying scikit-learn GaussianMixture model.</p> <code>labels</code> <code>Optional[ndarray]</code> <p>Cluster/component labels for each data point after fitting.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>class Gmm(Clustering):\n    \"\"\"\n    Gaussian Mixture Model clustering with automatic component selection via silhouette scores.\n\n    Attributes:\n        max_k (int): Maximum number of components (clusters) to consider when searching\n                     for the optimal mixture size.\n        optimal_k (Optional[int]): The chosen (user-verified) number of components after fitting.\n        model (Optional[GaussianMixture]): The underlying scikit-learn GaussianMixture model.\n        labels (Optional[np.ndarray]): Cluster/component labels for each data point after fitting.\n    \"\"\"\n\n    def __init__(self, max_k: int = 10) -&gt; None:\n        \"\"\"\n        Initialize the GMM clustering.\n\n        Args:\n            max_k (int, optional): Maximum number of components to try. Defaults to 10.\n        \"\"\"\n        super().__init__(\"gmm\")\n        self.max_k = max_k\n        self.optimal_k: Optional[int] = None\n        self.model: Optional[GaussianMixture] = None\n        self.labels: Optional[np.ndarray] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the GMM model to the data with automatic component selection.\n\n        Args:\n            X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples, n_features = X.shape\n\n        k_values = range(2, self.max_k + 1)\n        silhouettes = []\n\n        # Prepare a random generator for subsampling\n        rng = np.random.default_rng(self.random_state)\n        silhouette_sample_size = min(1000, n_samples)\n\n        # Evaluate silhouette scores for each candidate k\n        for k in k_values:\n            gmm = GaussianMixture(n_components=k, random_state=self.random_state)\n            gmm.fit(X)\n            labels = gmm.predict(X)\n\n            # Ensure at least 2 distinct clusters\n            if len(np.unique(labels)) &gt; 1:\n                # Subsample if large\n                if n_samples &gt; silhouette_sample_size:\n                    sample_indices = rng.choice(\n                        n_samples, silhouette_sample_size, replace=False\n                    )\n                    X_sample_silhouette = X[sample_indices]\n                    labels_sample = labels[sample_indices]\n                else:\n                    X_sample_silhouette = X\n                    labels_sample = labels\n\n                silhouettes.append(\n                    silhouette_score(\n                        X_sample_silhouette.reshape(-1, n_features), labels_sample\n                    )\n                )\n            else:\n                silhouettes.append(-1)  # Invalid silhouette if only one cluster\n\n        # Pick k with best silhouette\n        self.optimal_k = k_values[np.argmax(silhouettes)]\n        print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n        # Optional user override\n        user_input = (\n            input(\"Do you want to input your own number of clusters? (y/n): \")\n            .strip()\n            .lower()\n        )\n        if user_input == \"y\":\n            k_input = int(\n                input(\n                    f\"Enter the number of clusters (k). Current estimate is {self.optimal_k}: \"\n                )\n            )\n            if k_input &gt;= 2:\n                self.optimal_k = k_input\n            else:\n                print(\n                    \"Number of clusters must be at least 2. Using the estimated optimal_k.\"\n                )\n\n        # Final fit\n        self.model = GaussianMixture(\n            n_components=self.optimal_k, random_state=self.random_state\n        )\n        self.labels = self.model.fit_predict(X)\n        print(f\"GMM fitted with optimal_k = {self.optimal_k}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted GMM model.\n\n        Returns:\n            Dict[str, Any]:\n                A dictionary containing:\n                - model_type (str)\n                - optimal_k (int)\n                - max_k (int)\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"optimal_k\": self.optimal_k,\n            \"max_k\": self.max_k,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm.__init__","title":"<code>__init__(max_k=10)</code>","text":"<p>Initialize the GMM clustering.</p> <p>Parameters:</p> Name Type Description Default <code>max_k</code> <code>int</code> <p>Maximum number of components to try. Defaults to 10.</p> <code>10</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>def __init__(self, max_k: int = 10) -&gt; None:\n    \"\"\"\n    Initialize the GMM clustering.\n\n    Args:\n        max_k (int, optional): Maximum number of components to try. Defaults to 10.\n    \"\"\"\n    super().__init__(\"gmm\")\n    self.max_k = max_k\n    self.optimal_k: Optional[int] = None\n    self.model: Optional[GaussianMixture] = None\n    self.labels: Optional[np.ndarray] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm.fit","title":"<code>fit(X)</code>","text":"<p>Fit the GMM model to the data with automatic component selection.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Scaled feature matrix of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the GMM model to the data with automatic component selection.\n\n    Args:\n        X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples, n_features = X.shape\n\n    k_values = range(2, self.max_k + 1)\n    silhouettes = []\n\n    # Prepare a random generator for subsampling\n    rng = np.random.default_rng(self.random_state)\n    silhouette_sample_size = min(1000, n_samples)\n\n    # Evaluate silhouette scores for each candidate k\n    for k in k_values:\n        gmm = GaussianMixture(n_components=k, random_state=self.random_state)\n        gmm.fit(X)\n        labels = gmm.predict(X)\n\n        # Ensure at least 2 distinct clusters\n        if len(np.unique(labels)) &gt; 1:\n            # Subsample if large\n            if n_samples &gt; silhouette_sample_size:\n                sample_indices = rng.choice(\n                    n_samples, silhouette_sample_size, replace=False\n                )\n                X_sample_silhouette = X[sample_indices]\n                labels_sample = labels[sample_indices]\n            else:\n                X_sample_silhouette = X\n                labels_sample = labels\n\n            silhouettes.append(\n                silhouette_score(\n                    X_sample_silhouette.reshape(-1, n_features), labels_sample\n                )\n            )\n        else:\n            silhouettes.append(-1)  # Invalid silhouette if only one cluster\n\n    # Pick k with best silhouette\n    self.optimal_k = k_values[np.argmax(silhouettes)]\n    print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n    # Optional user override\n    user_input = (\n        input(\"Do you want to input your own number of clusters? (y/n): \")\n        .strip()\n        .lower()\n    )\n    if user_input == \"y\":\n        k_input = int(\n            input(\n                f\"Enter the number of clusters (k). Current estimate is {self.optimal_k}: \"\n            )\n        )\n        if k_input &gt;= 2:\n            self.optimal_k = k_input\n        else:\n            print(\n                \"Number of clusters must be at least 2. Using the estimated optimal_k.\"\n            )\n\n    # Final fit\n    self.model = GaussianMixture(\n        n_components=self.optimal_k, random_state=self.random_state\n    )\n    self.labels = self.model.fit_predict(X)\n    print(f\"GMM fitted with optimal_k = {self.optimal_k}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted GMM model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str) - optimal_k (int) - max_k (int)</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted GMM model.\n\n    Returns:\n        Dict[str, Any]:\n            A dictionary containing:\n            - model_type (str)\n            - optimal_k (int)\n            - max_k (int)\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"optimal_k\": self.optimal_k,\n        \"max_k\": self.max_k,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/","title":"Hdbscan","text":"<p>Module: hdbscan.py</p> <p>This module provides an implementation of the HDBSCAN (Hierarchical Density-Based Spatial  Clustering of Applications with Noise) algorithm.</p> <p>HDBSCAN automatically finds clusters of varying densities by constructing a hierarchical tree structure and extracting stable clusters from the hierarchy using the EOM (Excess of Mass) method or another selection approach.</p> <p>Classes:</p> Name Description <code>Hdbscan</code> <p>Implements HDBSCAN with a heuristic for <code>min_cluster_size</code> and <code>min_samples</code>,      plus optional user override.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.HDBSCAN</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic heuristic for <code>min_cluster_size</code> and <code>min_samples</code></li> <li>Optional user override for parameters</li> <li>Summarizes discovered clusters and noise points</li> <li>Inherits from base <code>Clustering</code> for a consistent pipeline</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan","title":"<code>Hdbscan</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>HDBSCAN clustering with automatic heuristic for <code>min_cluster_size</code> and <code>min_samples</code>, plus optional user override.</p> <p>Attributes:</p> Name Type Description <code>min_cluster_size</code> <code>Optional[int]</code> <p>The minimum size of a cluster (in samples).</p> <code>min_samples</code> <code>Optional[int]</code> <p>The minimum number of samples in a neighborhood for                          a point to be considered a core point.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>Number of clusters discovered (excluding noise).</p> <code>n_noise</code> <code>Optional[int]</code> <p>Number of points labeled as noise (i.e., assigned label -1).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>class Hdbscan(Clustering):\n    \"\"\"\n    HDBSCAN clustering with automatic heuristic for `min_cluster_size` and `min_samples`,\n    plus optional user override.\n\n    Attributes:\n        min_cluster_size (Optional[int]): The minimum size of a cluster (in samples).\n        min_samples (Optional[int]): The minimum number of samples in a neighborhood for\n                                     a point to be considered a core point.\n        n_clusters (Optional[int]): Number of clusters discovered (excluding noise).\n        n_noise (Optional[int]): Number of points labeled as noise (i.e., assigned label -1).\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the HDBSCAN clustering model.\n\n        By default, `min_cluster_size` and `min_samples` are computed at fit time\n        based on dataset properties, then optionally overridden by user input.\n        \"\"\"\n        super().__init__(\"hdbscan\")\n        self.min_cluster_size: Optional[int] = None\n        self.min_samples: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n        self.n_noise: Optional[int] = None\n\n    def fit(self, X: np.ndarray, expected_clusters: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Fit the HDBSCAN model to the data using a simple heuristic for initial parameters.\n\n        Args:\n            X (np.ndarray): Input data array of shape (n_samples, n_features).\n            expected_clusters (Optional[int]): Potential future extension for approximate cluster count.\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples = X.shape[0]\n\n        # Heuristic estimation of parameters\n        self.min_samples = max(1, int(np.log(n_samples)))\n        self.min_cluster_size = max(5, int(0.02 * n_samples))\n\n        print(\"Estimated parameters:\")\n        print(\n            f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n        )\n\n        # (Optional) prompt user for overrides if desired (not shown in snippet)\n        # For example: user_input = input(\"Do you want to override? ...\")\n\n        self.model = HDBSCAN(\n            min_cluster_size=self.min_cluster_size,\n            min_samples=self.min_samples,\n            cluster_selection_method=\"eom\",\n        )\n        self.model.fit(X)\n\n        self.labels = self.model.labels_\n        self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n        self.n_noise = np.count_nonzero(self.labels == -1)\n\n        print(f\"Number of clusters: {self.n_clusters}\")\n        print(f\"Number of noise points: {self.n_noise}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the model parameters and clustering results.\n\n        Returns:\n            Dict[str, Any]:\n                - model_type (str): \"hdbscan\"\n                - min_cluster_size (int)\n                - min_samples (int)\n                - n_clusters (int)\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"min_cluster_size\": self.min_cluster_size,\n            \"min_samples\": self.min_samples,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the HDBSCAN clustering model.</p> <p>By default, <code>min_cluster_size</code> and <code>min_samples</code> are computed at fit time based on dataset properties, then optionally overridden by user input.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the HDBSCAN clustering model.\n\n    By default, `min_cluster_size` and `min_samples` are computed at fit time\n    based on dataset properties, then optionally overridden by user input.\n    \"\"\"\n    super().__init__(\"hdbscan\")\n    self.min_cluster_size: Optional[int] = None\n    self.min_samples: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n    self.n_noise: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan.fit","title":"<code>fit(X, expected_clusters=None)</code>","text":"<p>Fit the HDBSCAN model to the data using a simple heuristic for initial parameters.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input data array of shape (n_samples, n_features).</p> required <code>expected_clusters</code> <code>Optional[int]</code> <p>Potential future extension for approximate cluster count.</p> <code>None</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>def fit(self, X: np.ndarray, expected_clusters: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Fit the HDBSCAN model to the data using a simple heuristic for initial parameters.\n\n    Args:\n        X (np.ndarray): Input data array of shape (n_samples, n_features).\n        expected_clusters (Optional[int]): Potential future extension for approximate cluster count.\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples = X.shape[0]\n\n    # Heuristic estimation of parameters\n    self.min_samples = max(1, int(np.log(n_samples)))\n    self.min_cluster_size = max(5, int(0.02 * n_samples))\n\n    print(\"Estimated parameters:\")\n    print(\n        f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n    )\n\n    # (Optional) prompt user for overrides if desired (not shown in snippet)\n    # For example: user_input = input(\"Do you want to override? ...\")\n\n    self.model = HDBSCAN(\n        min_cluster_size=self.min_cluster_size,\n        min_samples=self.min_samples,\n        cluster_selection_method=\"eom\",\n    )\n    self.model.fit(X)\n\n    self.labels = self.model.labels_\n    self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n    self.n_noise = np.count_nonzero(self.labels == -1)\n\n    print(f\"Number of clusters: {self.n_clusters}\")\n    print(f\"Number of noise points: {self.n_noise}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get the model parameters and clustering results.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: - model_type (str): \"hdbscan\" - min_cluster_size (int) - min_samples (int) - n_clusters (int)</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the model parameters and clustering results.\n\n    Returns:\n        Dict[str, Any]:\n            - model_type (str): \"hdbscan\"\n            - min_cluster_size (int)\n            - min_samples (int)\n            - n_clusters (int)\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"min_cluster_size\": self.min_cluster_size,\n        \"min_samples\": self.min_samples,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/","title":"Kmeans","text":"<p>Module: kmeans.py</p> <p>This module provides a K-means clustering implementation using scikit-learn's MiniBatchKMeans. The Kmeans class inherits from a generic Clustering base class and offers:   - Automatic selection of the optimal number of clusters via silhouette or elbow methods   - Option for the user to input a custom number of clusters if desired</p> <p>Classes:</p> Name Description <code>Kmeans</code> <p>K-Means clustering with automatic parameter selection and optional user override.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.MiniBatchKMeans</li> <li>sklearn.metrics.silhouette_score</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Scans [2..max_k] to find the best cluster count using silhouette or elbow</li> <li>Final cluster count stored in <code>optimal_k</code>, with a fitted model and labels</li> <li>Inherits from the base <code>Clustering</code> for consistent plotting and metric computation</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans","title":"<code>Kmeans</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>K-Means clustering with automatic selection of the optimal number of clusters.</p> <p>Attributes:</p> Name Type Description <code>max_k</code> <code>int</code> <p>The maximum number of clusters to consider when scanning for the optimal cluster count.</p> <code>optimal_k</code> <code>Optional[int]</code> <p>The chosen number of clusters after fitting.</p> <code>model</code> <code>Optional[MiniBatchKMeans]</code> <p>The underlying scikit-learn MiniBatchKMeans model.</p> <code>labels</code> <code>Optional[ndarray]</code> <p>Cluster labels for each data point after fitting.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>The actual number of clusters used by the final fitted model.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>class Kmeans(Clustering):\n    \"\"\"\n    K-Means clustering with automatic selection of the optimal number of clusters.\n\n    Attributes:\n        max_k (int): The maximum number of clusters to consider when scanning for the optimal cluster count.\n        optimal_k (Optional[int]): The chosen number of clusters after fitting.\n        model (Optional[MiniBatchKMeans]): The underlying scikit-learn MiniBatchKMeans model.\n        labels (Optional[np.ndarray]): Cluster labels for each data point after fitting.\n        n_clusters (Optional[int]): The actual number of clusters used by the final fitted model.\n    \"\"\"\n\n    def __init__(self, max_k: int = 10) -&gt; None:\n        \"\"\"\n        Initialize the Kmeans clustering class.\n\n        Args:\n            max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n        \"\"\"\n        super().__init__(\"kmeans\")\n        self.max_k = max_k\n        self.optimal_k: Optional[int] = None\n        self.model: Optional[MiniBatchKMeans] = None\n        self.labels: Optional[np.ndarray] = None\n        self.n_clusters: Optional[int] = None\n\n    def _calculate_elbow_scores(self, X: np.ndarray, k_values: range) -&gt; np.ndarray:\n        \"\"\"\n        Calculate inertia scores (in elbow method), then compute a \"second derivative\" style metric.\n\n        Args:\n            X (np.ndarray): Input data of shape (n_samples, n_features).\n            k_values (range): Range of k values to evaluate, e.g. range(2, max_k+1).\n\n        Returns:\n            np.ndarray: A numeric array of elbow scores, where higher indicates a stronger elbow.\n        \"\"\"\n        inertias = []\n        for k in k_values:\n            kmeans = MiniBatchKMeans(\n                n_clusters=k, random_state=self.random_state, batch_size=1000\n            )\n            kmeans.fit(X)\n            inertias.append(kmeans.inertia_)\n\n        inertias = np.array(inertias)\n\n        # First derivative of inertia\n        diffs = np.diff(inertias)\n        # Second derivative\n        diffs_r = np.diff(diffs)\n        # A ratio capturing second derivative relative to the first derivative\n        elbow_score = diffs_r / np.abs(diffs[1:])\n\n        return elbow_score\n\n    def _calculate_silhouette_scores(\n        self, X: np.ndarray, k_values: range\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate silhouette scores for each candidate k in k_values.\n\n        Steps:\n          1. For each k, fit a MiniBatchKMeans and obtain cluster labels.\n          2. Subsample large datasets (up to 1000 points) to speed silhouette calculations.\n          3. Return an array of silhouette scores, one per k.\n\n        Args:\n            X (np.ndarray): Input data of shape (n_samples, n_features).\n            k_values (range): Range of k values to evaluate, e.g. range(2, max_k+1).\n\n        Returns:\n            np.ndarray: Silhouette scores for each candidate k.\n        \"\"\"\n        silhouette_scores = []\n        sample_size = min(1000, X.shape[0])\n        rng = np.random.default_rng(self.random_state)\n\n        for k in k_values:\n            kmeans = MiniBatchKMeans(\n                n_clusters=k, random_state=self.random_state, batch_size=1000\n            )\n            labels = kmeans.fit_predict(X)\n\n            # If there's only one cluster, silhouette is invalid\n            if len(np.unique(labels)) &lt;= 1:\n                silhouette_scores.append(-1)\n                continue\n\n            # Subsample if the dataset is very large\n            if X.shape[0] &gt; sample_size:\n                indices = rng.choice(X.shape[0], sample_size, replace=False)\n                X_sample = X[indices]\n                labels_sample = labels[indices]\n            else:\n                X_sample = X\n                labels_sample = labels\n\n            score = silhouette_score(X_sample, labels_sample)\n            silhouette_scores.append(score)\n\n        return np.array(silhouette_scores)\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the K-Means model to the data with automatic cluster selection.\n\n        Steps:\n          1. Define k_values as range(2..max_k).\n          2. Compute silhouette scores and elbow scores across those k_values.\n          3. Determine an optimal k from either method (this example picks elbow).\n          4. Fit a final MiniBatchKMeans with the chosen k, storing labels and cluster count.\n\n        Args:\n            X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n        \"\"\"\n        k_values = range(2, self.max_k + 1)\n\n        # Evaluate silhouette and elbow\n        silhouette_scores = self._calculate_silhouette_scores(X, k_values)\n        elbow_scores = self._calculate_elbow_scores(X, k_values)\n\n        # Best k from silhouette = index of maximum silhouette\n        optimal_k_silhouette = k_values[np.argmax(silhouette_scores)]\n\n        # Best k from elbow = index of maximum elbow score\n        # Note: elbow_scores has length (len(k_values) - 2), so we align indexing\n        optimal_k_elbow = k_values[:-2][np.argmax(elbow_scores)]\n\n        # Choose whichever approach you'd like; here using elbow by default\n        self.optimal_k = optimal_k_elbow\n        print(f\"Optimal k from silhouette: {optimal_k_silhouette}\")\n        print(f\"Optimal k from elbow method: {self.optimal_k}\")\n\n        self.model = MiniBatchKMeans(\n            n_clusters=self.optimal_k, random_state=self.random_state, batch_size=1000\n        )\n        self.labels = self.model.fit_predict(X)\n        self.n_clusters = len(np.unique(self.labels))\n\n        print(f\"\\nKMeans fitted with {self.optimal_k} clusters\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted K-Means model.\n\n        Returns:\n            Dict[str, Any]:\n                - model_type (str): \"kmeans\"\n                - max_k (int): The maximum number of clusters originally specified\n                - n_clusters (int): The final number of clusters used\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"max_k\": self.max_k,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans.__init__","title":"<code>__init__(max_k=10)</code>","text":"<p>Initialize the Kmeans clustering class.</p> <p>Parameters:</p> Name Type Description Default <code>max_k</code> <code>int</code> <p>Maximum number of clusters to try. Defaults to 10.</p> <code>10</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>def __init__(self, max_k: int = 10) -&gt; None:\n    \"\"\"\n    Initialize the Kmeans clustering class.\n\n    Args:\n        max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n    \"\"\"\n    super().__init__(\"kmeans\")\n    self.max_k = max_k\n    self.optimal_k: Optional[int] = None\n    self.model: Optional[MiniBatchKMeans] = None\n    self.labels: Optional[np.ndarray] = None\n    self.n_clusters: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans.fit","title":"<code>fit(X)</code>","text":"<p>Fit the K-Means model to the data with automatic cluster selection.</p> Steps <ol> <li>Define k_values as range(2..max_k).</li> <li>Compute silhouette scores and elbow scores across those k_values.</li> <li>Determine an optimal k from either method (this example picks elbow).</li> <li>Fit a final MiniBatchKMeans with the chosen k, storing labels and cluster count.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Scaled feature matrix of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the K-Means model to the data with automatic cluster selection.\n\n    Steps:\n      1. Define k_values as range(2..max_k).\n      2. Compute silhouette scores and elbow scores across those k_values.\n      3. Determine an optimal k from either method (this example picks elbow).\n      4. Fit a final MiniBatchKMeans with the chosen k, storing labels and cluster count.\n\n    Args:\n        X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n    \"\"\"\n    k_values = range(2, self.max_k + 1)\n\n    # Evaluate silhouette and elbow\n    silhouette_scores = self._calculate_silhouette_scores(X, k_values)\n    elbow_scores = self._calculate_elbow_scores(X, k_values)\n\n    # Best k from silhouette = index of maximum silhouette\n    optimal_k_silhouette = k_values[np.argmax(silhouette_scores)]\n\n    # Best k from elbow = index of maximum elbow score\n    # Note: elbow_scores has length (len(k_values) - 2), so we align indexing\n    optimal_k_elbow = k_values[:-2][np.argmax(elbow_scores)]\n\n    # Choose whichever approach you'd like; here using elbow by default\n    self.optimal_k = optimal_k_elbow\n    print(f\"Optimal k from silhouette: {optimal_k_silhouette}\")\n    print(f\"Optimal k from elbow method: {self.optimal_k}\")\n\n    self.model = MiniBatchKMeans(\n        n_clusters=self.optimal_k, random_state=self.random_state, batch_size=1000\n    )\n    self.labels = self.model.fit_predict(X)\n    self.n_clusters = len(np.unique(self.labels))\n\n    print(f\"\\nKMeans fitted with {self.optimal_k} clusters\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted K-Means model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: - model_type (str): \"kmeans\" - max_k (int): The maximum number of clusters originally specified - n_clusters (int): The final number of clusters used</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted K-Means model.\n\n    Returns:\n        Dict[str, Any]:\n            - model_type (str): \"kmeans\"\n            - max_k (int): The maximum number of clusters originally specified\n            - n_clusters (int): The final number of clusters used\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"max_k\": self.max_k,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/","title":"Optics","text":"<p>Module: optics.py</p> <p>This module provides an implementation of the OPTICS (Ordering Points To Identify Clustering Structure) clustering algorithm using scikit-learn's OPTICS. It automatically estimates minimum cluster size and minimum samples based on the dataset, and lets the user override these parameters.</p> <p>Classes:</p> Name Description <code>Optics</code> <p>An OPTICS clustering implementation with heuristic parameter estimation and optional user override.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.OPTICS</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic estimation of <code>min_samples</code> based on dataset size (log2 heuristic)</li> <li>Automatic estimation of <code>min_cluster_size</code> (5% of data or 50, whichever is smaller,   but not less than <code>min_samples</code>)</li> <li>Optional user prompts to override both parameters</li> <li>Computation of discovered clusters, noise points, and summary messages</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics","title":"<code>Optics</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>OPTICS clustering implementation with parameter estimation and optional user override.</p> <p>Attributes:</p> Name Type Description <code>min_samples</code> <code>int</code> <p>The minimum number of samples in a neighborhood for a point                to be considered a core point. Initialized after heuristic                or user input.</p> <code>min_cluster_size</code> <code>int</code> <p>The minimum number of samples in a cluster.                     Initialized after heuristic or user input.</p> <code>n_clusters</code> <code>int</code> <p>Number of clusters found (excluding noise).</p> <code>n_noise</code> <code>int</code> <p>Number of points labeled as noise.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>class Optics(Clustering):\n    \"\"\"\n    OPTICS clustering implementation with parameter estimation and optional user override.\n\n    Attributes:\n        min_samples (int): The minimum number of samples in a neighborhood for a point\n                           to be considered a core point. Initialized after heuristic\n                           or user input.\n        min_cluster_size (int): The minimum number of samples in a cluster.\n                                Initialized after heuristic or user input.\n        n_clusters (int): Number of clusters found (excluding noise).\n        n_noise (int): Number of points labeled as noise.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the OPTICS clustering model.\n\n        By default, `min_cluster_size` and `min_samples` are estimated after analyzing\n        dataset size. The user can override these parameters in the `.fit(...)` method.\n        \"\"\"\n        super().__init__(\"optics\")\n        self.min_samples: Optional[int] = None\n        self.min_cluster_size: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n        self.n_noise: Optional[int] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the OPTICS model to the data, estimating `min_cluster_size` and `min_samples`.\n\n        Args:\n            X (np.ndarray): Input data array of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples, n_features = X.shape\n\n        # Heuristic for min_samples\n        self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n        # Heuristic for min_cluster_size:\n        #   - Minimum of 5% of data or 50\n        #   - but not less than min_samples\n        self.min_cluster_size = max(self.min_samples, min(50, int(0.05 * n_samples)))\n\n        print(\"Estimated parameters:\")\n        print(\n            f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n        )\n\n        user_input = (\n            input(\"Do you want to input your own parameters? (y/n): \").strip().lower()\n        )\n        if user_input == \"y\":\n            min_cluster_size_input = input(\n                f\"Enter 'min_cluster_size' (current: {self.min_cluster_size}): \"\n            )\n            min_samples_input = input(\n                f\"Enter 'min_samples' (current: {self.min_samples}): \"\n            )\n            self.min_cluster_size = int(min_cluster_size_input)\n            self.min_samples = int(min_samples_input)\n\n        # Fit the OPTICS model\n        self.model = SKLearnOPTICS(\n            min_samples=self.min_samples,\n            min_cluster_size=self.min_cluster_size,\n            xi=0.05,\n            metric=\"euclidean\",\n            n_jobs=-1,\n        )\n        self.model.fit(X)\n\n        self.labels = self.model.labels_\n        self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n        self.n_noise = np.count_nonzero(self.labels == -1)\n\n        if self.n_clusters == 0:\n            print(\"Warning: No clusters found. All points labeled as noise.\")\n        else:\n            print(f\"OPTICS found {self.n_clusters} clusters\")\n            print(f\"Noise points: {self.n_noise} ({(self.n_noise/n_samples)*100:.1f}%)\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the model parameters and clustering results.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing:\n                - model_type (str): The name of the clustering algorithm (\"optics\").\n                - min_cluster_size (int): Final min_cluster_size used.\n                - min_samples (int): Final min_samples used.\n                - n_clusters (int, optional): Number of clusters found.\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"min_cluster_size\": self.min_cluster_size,\n            \"min_samples\": self.min_samples,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the OPTICS clustering model.</p> <p>By default, <code>min_cluster_size</code> and <code>min_samples</code> are estimated after analyzing dataset size. The user can override these parameters in the <code>.fit(...)</code> method.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the OPTICS clustering model.\n\n    By default, `min_cluster_size` and `min_samples` are estimated after analyzing\n    dataset size. The user can override these parameters in the `.fit(...)` method.\n    \"\"\"\n    super().__init__(\"optics\")\n    self.min_samples: Optional[int] = None\n    self.min_cluster_size: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n    self.n_noise: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics.fit","title":"<code>fit(X)</code>","text":"<p>Fit the OPTICS model to the data, estimating <code>min_cluster_size</code> and <code>min_samples</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input data array of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the OPTICS model to the data, estimating `min_cluster_size` and `min_samples`.\n\n    Args:\n        X (np.ndarray): Input data array of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples, n_features = X.shape\n\n    # Heuristic for min_samples\n    self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n    # Heuristic for min_cluster_size:\n    #   - Minimum of 5% of data or 50\n    #   - but not less than min_samples\n    self.min_cluster_size = max(self.min_samples, min(50, int(0.05 * n_samples)))\n\n    print(\"Estimated parameters:\")\n    print(\n        f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n    )\n\n    user_input = (\n        input(\"Do you want to input your own parameters? (y/n): \").strip().lower()\n    )\n    if user_input == \"y\":\n        min_cluster_size_input = input(\n            f\"Enter 'min_cluster_size' (current: {self.min_cluster_size}): \"\n        )\n        min_samples_input = input(\n            f\"Enter 'min_samples' (current: {self.min_samples}): \"\n        )\n        self.min_cluster_size = int(min_cluster_size_input)\n        self.min_samples = int(min_samples_input)\n\n    # Fit the OPTICS model\n    self.model = SKLearnOPTICS(\n        min_samples=self.min_samples,\n        min_cluster_size=self.min_cluster_size,\n        xi=0.05,\n        metric=\"euclidean\",\n        n_jobs=-1,\n    )\n    self.model.fit(X)\n\n    self.labels = self.model.labels_\n    self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n    self.n_noise = np.count_nonzero(self.labels == -1)\n\n    if self.n_clusters == 0:\n        print(\"Warning: No clusters found. All points labeled as noise.\")\n    else:\n        print(f\"OPTICS found {self.n_clusters} clusters\")\n        print(f\"Noise points: {self.n_noise} ({(self.n_noise/n_samples)*100:.1f}%)\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get the model parameters and clustering results.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str): The name of the clustering algorithm (\"optics\"). - min_cluster_size (int): Final min_cluster_size used. - min_samples (int): Final min_samples used. - n_clusters (int, optional): Number of clusters found.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the model parameters and clustering results.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing:\n            - model_type (str): The name of the clustering algorithm (\"optics\").\n            - min_cluster_size (int): Final min_cluster_size used.\n            - min_samples (int): Final min_samples used.\n            - n_clusters (int, optional): Number of clusters found.\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"min_cluster_size\": self.min_cluster_size,\n        \"min_samples\": self.min_samples,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/","title":"datahandler","text":"<p>Abstract Base Interface for Neural Network Data Handling in PDEs.</p> <p>This module provides the base interface for handling data transformations and tensor conversions required for neural network-based PDE solvers. It defines the essential structure for managing various data types involved in finite element computations.</p> The implementation supports <ul> <li>Finite element data processing</li> <li>Dirichlet boundary condition handling</li> <li>Test point generation and management</li> <li>Bilinear parameter tensor conversion</li> <li>Sensor data generation and handling</li> <li>Parameter management for inverse problems</li> </ul> Key classes <ul> <li>DataHandler: Abstract base class for PDE data handling</li> </ul> Note <p>All implementations assume double precision (float64) numpy arrays as inputs, with optional conversion to float32 for computational efficiency.</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> <li>tensorflow: For tensor operations</li> <li>numpy: For numerical arrays</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler","title":"<code>DataHandler</code>","text":"<p>Abstract base class for PDE solution data handling and tensor conversion.</p> <p>This class defines the interface for managing and converting various data types required in neural network-based PDE solvers. It handles transformation between numpy arrays and tensorflow tensors, and manages different aspects of the finite element computation data.</p> <p>Attributes:</p> Name Type Description <code>fespace</code> <p>Finite element space object containing mesh and element info</p> <code>domain</code> <p>Domain object containing geometric and boundary information</p> <code>dtype</code> <p>TensorFlow data type for tensor conversion (float32/float64)</p> Example <p>class MyDataHandler(DataHandler): ...     def init(self, fespace, domain): ...         super().init(fespace, domain, tf.float32) ... ...     def get_dirichlet_input(self): ...         # Implementation ...         pass ... ...     def get_test_points(self): ...         # Implementation ...         pass</p> Note <p>Concrete implementations must override: - get_dirichlet_input() - get_test_points() - get_bilinear_params_dict_as_tensors() - get_sensor_data() - get_inverse_params()</p> <p>All methods should handle type conversion between numpy arrays and tensorflow tensors consistently.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>class DataHandler:\n    \"\"\"Abstract base class for PDE solution data handling and tensor conversion.\n\n    This class defines the interface for managing and converting various data types\n    required in neural network-based PDE solvers. It handles transformation between\n    numpy arrays and tensorflow tensors, and manages different aspects of the finite\n    element computation data.\n\n    Attributes:\n        fespace: Finite element space object containing mesh and element info\n        domain: Domain object containing geometric and boundary information\n        dtype: TensorFlow data type for tensor conversion (float32/float64)\n\n    Example:\n        &gt;&gt;&gt; class MyDataHandler(DataHandler):\n        ...     def __init__(self, fespace, domain):\n        ...         super().__init__(fespace, domain, tf.float32)\n        ...\n        ...     def get_dirichlet_input(self):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def get_test_points(self):\n        ...         # Implementation\n        ...         pass\n\n    Note:\n        Concrete implementations must override:\n        - get_dirichlet_input()\n        - get_test_points()\n        - get_bilinear_params_dict_as_tensors()\n        - get_sensor_data()\n        - get_inverse_params()\n\n        All methods should handle type conversion between numpy arrays\n        and tensorflow tensors consistently.\n    \"\"\"\n\n    def __init__(self, fespace, domain, dtype):\n        \"\"\"\n        Constructor for the DataHandler class\n\n        Args:\n            fespace (FESpace2D): The FESpace2D object.\n            domain (Domain2D): The Domain2D object.\n            dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.fespace = fespace\n        self.domain = domain\n        self.dtype = dtype\n\n    @abstractmethod\n    def get_dirichlet_input(self) -&gt; tuple:\n        \"\"\"\n        This function will return the input for the Dirichlet boundary data\n\n        Args:\n            None\n\n        Returns:\n            The Dirichlet boundary data as a tuple of tensors\n        \"\"\"\n\n    @abstractmethod\n    def get_test_points(self):\n        \"\"\"\n        Get the test points for the given domain.\n\n        Args:\n            None\n\n        Returns:\n            The test points as a tensor\n        \"\"\"\n\n    @abstractmethod\n    def get_bilinear_params_dict_as_tensors(self, function) -&gt; dict:\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            function (function): The function from the example file which returns the bilinear parameters dictionary\n\n        Returns:\n            The bilinear parameters dictionary with all the values converted to tensors\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data(self, exact_sol, num_sensor_points, mesh_type, file_name=None):\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            exact_sol (function): The exact solution function\n            num_sensor_points (int): The number of sensor points\n            mesh_type (str): The type of mesh\n            file_name (str): The file name to save the sensor data\n\n        Returns:\n            The sensor data as a tensor\n        \"\"\"\n\n    @abstractmethod\n    def get_inverse_params(self, inverse_params_dict_function):\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n        Returns:\n            The inverse parameters dictionary with all the values converted to tensors\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.__init__","title":"<code>__init__(fespace, domain, dtype)</code>","text":"<p>Constructor for the DataHandler class</p> <p>Parameters:</p> Name Type Description Default <code>fespace</code> <code>FESpace2D</code> <p>The FESpace2D object.</p> required <code>domain</code> <code>Domain2D</code> <p>The Domain2D object.</p> required <code>dtype</code> <code>DType</code> <p>The tensorflow dtype to be used for all the tensors.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>def __init__(self, fespace, domain, dtype):\n    \"\"\"\n    Constructor for the DataHandler class\n\n    Args:\n        fespace (FESpace2D): The FESpace2D object.\n        domain (Domain2D): The Domain2D object.\n        dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n    Returns:\n        None\n    \"\"\"\n\n    self.fespace = fespace\n    self.domain = domain\n    self.dtype = dtype\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_bilinear_params_dict_as_tensors","title":"<code>get_bilinear_params_dict_as_tensors(function)</code>  <code>abstractmethod</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>function</code> <p>The function from the example file which returns the bilinear parameters dictionary</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The bilinear parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_bilinear_params_dict_as_tensors(self, function) -&gt; dict:\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        function (function): The function from the example file which returns the bilinear parameters dictionary\n\n    Returns:\n        The bilinear parameters dictionary with all the values converted to tensors\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_dirichlet_input","title":"<code>get_dirichlet_input()</code>  <code>abstractmethod</code>","text":"<p>This function will return the input for the Dirichlet boundary data</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The Dirichlet boundary data as a tuple of tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_dirichlet_input(self) -&gt; tuple:\n    \"\"\"\n    This function will return the input for the Dirichlet boundary data\n\n    Args:\n        None\n\n    Returns:\n        The Dirichlet boundary data as a tuple of tensors\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_inverse_params","title":"<code>get_inverse_params(inverse_params_dict_function)</code>  <code>abstractmethod</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>inverse_params_dict_function</code> <code>function</code> <p>The function from the example file which returns the inverse parameters dictionary</p> required <p>Returns:</p> Type Description <p>The inverse parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_inverse_params(self, inverse_params_dict_function):\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n    Returns:\n        The inverse parameters dictionary with all the values converted to tensors\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_sensor_data","title":"<code>get_sensor_data(exact_sol, num_sensor_points, mesh_type, file_name=None)</code>  <code>abstractmethod</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function</p> required <code>num_sensor_points</code> <code>int</code> <p>The number of sensor points</p> required <code>mesh_type</code> <code>str</code> <p>The type of mesh</p> required <code>file_name</code> <code>str</code> <p>The file name to save the sensor data</p> <code>None</code> <p>Returns:</p> Type Description <p>The sensor data as a tensor</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_sensor_data(self, exact_sol, num_sensor_points, mesh_type, file_name=None):\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        exact_sol (function): The exact solution function\n        num_sensor_points (int): The number of sensor points\n        mesh_type (str): The type of mesh\n        file_name (str): The file name to save the sensor data\n\n    Returns:\n        The sensor data as a tensor\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_test_points","title":"<code>get_test_points()</code>  <code>abstractmethod</code>","text":"<p>Get the test points for the given domain.</p> <p>Returns:</p> Type Description <p>The test points as a tensor</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_test_points(self):\n    \"\"\"\n    Get the test points for the given domain.\n\n    Args:\n        None\n\n    Returns:\n        The test points as a tensor\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/","title":"datahandler2","text":"<p>Two-Dimensional Data Handler Implementation for PDE Solvers.</p> <p>This module implements data handling functionality for 2D PDE problems, focusing on efficient tensor conversions and management of finite element data structures. It provides methods for converting numpy arrays to tensorflow tensors and handling various aspects of the PDE solution process.</p> The implementation supports <ul> <li>Shape function and gradient tensor management</li> <li>Dirichlet boundary data processing</li> <li>Test point generation and handling</li> <li>Sensor data management for inverse problems</li> <li>Bilinear parameter tensor conversion</li> <li>Forcing function data handling</li> </ul> Key classes <ul> <li>DataHandler2D: Implementation for 2D PDE data handling</li> </ul> Dependencies <ul> <li>tensorflow: For tensor operations</li> <li>numpy: For numerical arrays</li> <li>FESpace2D: For finite element space handling</li> <li>Domain2D: For domain management</li> </ul> Note <p>The implementation follows FastVPINNs methodology [1] for efficient handling of finite element data structures.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D","title":"<code>DataHandler2D</code>","text":"<p>               Bases: <code>DataHandler</code></p> <p>Handles data conversion and management for 2D PDE problems.</p> <p>This class implements the DataHandler interface for 2D problems, providing methods for converting finite element data to tensorflow tensors and managing various aspects of the PDE solution process.</p> <p>Attributes:</p> Name Type Description <code>fespace</code> <p>Finite element space object for mesh and element info</p> <code>domain</code> <p>Domain object for geometric information</p> <code>dtype</code> <p>TensorFlow data type for tensor conversion</p> <code>shape_val_mat_list</code> <p>Tensor of shape function values Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements</p> <code>grad_x_mat_list</code> <p>Tensor of x-derivatives Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements</p> <code>grad_y_mat_list</code> <p>Tensor of y-derivatives Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements</p> <code>x_pde_list</code> <p>Tensor of quadrature point coordinates</p> <code>forcing_function_list</code> <p>Tensor of forcing function values</p> <code>test_points</code> <p>Tensor of test point coordinates</p> Example <p>fespace = FESpace2D(mesh, elements) domain = Domain2D(bounds) handler = DataHandler2D(fespace, domain, tf.float32) dirichlet_input, dirichlet_vals = handler.get_dirichlet_input() test_points = handler.get_test_points()</p> Note <p>All input numpy arrays are assumed to be float64. The class handles conversion to the specified tensorflow dtype (typically float32) for computational efficiency.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>class DataHandler2D(DataHandler):\n    \"\"\"Handles data conversion and management for 2D PDE problems.\n\n    This class implements the DataHandler interface for 2D problems,\n    providing methods for converting finite element data to tensorflow\n    tensors and managing various aspects of the PDE solution process.\n\n    Attributes:\n        fespace: Finite element space object for mesh and element info\n        domain: Domain object for geometric information\n        dtype: TensorFlow data type for tensor conversion\n        shape_val_mat_list: Tensor of shape function values\n            Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements\n        grad_x_mat_list: Tensor of x-derivatives\n            Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements\n        grad_y_mat_list: Tensor of y-derivatives\n            Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements\n        x_pde_list: Tensor of quadrature point coordinates\n        forcing_function_list: Tensor of forcing function values\n        test_points: Tensor of test point coordinates\n\n    Example:\n        &gt;&gt;&gt; fespace = FESpace2D(mesh, elements)\n        &gt;&gt;&gt; domain = Domain2D(bounds)\n        &gt;&gt;&gt; handler = DataHandler2D(fespace, domain, tf.float32)\n        &gt;&gt;&gt; dirichlet_input, dirichlet_vals = handler.get_dirichlet_input()\n        &gt;&gt;&gt; test_points = handler.get_test_points()\n\n    Note:\n        All input numpy arrays are assumed to be float64. The class handles\n        conversion to the specified tensorflow dtype (typically float32)\n        for computational efficiency.\n    \"\"\"\n\n    def __init__(self, fespace, domain, dtype):\n        \"\"\"\n        Constructor for the DataHandler2D class\n\n        Args:\n            fespace (FESpace2D): The FESpace2D object.\n            domain (Domain2D): The Domain2D object.\n            dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n        Returns:\n            None\n        \"\"\"\n        # call the parent class constructor\n        super().__init__(fespace=fespace, domain=domain, dtype=dtype)\n\n        self.shape_val_mat_list = []\n        self.grad_x_mat_list = []\n        self.grad_y_mat_list = []\n        self.x_pde_list = []\n        self.forcing_function_list = []\n\n        # check if the given dtype is a valid tensorflow dtype\n        if not isinstance(self.dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        for cell_index in range(self.fespace.n_cells):\n            shape_val_mat = tf.constant(\n                self.fespace.get_shape_function_val(cell_index), dtype=self.dtype\n            )\n            grad_x_mat = tf.constant(\n                self.fespace.get_shape_function_grad_x(cell_index), dtype=self.dtype\n            )\n            grad_y_mat = tf.constant(\n                self.fespace.get_shape_function_grad_y(cell_index), dtype=self.dtype\n            )\n            x_pde = tf.constant(\n                self.fespace.get_quadrature_actual_coordinates(cell_index),\n                dtype=self.dtype,\n            )\n            forcing_function = tf.constant(\n                self.fespace.get_forcing_function_values(cell_index), dtype=self.dtype\n            )\n            self.shape_val_mat_list.append(shape_val_mat)\n            self.grad_x_mat_list.append(grad_x_mat)\n            self.grad_y_mat_list.append(grad_y_mat)\n            self.x_pde_list.append(x_pde)\n            self.forcing_function_list.append(forcing_function)\n\n        # now convert all the shapes into 3D tensors for easy multiplication\n        # input tensor - x_pde_list\n        self.x_pde_list = tf.reshape(self.x_pde_list, [-1, 2])\n\n        self.forcing_function_list = tf.concat(self.forcing_function_list, axis=1)\n\n        self.shape_val_mat_list = tf.stack(self.shape_val_mat_list, axis=0)\n        self.grad_x_mat_list = tf.stack(self.grad_x_mat_list, axis=0)\n        self.grad_y_mat_list = tf.stack(self.grad_y_mat_list, axis=0)\n\n        # test points\n        self.test_points = None\n\n    def get_dirichlet_input(self) -&gt; tuple:\n        \"\"\"\n        This function will return the input for the Dirichlet boundary data\n\n        Args:\n            None\n\n        Returns:\n            The Dirichlet boundary data as a tuple of tensors\n        \"\"\"\n        input_dirichlet, actual_dirichlet = (\n            self.fespace.generate_dirichlet_boundary_data()\n        )\n\n        # convert to tensors\n        input_dirichlet = tf.constant(input_dirichlet, dtype=self.dtype)\n        actual_dirichlet = tf.constant(actual_dirichlet, dtype=self.dtype)\n        actual_dirichlet = tf.reshape(actual_dirichlet, [-1, 1])\n\n        return input_dirichlet, actual_dirichlet\n\n    def get_test_points(self) -&gt; tf.Tensor:\n        \"\"\"\n        Get the test points for the given domain.\n\n        Args:\n            None\n\n        Returns:\n            The test points as a tensor\n        \"\"\"\n        self.test_points = self.domain.get_test_points()\n        self.test_points = tf.constant(self.test_points, dtype=self.dtype)\n        return self.test_points\n\n    def get_bilinear_params_dict_as_tensors(self, function):\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            function (function): The function from the example file which returns the bilinear parameters dictionary\n\n        Returns:\n            The bilinear parameters dictionary with all the values converted to tensors\n        \"\"\"\n        # get the dictionary of bilinear parameters\n        bilinear_params_dict = function()\n\n        # loop over all keys and convert the values to tensors\n        for key in bilinear_params_dict.keys():\n            bilinear_params_dict[key] = tf.constant(\n                bilinear_params_dict[key], dtype=self.dtype\n            )\n\n        return bilinear_params_dict\n\n    # to be used only in inverse problems\n    def get_sensor_data(\n        self, exact_sol, num_sensor_points, mesh_type, file_name=None\n    ) -&gt; tuple:\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            exact_sol (function): The exact solution function\n            num_sensor_points (int): The number of sensor points\n            mesh_type (str): The type of mesh\n            file_name (str): The file name to save the sensor data\n\n        Returns:\n            The sensor data as a tensor\n\n        Raises:\n            ValueError: If the mesh type is not internal or external\n        \"\"\"\n        print(f\"mesh_type = {mesh_type}\")\n        if mesh_type == \"internal\":\n            # Call the method to get the sensor data\n            points, sensor_values = self.fespace.get_sensor_data(\n                exact_sol, num_sensor_points\n            )\n        elif mesh_type == \"external\":\n            # Call the method to get the sensor data\n            points, sensor_values = self.fespace.get_sensor_data_external(\n                exact_sol, num_sensor_points, file_name\n            )\n        # convert the points and sensor values into tensors\n        points = tf.constant(points, dtype=self.dtype)\n        sensor_values = tf.constant(sensor_values, dtype=self.dtype)\n\n        sensor_values = tf.reshape(sensor_values, [-1, 1])\n        points = tf.reshape(points, [-1, 2])\n\n        return points, sensor_values\n\n    # get inverse param dict as tensors\n    def get_inverse_params(self, inverse_params_dict_function) -&gt; dict:\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n        Returns:\n            The inverse parameters dictionary with all the values converted to tensors\n        \"\"\"\n        # loop over all keys and convert the values to tensors\n\n        inverse_params_dict = inverse_params_dict_function()\n\n        for key in inverse_params_dict.keys():\n            inverse_params_dict[key] = tf.constant(\n                inverse_params_dict[key], dtype=self.dtype\n            )\n\n        return inverse_params_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.__init__","title":"<code>__init__(fespace, domain, dtype)</code>","text":"<p>Constructor for the DataHandler2D class</p> <p>Parameters:</p> Name Type Description Default <code>fespace</code> <code>FESpace2D</code> <p>The FESpace2D object.</p> required <code>domain</code> <code>Domain2D</code> <p>The Domain2D object.</p> required <code>dtype</code> <code>DType</code> <p>The tensorflow dtype to be used for all the tensors.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def __init__(self, fespace, domain, dtype):\n    \"\"\"\n    Constructor for the DataHandler2D class\n\n    Args:\n        fespace (FESpace2D): The FESpace2D object.\n        domain (Domain2D): The Domain2D object.\n        dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n    Returns:\n        None\n    \"\"\"\n    # call the parent class constructor\n    super().__init__(fespace=fespace, domain=domain, dtype=dtype)\n\n    self.shape_val_mat_list = []\n    self.grad_x_mat_list = []\n    self.grad_y_mat_list = []\n    self.x_pde_list = []\n    self.forcing_function_list = []\n\n    # check if the given dtype is a valid tensorflow dtype\n    if not isinstance(self.dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    for cell_index in range(self.fespace.n_cells):\n        shape_val_mat = tf.constant(\n            self.fespace.get_shape_function_val(cell_index), dtype=self.dtype\n        )\n        grad_x_mat = tf.constant(\n            self.fespace.get_shape_function_grad_x(cell_index), dtype=self.dtype\n        )\n        grad_y_mat = tf.constant(\n            self.fespace.get_shape_function_grad_y(cell_index), dtype=self.dtype\n        )\n        x_pde = tf.constant(\n            self.fespace.get_quadrature_actual_coordinates(cell_index),\n            dtype=self.dtype,\n        )\n        forcing_function = tf.constant(\n            self.fespace.get_forcing_function_values(cell_index), dtype=self.dtype\n        )\n        self.shape_val_mat_list.append(shape_val_mat)\n        self.grad_x_mat_list.append(grad_x_mat)\n        self.grad_y_mat_list.append(grad_y_mat)\n        self.x_pde_list.append(x_pde)\n        self.forcing_function_list.append(forcing_function)\n\n    # now convert all the shapes into 3D tensors for easy multiplication\n    # input tensor - x_pde_list\n    self.x_pde_list = tf.reshape(self.x_pde_list, [-1, 2])\n\n    self.forcing_function_list = tf.concat(self.forcing_function_list, axis=1)\n\n    self.shape_val_mat_list = tf.stack(self.shape_val_mat_list, axis=0)\n    self.grad_x_mat_list = tf.stack(self.grad_x_mat_list, axis=0)\n    self.grad_y_mat_list = tf.stack(self.grad_y_mat_list, axis=0)\n\n    # test points\n    self.test_points = None\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_bilinear_params_dict_as_tensors","title":"<code>get_bilinear_params_dict_as_tensors(function)</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>function</code> <p>The function from the example file which returns the bilinear parameters dictionary</p> required <p>Returns:</p> Type Description <p>The bilinear parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_bilinear_params_dict_as_tensors(self, function):\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        function (function): The function from the example file which returns the bilinear parameters dictionary\n\n    Returns:\n        The bilinear parameters dictionary with all the values converted to tensors\n    \"\"\"\n    # get the dictionary of bilinear parameters\n    bilinear_params_dict = function()\n\n    # loop over all keys and convert the values to tensors\n    for key in bilinear_params_dict.keys():\n        bilinear_params_dict[key] = tf.constant(\n            bilinear_params_dict[key], dtype=self.dtype\n        )\n\n    return bilinear_params_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_dirichlet_input","title":"<code>get_dirichlet_input()</code>","text":"<p>This function will return the input for the Dirichlet boundary data</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The Dirichlet boundary data as a tuple of tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_dirichlet_input(self) -&gt; tuple:\n    \"\"\"\n    This function will return the input for the Dirichlet boundary data\n\n    Args:\n        None\n\n    Returns:\n        The Dirichlet boundary data as a tuple of tensors\n    \"\"\"\n    input_dirichlet, actual_dirichlet = (\n        self.fespace.generate_dirichlet_boundary_data()\n    )\n\n    # convert to tensors\n    input_dirichlet = tf.constant(input_dirichlet, dtype=self.dtype)\n    actual_dirichlet = tf.constant(actual_dirichlet, dtype=self.dtype)\n    actual_dirichlet = tf.reshape(actual_dirichlet, [-1, 1])\n\n    return input_dirichlet, actual_dirichlet\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_inverse_params","title":"<code>get_inverse_params(inverse_params_dict_function)</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>inverse_params_dict_function</code> <code>function</code> <p>The function from the example file which returns the inverse parameters dictionary</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The inverse parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_inverse_params(self, inverse_params_dict_function) -&gt; dict:\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n    Returns:\n        The inverse parameters dictionary with all the values converted to tensors\n    \"\"\"\n    # loop over all keys and convert the values to tensors\n\n    inverse_params_dict = inverse_params_dict_function()\n\n    for key in inverse_params_dict.keys():\n        inverse_params_dict[key] = tf.constant(\n            inverse_params_dict[key], dtype=self.dtype\n        )\n\n    return inverse_params_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_sensor_data","title":"<code>get_sensor_data(exact_sol, num_sensor_points, mesh_type, file_name=None)</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function</p> required <code>num_sensor_points</code> <code>int</code> <p>The number of sensor points</p> required <code>mesh_type</code> <code>str</code> <p>The type of mesh</p> required <code>file_name</code> <code>str</code> <p>The file name to save the sensor data</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>The sensor data as a tensor</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mesh type is not internal or external</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_sensor_data(\n    self, exact_sol, num_sensor_points, mesh_type, file_name=None\n) -&gt; tuple:\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        exact_sol (function): The exact solution function\n        num_sensor_points (int): The number of sensor points\n        mesh_type (str): The type of mesh\n        file_name (str): The file name to save the sensor data\n\n    Returns:\n        The sensor data as a tensor\n\n    Raises:\n        ValueError: If the mesh type is not internal or external\n    \"\"\"\n    print(f\"mesh_type = {mesh_type}\")\n    if mesh_type == \"internal\":\n        # Call the method to get the sensor data\n        points, sensor_values = self.fespace.get_sensor_data(\n            exact_sol, num_sensor_points\n        )\n    elif mesh_type == \"external\":\n        # Call the method to get the sensor data\n        points, sensor_values = self.fespace.get_sensor_data_external(\n            exact_sol, num_sensor_points, file_name\n        )\n    # convert the points and sensor values into tensors\n    points = tf.constant(points, dtype=self.dtype)\n    sensor_values = tf.constant(sensor_values, dtype=self.dtype)\n\n    sensor_values = tf.reshape(sensor_values, [-1, 1])\n    points = tf.reshape(points, [-1, 2])\n\n    return points, sensor_values\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_test_points","title":"<code>get_test_points()</code>","text":"<p>Get the test points for the given domain.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>The test points as a tensor</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_test_points(self) -&gt; tf.Tensor:\n    \"\"\"\n    Get the test points for the given domain.\n\n    Args:\n        None\n\n    Returns:\n        The test points as a tensor\n    \"\"\"\n    self.test_points = self.domain.get_test_points()\n    self.test_points = tf.constant(self.test_points, dtype=self.dtype)\n    return self.test_points\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell","title":"<code>FE2D_Cell</code>","text":"<p>A class for managing finite element computations at the cell level.</p> <p>This class handles the storage and computation of finite element values, including basis functions, quadrature rules, and transformations for a single cell in a 2D mesh.</p> <p>Attributes:</p> Name Type Description <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation</code> <code>str</code> <p>Type of geometric transformation</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>basis_function</code> <code>BasisFunction2D</code> <p>Basis function implementation</p> <code>quad_xi</code> <code>ndarray</code> <p>Xi coordinates of quadrature points</p> <code>quad_eta</code> <code>ndarray</code> <p>Eta coordinates of quadrature points</p> <code>quad_weight</code> <code>ndarray</code> <p>Quadrature weights</p> <code>jacobian</code> <code>ndarray</code> <p>Transformation Jacobian</p> <code>basis_at_quad</code> <code>ndarray</code> <p>Basis values at quadrature points</p> <code>basis_gradx_at_quad</code> <code>ndarray</code> <p>X-derivatives at quadrature points</p> <code>basis_grady_at_quad</code> <code>ndarray</code> <p>Y-derivatives at quadrature points</p> <code>quad_actual_coordinates</code> <code>ndarray</code> <p>Physical quadrature point coordinates</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) cell = FE2D_Cell( ...     cell_coordinates=coords, ...     cell_type='quad', ...     fe_order=2, ...     fe_type='lagrange', ...     quad_order=3, ...     quad_type='gauss', ...     fe_transformation_type='bilinear', ...     forcing_function=lambda x, y: x*y ... ) cell.basis_at_quad  # Get basis values at quadrature points</p> Notes <ul> <li>All gradient and derivative values are stored in the reference domain</li> <li>Jacobian and quadrature weights are combined for efficiency</li> <li>Forcing function values are typically computed in the fespace class</li> <li>Supports multiple types of transformations and element types</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>class FE2D_Cell:\n    \"\"\"\n    A class for managing finite element computations at the cell level.\n\n    This class handles the storage and computation of finite element values,\n    including basis functions, quadrature rules, and transformations for a\n    single cell in a 2D mesh.\n\n    Attributes:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n        basis_function (BasisFunction2D): Basis function implementation\n        quad_xi (np.ndarray): Xi coordinates of quadrature points\n        quad_eta (np.ndarray): Eta coordinates of quadrature points\n        quad_weight (np.ndarray): Quadrature weights\n        jacobian (np.ndarray): Transformation Jacobian\n        basis_at_quad (np.ndarray): Basis values at quadrature points\n        basis_gradx_at_quad (np.ndarray): X-derivatives at quadrature points\n        basis_grady_at_quad (np.ndarray): Y-derivatives at quadrature points\n        quad_actual_coordinates (np.ndarray): Physical quadrature point coordinates\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; cell = FE2D_Cell(\n        ...     cell_coordinates=coords,\n        ...     cell_type='quad',\n        ...     fe_order=2,\n        ...     fe_type='lagrange',\n        ...     quad_order=3,\n        ...     quad_type='gauss',\n        ...     fe_transformation_type='bilinear',\n        ...     forcing_function=lambda x, y: x*y\n        ... )\n        &gt;&gt;&gt; cell.basis_at_quad  # Get basis values at quadrature points\n\n    Notes:\n        - All gradient and derivative values are stored in the reference domain\n        - Jacobian and quadrature weights are combined for efficiency\n        - Forcing function values are typically computed in the fespace class\n        - Supports multiple types of transformations and element types\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_coordinates: np.ndarray,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        forcing_function,\n    ):\n        \"\"\"\n        Constructor for the FE2D_Cell class.\n\n        Args:\n            cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n            cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n            fe_order (int): Order of the finite element approximation\n            fe_type (str): Type of finite element basis\n            quad_order (int): Order of quadrature rule\n            quad_type (str): Type of quadrature formula\n            fe_transformation_type (str): Type of geometric transformation\n            forcing_function (callable): Source term function\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_coordinates = cell_coordinates\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.fe_transformation = fe_transformation_type\n        self.forcing_function = forcing_function\n\n        # Basis function Class\n        self.basis_function = None\n\n        # Quadrature Values\n        self.quad_xi = None\n        self.quad_eta = None\n        self.quad_weight = None\n        self.jacobian = None\n        self.mult = None\n\n        # FE Values\n        self.basis_at_quad = None\n        self.basis_gradx_at_quad = None\n        self.basis_grady_at_quad = None\n        self.basis_gradxy_at_quad = None\n        self.basis_gradxx_at_quad = None\n        self.basis_gradyy_at_quad = None\n\n        # Quadrature Coordinates\n        self.quad_actual_coordinates = None\n\n        # Forcing function values at the quadrature points\n        self.forcing_at_quad = None\n\n        # FE Transformation Class\n        self.fetransformation = None\n\n        # get instance of the FE_setup class\n        self.fe_setup = FE2DSetupMain(\n            cell_type=self.cell_type,\n            fe_order=self.fe_order,\n            fe_type=self.fe_type,\n            quad_order=self.quad_order,\n            quad_type=self.quad_type,\n        )\n\n        # Call the function to assign the basis function\n        self.assign_basis_function()\n\n        # Assign the quadrature points and weights\n        self.assign_quadrature()\n\n        # Assign the FE Transformation\n        self.assign_fe_transformation()\n\n        # calculate mult -&gt; quadrature weights * Jacobian\n        self.assign_quad_weights_and_jacobian()\n\n        # Calculate the basis function values at the quadrature points\n        self.assign_basis_values_at_quadrature_points()\n\n        # calculate the actual coordinates of the quadrature points\n        self.assign_quadrature_coordinates()\n\n        # Calculate the forcing function values at the actual quadrature points\n        # NOTE : The function is just for printing the shape of the force matrix, the\n        # actual calculation is performed on the fespace class\n        self.assign_forcing_term(self.forcing_function)\n\n        # # print the values\n        # print(\"============================================================================\")\n        # print(\"Cell Co-ord : \", self.cell_coordinates)\n        # print(\"Basis function values at the quadrature points: \\n\", self.basis_at_quad / self.mult)\n        # print(\"Basis function gradx at the quadrature points: \\n\", self.basis_gradx_at_quad)\n        # print(\"Basis function grady at the quadrature points: \\n\", self.basis_grady_at_quad)\n        # print(\"Forcing function values at the quadrature points: \\n\", self.forcing_at_quad)\n\n        # grad_x = np.array([5,6,7,8])\n        # grad_y = np.array([1,2,3,4])\n\n        # pde = np.matmul(self.basis_gradx_at_quad, grad_x.reshape(-1,1)) + np.matmul(self.basis_grady_at_quad, grad_y.reshape(-1,1))\n        # print(\"PDE values at the quadrature points: \\n\", pde)\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function class based on the cell type and the FE order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function class for the given cell type and FE order.\n        \"\"\"\n        self.basis_function = self.fe_setup.assign_basis_function()\n\n    def assign_quadrature(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_weight, self.quad_xi, self.quad_eta = (\n            self.fe_setup.assign_quadrature_rules()\n        )\n\n    def assign_fe_transformation(self) -&gt; None:\n        \"\"\"\n        Assigns the FE Transformation class based on the cell type and the FE order.\n\n        This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n        It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.fetransformation = self.fe_setup.assign_fe_transformation(\n            self.fe_transformation, self.cell_coordinates\n        )\n        # Sets cell co-ordinates for the FE Transformation\n        self.fetransformation.set_cell()\n\n        # obtains the Jacobian of the transformation\n        self.jacobian = self.fetransformation.get_jacobian(\n            self.quad_xi, self.quad_eta\n        ).reshape(-1, 1)\n\n    def assign_basis_values_at_quadrature_points(self) -&gt; None:\n        \"\"\"\n        Assigns the basis function values at the quadrature points.\n\n        This method calculates the values of the basis functions and their gradients at the quadrature points.\n        The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n        `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n        `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.basis_at_quad = []\n        self.basis_gradx_at_quad = []\n        self.basis_grady_at_quad = []\n        self.basis_gradxy_at_quad = []\n        self.basis_gradxx_at_quad = []\n        self.basis_gradyy_at_quad = []\n\n        self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n        # For Gradients we need to perform a transformation to the original cell\n        grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n        grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n        grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n            grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n        )\n\n        self.basis_gradx_at_quad = grad_x_orig\n        self.basis_grady_at_quad = grad_y_orig\n\n        self.basis_gradx_at_quad_ref = grad_x_ref\n        self.basis_grady_at_quad_ref = grad_y_ref\n\n        # get the double derivatives of the basis functions ( ref co-ordinates )\n        grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n        grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n        grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n        # get the double derivatives of the basis functions ( orig co-ordinates )\n        grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n            self.fetransformation.get_orig_from_ref_second_derivative(\n                grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n            )\n        )\n\n        # = the value\n        self.basis_gradxy_at_quad = grad_xy_orig\n        self.basis_gradxx_at_quad = grad_xx_orig\n        self.basis_gradyy_at_quad = grad_yy_orig\n\n        # Multiply each row with the quadrature weights\n        # Basis at Quad - n_test * N_quad\n        self.basis_at_quad = self.basis_at_quad * self.mult\n        self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n        self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n        self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n        self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n        self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n\n    def assign_quad_weights_and_jacobian(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature weights and the Jacobian of the transformation.\n\n        This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n        for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n        and stored in the `mult` attribute of the class.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.mult = self.quad_weight * self.jacobian.flatten()\n\n    def assign_quadrature_coordinates(self) -&gt; None:\n        \"\"\"\n        Assigns the actual coordinates of the quadrature points.\n\n        This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n        The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n        The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        actual_co_ord = []\n        for xi, eta in zip(self.quad_xi, self.quad_eta):\n            actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n        self.quad_actual_coordinates = np.array(actual_co_ord)\n\n    def assign_forcing_term(self, forcing_function) -&gt; None:\n        \"\"\"\n        Assigns the forcing function values at the quadrature points.\n\n        This function computes the values of the forcing function at the quadrature points\n        and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n        Args:\n            forcing_function (callable): The forcing function to be integrated\n\n        Returns:\n            None\n\n        Notes:\n            - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n            - This function is for backward compatibility with old code and currently assigns\n              the values as zeros. The actual calculation is performed in the fespace class.\n        \"\"\"\n        # get number of shape functions\n        n_shape_functions = self.basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n        # the actual calculation is performed in the fespace class\n\n        # for i in range(n_shape_functions):\n        #     val = 0\n        #     for q in range(self.basis_at_quad.shape[1]):\n        #         x = self.quad_actual_coordinates[q, 0]\n        #         y = self.quad_actual_coordinates[q, 1]\n        #         # print(\"f_values[q] = \",f_values[q])\n\n        #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n        #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n        #         # print(\"val = \", val)\n\n        #     f_integral[i] = val\n\n        self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.__init__","title":"<code>__init__(cell_coordinates, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, forcing_function)</code>","text":"<p>Constructor for the FE2D_Cell class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> required <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> required <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> required <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> required <code>forcing_function</code> <code>callable</code> <p>Source term function</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def __init__(\n    self,\n    cell_coordinates: np.ndarray,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    forcing_function,\n):\n    \"\"\"\n    Constructor for the FE2D_Cell class.\n\n    Args:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_coordinates = cell_coordinates\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.fe_transformation = fe_transformation_type\n    self.forcing_function = forcing_function\n\n    # Basis function Class\n    self.basis_function = None\n\n    # Quadrature Values\n    self.quad_xi = None\n    self.quad_eta = None\n    self.quad_weight = None\n    self.jacobian = None\n    self.mult = None\n\n    # FE Values\n    self.basis_at_quad = None\n    self.basis_gradx_at_quad = None\n    self.basis_grady_at_quad = None\n    self.basis_gradxy_at_quad = None\n    self.basis_gradxx_at_quad = None\n    self.basis_gradyy_at_quad = None\n\n    # Quadrature Coordinates\n    self.quad_actual_coordinates = None\n\n    # Forcing function values at the quadrature points\n    self.forcing_at_quad = None\n\n    # FE Transformation Class\n    self.fetransformation = None\n\n    # get instance of the FE_setup class\n    self.fe_setup = FE2DSetupMain(\n        cell_type=self.cell_type,\n        fe_order=self.fe_order,\n        fe_type=self.fe_type,\n        quad_order=self.quad_order,\n        quad_type=self.quad_type,\n    )\n\n    # Call the function to assign the basis function\n    self.assign_basis_function()\n\n    # Assign the quadrature points and weights\n    self.assign_quadrature()\n\n    # Assign the FE Transformation\n    self.assign_fe_transformation()\n\n    # calculate mult -&gt; quadrature weights * Jacobian\n    self.assign_quad_weights_and_jacobian()\n\n    # Calculate the basis function values at the quadrature points\n    self.assign_basis_values_at_quadrature_points()\n\n    # calculate the actual coordinates of the quadrature points\n    self.assign_quadrature_coordinates()\n\n    # Calculate the forcing function values at the actual quadrature points\n    # NOTE : The function is just for printing the shape of the force matrix, the\n    # actual calculation is performed on the fespace class\n    self.assign_forcing_term(self.forcing_function)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function class based on the cell type and the FE order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function class for the given cell type and FE order.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function class based on the cell type and the FE order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function class for the given cell type and FE order.\n    \"\"\"\n    self.basis_function = self.fe_setup.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_basis_values_at_quadrature_points","title":"<code>assign_basis_values_at_quadrature_points()</code>","text":"<p>Assigns the basis function values at the quadrature points.</p> <p>This method calculates the values of the basis functions and their gradients at the quadrature points. The basis function values are stored in <code>self.basis_at_quad</code>, while the gradients are stored in <code>self.basis_gradx_at_quad</code>, <code>self.basis_grady_at_quad</code>, <code>self.basis_gradxy_at_quad</code>, <code>self.basis_gradxx_at_quad</code>, and <code>self.basis_gradyy_at_quad</code>.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_values_at_quadrature_points(self) -&gt; None:\n    \"\"\"\n    Assigns the basis function values at the quadrature points.\n\n    This method calculates the values of the basis functions and their gradients at the quadrature points.\n    The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n    `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n    `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.basis_at_quad = []\n    self.basis_gradx_at_quad = []\n    self.basis_grady_at_quad = []\n    self.basis_gradxy_at_quad = []\n    self.basis_gradxx_at_quad = []\n    self.basis_gradyy_at_quad = []\n\n    self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n    # For Gradients we need to perform a transformation to the original cell\n    grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n    grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n    grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n        grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n    )\n\n    self.basis_gradx_at_quad = grad_x_orig\n    self.basis_grady_at_quad = grad_y_orig\n\n    self.basis_gradx_at_quad_ref = grad_x_ref\n    self.basis_grady_at_quad_ref = grad_y_ref\n\n    # get the double derivatives of the basis functions ( ref co-ordinates )\n    grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n    grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n    grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n    # get the double derivatives of the basis functions ( orig co-ordinates )\n    grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n        self.fetransformation.get_orig_from_ref_second_derivative(\n            grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n        )\n    )\n\n    # = the value\n    self.basis_gradxy_at_quad = grad_xy_orig\n    self.basis_gradxx_at_quad = grad_xx_orig\n    self.basis_gradyy_at_quad = grad_yy_orig\n\n    # Multiply each row with the quadrature weights\n    # Basis at Quad - n_test * N_quad\n    self.basis_at_quad = self.basis_at_quad * self.mult\n    self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n    self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n    self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n    self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n    self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_fe_transformation","title":"<code>assign_fe_transformation()</code>","text":"<p>Assigns the FE Transformation class based on the cell type and the FE order.</p> <p>This method assigns the appropriate FE Transformation class based on the cell type and the FE order. It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_fe_transformation(self) -&gt; None:\n    \"\"\"\n    Assigns the FE Transformation class based on the cell type and the FE order.\n\n    This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n    It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.fetransformation = self.fe_setup.assign_fe_transformation(\n        self.fe_transformation, self.cell_coordinates\n    )\n    # Sets cell co-ordinates for the FE Transformation\n    self.fetransformation.set_cell()\n\n    # obtains the Jacobian of the transformation\n    self.jacobian = self.fetransformation.get_jacobian(\n        self.quad_xi, self.quad_eta\n    ).reshape(-1, 1)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_forcing_term","title":"<code>assign_forcing_term(forcing_function)</code>","text":"<p>Assigns the forcing function values at the quadrature points.</p> <p>This function computes the values of the forcing function at the quadrature points and assigns them to the <code>forcing_at_quad</code> attribute of the FE2D_Cell object.</p> <p>Parameters:</p> Name Type Description Default <code>forcing_function</code> <code>callable</code> <p>The forcing function to be integrated</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Notes <ul> <li>The final shape of <code>forcing_at_quad</code> will be N_shape_functions x 1.</li> <li>This function is for backward compatibility with old code and currently assigns   the values as zeros. The actual calculation is performed in the fespace class.</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_forcing_term(self, forcing_function) -&gt; None:\n    \"\"\"\n    Assigns the forcing function values at the quadrature points.\n\n    This function computes the values of the forcing function at the quadrature points\n    and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n    Args:\n        forcing_function (callable): The forcing function to be integrated\n\n    Returns:\n        None\n\n    Notes:\n        - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n        - This function is for backward compatibility with old code and currently assigns\n          the values as zeros. The actual calculation is performed in the fespace class.\n    \"\"\"\n    # get number of shape functions\n    n_shape_functions = self.basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n    # the actual calculation is performed in the fespace class\n\n    # for i in range(n_shape_functions):\n    #     val = 0\n    #     for q in range(self.basis_at_quad.shape[1]):\n    #         x = self.quad_actual_coordinates[q, 0]\n    #         y = self.quad_actual_coordinates[q, 1]\n    #         # print(\"f_values[q] = \",f_values[q])\n\n    #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n    #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n    #         # print(\"val = \", val)\n\n    #     f_integral[i] = val\n\n    self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_quad_weights_and_jacobian","title":"<code>assign_quad_weights_and_jacobian()</code>","text":"<p>Assigns the quadrature weights and the Jacobian of the transformation.</p> <p>This method calculates and assigns the quadrature weights and the Jacobian of the transformation for the current cell. The quadrature weights are multiplied by the flattened Jacobian array and stored in the <code>mult</code> attribute of the class.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quad_weights_and_jacobian(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature weights and the Jacobian of the transformation.\n\n    This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n    for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n    and stored in the `mult` attribute of the class.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.mult = self.quad_weight * self.jacobian.flatten()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_quadrature","title":"<code>assign_quadrature()</code>","text":"<p>Assigns the quadrature points and weights based on the cell type and the quadrature order.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_weight, self.quad_xi, self.quad_eta = (\n        self.fe_setup.assign_quadrature_rules()\n    )\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_quadrature_coordinates","title":"<code>assign_quadrature_coordinates()</code>","text":"<p>Assigns the actual coordinates of the quadrature points.</p> <p>This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values. The Xi and Eta values are obtained from the <code>quad_xi</code> and <code>quad_eta</code> attributes of the class. The calculated coordinates are stored in the <code>quad_actual_coordinates</code> attribute as a NumPy array.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature_coordinates(self) -&gt; None:\n    \"\"\"\n    Assigns the actual coordinates of the quadrature points.\n\n    This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n    The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n    The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    actual_co_ord = []\n    for xi, eta in zip(self.quad_xi, self.quad_eta):\n        actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n    self.quad_actual_coordinates = np.array(actual_co_ord)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace","title":"<code>Fespace</code>","text":"<p>Abstract base class defining the interface for finite element spaces.</p> <p>This class provides the foundation for implementing finite element spaces, including mesh handling, element operations, and solution computations.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <p>Mesh object containing geometric information</p> <code>cells</code> <code>ndarray</code> <p>Array of cell indices</p> <code>boundary_points</code> <code>dict</code> <p>Dictionary of boundary point information</p> <code>cell_type</code> <code>str</code> <p>Type of finite element cell</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> <code>bound_function_dict</code> <code>dict</code> <p>Dictionary of boundary condition functions</p> <code>bound_condition_dict</code> <code>dict</code> <p>Dictionary of boundary condition types</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>output_path</code> <code>str</code> <p>Path for output files</p> Example <p>class MyFespace(Fespace): ...     def set_finite_elements(self): ...         # Implementation ...         pass ...     def generate_dirichlet_boundary_data(self): ...         # Implementation ...         pass ...     # Implement other abstract methods</p> Notes <ul> <li>All coordinate transformations must be implemented</li> <li>Shape function values and gradients are available in both reference and physical spaces</li> <li>Supports both internal and external sensor data for inverse problems</li> <li>Boundary conditions must be properly specified through the boundary dictionaries</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>class Fespace:\n    \"\"\"\n    Abstract base class defining the interface for finite element spaces.\n\n    This class provides the foundation for implementing finite element spaces,\n    including mesh handling, element operations, and solution computations.\n\n    Attributes:\n        mesh: Mesh object containing geometric information\n        cells (ndarray): Array of cell indices\n        boundary_points (dict): Dictionary of boundary point information\n        cell_type (str): Type of finite element cell\n        fe_order (int): Order of finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        bound_function_dict (dict): Dictionary of boundary condition functions\n        bound_condition_dict (dict): Dictionary of boundary condition types\n        forcing_function (callable): Source term function\n        output_path (str): Path for output files\n\n    Example:\n        &gt;&gt;&gt; class MyFespace(Fespace):\n        ...     def set_finite_elements(self):\n        ...         # Implementation\n        ...         pass\n        ...     def generate_dirichlet_boundary_data(self):\n        ...         # Implementation\n        ...         pass\n        ...     # Implement other abstract methods\n\n    Notes:\n        - All coordinate transformations must be implemented\n        - Shape function values and gradients are available in both\n        reference and physical spaces\n        - Supports both internal and external sensor data for\n        inverse problems\n        - Boundary conditions must be properly specified through\n        the boundary dictionaries\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n\n        Args:\n            mesh: The mesh object.\n            cells: The cells of the mesh.\n            boundary_points: The boundary points of the mesh.\n            cell_type: The type of the cell.\n            fe_order: The order of the finite element.\n            fe_type: The type of the finite element.\n            quad_order: The order of the quadrature.\n            quad_type: The type of the quadrature.\n            fe_transformation_type: The type of the finite element transformation.\n            bound_function_dict: The dictionary of the boundary functions.\n            bound_condition_dict: The dictionary of the boundary conditions.\n            forcing_function: The forcing function.\n            output_path: The path to the output directory.\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh = mesh\n        self.boundary_points = boundary_points\n        self.cells = cells\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.fe_transformation_type = fe_transformation_type\n        self.output_path = output_path\n        self.bound_function_dict = bound_function_dict\n        self.bound_condition_dict = bound_condition_dict\n        self.forcing_function = forcing_function\n\n    @abstractmethod\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data.\n\n        This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            np.ndarray: The boundary points and their values.\n\n        Notes:\n            The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual values of the shape functions.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n\n    @abstractmethod\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n            object.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        Args:\n            exact_solution (ndarray): The exact solution values.\n            num_points (int): The number of points to sample from the domain.\n\n        Returns:\n            np.ndarray: The sensor data at the given points.\n\n        Notes:\n            This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n            Methodologies to obtain sensor data for problems from a file are not implemented yet.\n            It is also not implemented for external or complex meshes.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data_external(\n        self, exact_sol, num_points: int, file_name: str\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n        Args:\n            exact_sol: The exact solution values.\n            num_points: The number of points to sample from the domain.\n            file_name: The name of the file containing the sensor data.\n\n        Returns:\n            np.ndarray: The sensor data at the given points based on the external file.\n\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path)</code>","text":"<p>The constructor of the Fespace2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <p>The mesh object.</p> required <code>cells</code> <p>The cells of the mesh.</p> required <code>boundary_points</code> <p>The boundary points of the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell.</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element.</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature.</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation.</p> required <code>bound_function_dict</code> <code>dict</code> <p>The dictionary of the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>The dictionary of the boundary conditions.</p> required <code>forcing_function</code> <p>The forcing function.</p> required <code>output_path</code> <code>str</code> <p>The path to the output directory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n\n    Args:\n        mesh: The mesh object.\n        cells: The cells of the mesh.\n        boundary_points: The boundary points of the mesh.\n        cell_type: The type of the cell.\n        fe_order: The order of the finite element.\n        fe_type: The type of the finite element.\n        quad_order: The order of the quadrature.\n        quad_type: The type of the quadrature.\n        fe_transformation_type: The type of the finite element transformation.\n        bound_function_dict: The dictionary of the boundary functions.\n        bound_condition_dict: The dictionary of the boundary conditions.\n        forcing_function: The forcing function.\n        output_path: The path to the output directory.\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh = mesh\n    self.boundary_points = boundary_points\n    self.cells = cells\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.fe_transformation_type = fe_transformation_type\n    self.output_path = output_path\n    self.bound_function_dict = bound_function_dict\n    self.bound_condition_dict = bound_condition_dict\n    self.forcing_function = forcing_function\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>  <code>abstractmethod</code>","text":"<p>Generate Dirichlet boundary data.</p> <p>This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The boundary points and their values.</p> Notes <p>The boundary points and values are stored in the <code>boundary_points</code> attribute of the <code>Fespace</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data.\n\n    This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        np.ndarray: The boundary points and their values.\n\n    Notes:\n        The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object. The forcing function is evaluated using the <code>forcing_function</code> method of the <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n        object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>  <code>abstractmethod</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>ndarray</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points.</p> Notes <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    Args:\n        exact_solution (ndarray): The exact solution values.\n        num_points (int): The number of points to sample from the domain.\n\n    Returns:\n        np.ndarray: The sensor data at the given points.\n\n    Notes:\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>  <code>abstractmethod</code>","text":"<p>This method is used to obtain the sensor data from an external file when there is no analytical solution available.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points based on the external file.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data_external(\n    self, exact_sol, num_points: int, file_name: str\n) -&gt; np.ndarray:\n    \"\"\"\n    This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n    Args:\n        exact_sol: The exact solution values.\n        num_points: The number of points to sample from the domain.\n        file_name: The name of the file containing the sensor data.\n\n    Returns:\n        np.ndarray: The sensor data at the given points based on the external file.\n\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to y.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual values of the shape functions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual values of the shape functions.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.set_finite_elements","title":"<code>set_finite_elements()</code>  <code>abstractmethod</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D","title":"<code>Fespace2D</code>","text":"<p>               Bases: <code>Fespace</code></p> <p>Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces, including mesh generation, basis function evaluation, and boundary condition handling.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh object containing the mesh information.</p> required <code>cells</code> <code>ndarray</code> <p>The cell information from the mesh.</p> required <code>boundary_points</code> <code>dict</code> <p>The boundary points information from the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell (e.g., 'quadrilateral').</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element basis functions.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element basis functions (e.g., 'legendre').</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature rule.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature rule (e.g., 'gauss-legendre').</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation (e.g., 'affine').</p> required <code>bound_function_dict</code> <code>dict</code> <p>A dictionary containing the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>A dictionary containing the boundary conditions.</p> required <code>forcing_function</code> <code>function</code> <p>The forcing function for the problem.</p> required <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <code>generate_mesh_plot</code> <code>bool</code> <p>Flag to generate the mesh plot (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is not supported.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>class Fespace2D(Fespace):\n    \"\"\"\n    Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces,\n    including mesh generation, basis function evaluation, and boundary condition handling.\n\n    Args:\n        mesh (meshio.Mesh): The mesh object containing the mesh information.\n        cells (np.ndarray): The cell information from the mesh.\n        boundary_points (dict): The boundary points information from the mesh.\n        cell_type (str): The type of the cell (e.g., 'quadrilateral').\n        fe_order (int): The order of the finite element basis functions.\n        fe_type (str): The type of the finite element basis functions (e.g., 'legendre').\n        quad_order (int): The order of the quadrature rule.\n        quad_type (str): The type of the quadrature rule (e.g., 'gauss-legendre').\n        fe_transformation_type (str): The type of the finite element transformation (e.g., 'affine').\n        bound_function_dict (dict): A dictionary containing the boundary functions.\n        bound_condition_dict (dict): A dictionary containing the boundary conditions.\n        forcing_function (function): The forcing function for the problem.\n        output_path (str): The path to save the output files.\n        generate_mesh_plot (bool): Flag to generate the mesh plot (default: False).\n\n    Raises:\n        ValueError: If the cell type is not supported.\n\n    Returns:\n        None\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n        generate_mesh_plot: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n        \"\"\"\n        # call the constructor of the parent class\n        super().__init__(\n            mesh=mesh,\n            cells=cells,\n            boundary_points=boundary_points,\n            cell_type=cell_type,\n            fe_order=fe_order,\n            fe_type=fe_type,\n            quad_order=quad_order,\n            quad_type=quad_type,\n            fe_transformation_type=fe_transformation_type,\n            bound_function_dict=bound_function_dict,\n            bound_condition_dict=bound_condition_dict,\n            forcing_function=forcing_function,\n            output_path=output_path,\n        )\n\n        if self.cell_type == \"triangle\":\n            raise ValueError(\n                \"Triangle Mesh is not supported yet\"\n            )  # added by thivin - to remove support for triangular mesh\n\n        self.generate_mesh_plot = generate_mesh_plot\n\n        # to be calculated in the plot function\n        self.total_dofs = 0\n        self.total_boundary_dofs = 0\n\n        # to be calculated on get_boundary_data_dirichlet function\n        self.total_dirichlet_dofs = 0\n\n        # get the number of cells\n        self.n_cells = self.cells.shape[0]\n\n        self.fe_cell = []\n\n        # Function which assigns the fe_cell for each cell\n        self.set_finite_elements()\n\n        # generate the plot of the mesh\n        if self.generate_mesh_plot:\n            self.generate_plot(self.output_path)\n        # self.generate_plot(self.output_path)\n\n        # Obtain boundary Data\n        self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n        title = [\n            \"Number of Cells\",\n            \"Number of Quadrature Points\",\n            \"Number of Dirichlet Boundary Points\",\n            \"Quadrature Order\",\n            \"fe Order\",\n            \"fe Type\",\n            \"fe Transformation Type\",\n        ]\n        values = [\n            self.n_cells,\n            self.total_dofs,\n            self.total_dirichlet_dofs,\n            self.quad_order,\n            self.fe_order,\n            self.fe_type,\n            self.fe_transformation_type,\n        ]\n        # print the table\n        print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        :return: None\n        \"\"\"\n        progress_bar = tqdm(\n            total=self.n_cells,\n            desc=\"Fe2D_cell Setup\",\n            unit=\"cells_assembled\",\n            bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n            colour=\"blue\",\n            ncols=100,\n        )\n\n        dof = 0\n        for i in range(self.n_cells):\n            self.fe_cell.append(\n                FE2D_Cell(\n                    self.cells[i],\n                    self.cell_type,\n                    self.fe_order,\n                    self.fe_type,\n                    self.quad_order,\n                    self.quad_type,\n                    self.fe_transformation_type,\n                    self.forcing_function,\n                )\n            )\n\n            # obtain the shape of the basis function (n_test, N_quad)\n            dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n            progress_bar.update(1)\n        # print the Shape details of all the matrices from cell 0 using print_table function\n        title = [\n            \"Shape function Matrix Shape\",\n            \"Shape function Gradient Matrix Shape\",\n            \"Jacobian Matrix Shape\",\n            \"Quadrature Points Shape\",\n            \"Quadrature Weights Shape\",\n            \"Quadrature Actual Coordinates Shape\",\n            \"Forcing Function Shape\",\n        ]\n        values = [\n            self.fe_cell[0].basis_at_quad.shape,\n            self.fe_cell[0].basis_gradx_at_quad.shape,\n            self.fe_cell[0].jacobian.shape,\n            self.fe_cell[0].quad_xi.shape,\n            self.fe_cell[0].quad_weight.shape,\n            self.fe_cell[0].quad_actual_coordinates.shape,\n            self.fe_cell[0].forcing_at_quad.shape,\n        ]\n        print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n        # update the total number of dofs\n        self.total_dofs = dof\n\n    def generate_plot(self, output_path) -&gt; None:\n        \"\"\"\n        Generate a plot of the mesh.\n\n        Args:\n            output_path (str): The path to save the output files.\n\n        Returns:\n            None\n        \"\"\"\n        total_quad = 0\n        marker_list = [\n            \"o\",\n            \".\",\n            \",\",\n            \"x\",\n            \"+\",\n            \"P\",\n            \"s\",\n            \"D\",\n            \"d\",\n            \"^\",\n            \"v\",\n            \"&lt;\",\n            \"&gt;\",\n            \"p\",\n            \"h\",\n            \"H\",\n        ]\n\n        print(f\"[INFO] : Generating the plot of the mesh\")\n        # Plot the mesh\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # label flag ( to add the label only once)\n        label_set = False\n\n        # plot every cell as a quadrilateral\n        # loop over all the cells\n        for i in range(self.n_cells):\n            # get the coordinates of the cell\n            x = self.fe_cell[i].cell_coordinates[:, 0]\n            y = self.fe_cell[i].cell_coordinates[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            plt.plot(x, y, \"k-\", linewidth=0.5)\n\n            # plot the quadrature points\n            x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n            y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n            total_quad += x_quad.shape[0]\n\n            if not label_set:\n                plt.scatter(\n                    x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n                )\n                label_set = True\n            else:\n                plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n        self.total_dofs = total_quad\n\n        bound_dof = 0\n        # plot the boundary points\n        # loop over all the boundary tags\n        for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n            # get the coordinates of the boundary points\n            x = bound_pts[:, 0]\n            y = bound_pts[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            bound_dof += x.shape[0]\n\n            plt.scatter(\n                x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n            )\n\n        self.total_boundary_dofs = bound_dof\n\n        plt.legend(bbox_to_anchor=(0.85, 1.02))\n        plt.axis(\"equal\")\n        plt.axis(\"off\")\n        plt.tight_layout()\n\n        plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n        plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n        # print the total number of quadrature points\n        print(f\"Plots generated\")\n        print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n        print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n        print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n                ).reshape(-1, 1)\n                y.append(val)\n\n        print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n        self.total_dirichlet_dofs = len(x)\n        print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n        print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n        return x, y\n\n    def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n        \"\"\"\n        Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n        Args:\n            component (int): The component of the boundary data vector.\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                    dtype=np.float64,\n                ).reshape(-1, 1)\n                y.append(val)\n\n        return x, y\n\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_at_quad.copy()\n\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n\n    def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Return the quadrature weights for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n        Returns:\n            np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n        Raises:\n            ValueError: If cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].mult.copy()\n\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n        # so that it can be used to handle multiple dimensions on a vector valud problem\n\n        # get number of shape functions\n        n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        for i in range(n_shape_functions):\n            val = 0\n            for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n                x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n                y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n                # print(\"f_values[q] = \",f_values[q])\n\n                # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n                val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                    cell_index\n                ].forcing_function(x, y)\n                # print(\"val = \", val)\n\n            f_integral[i] = val\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_forcing_function_values_vector(\n        self, cell_index: int, component: int\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This function will return the forcing function values at the quadrature points\n        based on the Component of the RHS Needed, for vector valued problems\n\n        Args:\n            cell_index (int): The index of the cell.\n            component (int): The component of the forcing function.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # get the coordinates\n        x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n        y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n        # compute the forcing function values\n        f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n        # compute the integral\n        f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_sensor_data(self, exact_solution, num_points: int):\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n        Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n\n        Args:\n            exact_solution (function): The exact solution function.\n            num_points (int): The number of points to sample.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n        \"\"\"\n        # generate random points within the bounds of the domain\n        # get the bounds of the domain\n        x_min = np.min(self.mesh.points[:, 0])\n        x_max = np.max(self.mesh.points[:, 0])\n        y_min = np.min(self.mesh.points[:, 1])\n        y_max = np.max(self.mesh.points[:, 1])\n        # sample n random points within the bounds of the domain\n        # Generate points in the unit square\n\n        num_internal_points = int(num_points * 0.9)\n\n        points = lhs(2, samples=num_internal_points)\n        points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n        points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n        # get the exact solution at the points\n        exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n        # print the shape of the points and the exact solution\n        print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n        print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n        # plot the points\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n        plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n        plt.axis(\"equal\")\n        plt.title(\"Sensor Points\")\n        plt.tight_layout()\n        plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n        return points, exact_sol\n\n    def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n        \"\"\"\n        This method is used to obtain the sensor data from an external file.\n\n        Args:\n            exact_sol (function): The exact solution function.\n            num_points (int): The number of points to sample.\n            file_name (str): The name of the file containing the sensor data.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n        Note:\n            This method reads the sensor data from a file and samples `num_points` from the data.\n            The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n        \"\"\"\n        # use pandas to read the file\n        df = pd.read_csv(file_name)\n\n        x = df.iloc[:, 0].values\n        y = df.iloc[:, 1].values\n        exact_sol = df.iloc[:, 2].values\n\n        # now sample num_points from the data\n        indices = np.random.randint(0, x.shape[0], num_points)\n\n        x = x[indices]\n        y = y[indices]\n        exact_sol = exact_sol[indices]\n\n        # stack them together\n        points = np.stack((x, y), axis=1)\n\n        return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path, generate_mesh_plot=False)</code>","text":"<p>The constructor of the Fespace2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n    generate_mesh_plot: bool = False,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n    \"\"\"\n    # call the constructor of the parent class\n    super().__init__(\n        mesh=mesh,\n        cells=cells,\n        boundary_points=boundary_points,\n        cell_type=cell_type,\n        fe_order=fe_order,\n        fe_type=fe_type,\n        quad_order=quad_order,\n        quad_type=quad_type,\n        fe_transformation_type=fe_transformation_type,\n        bound_function_dict=bound_function_dict,\n        bound_condition_dict=bound_condition_dict,\n        forcing_function=forcing_function,\n        output_path=output_path,\n    )\n\n    if self.cell_type == \"triangle\":\n        raise ValueError(\n            \"Triangle Mesh is not supported yet\"\n        )  # added by thivin - to remove support for triangular mesh\n\n    self.generate_mesh_plot = generate_mesh_plot\n\n    # to be calculated in the plot function\n    self.total_dofs = 0\n    self.total_boundary_dofs = 0\n\n    # to be calculated on get_boundary_data_dirichlet function\n    self.total_dirichlet_dofs = 0\n\n    # get the number of cells\n    self.n_cells = self.cells.shape[0]\n\n    self.fe_cell = []\n\n    # Function which assigns the fe_cell for each cell\n    self.set_finite_elements()\n\n    # generate the plot of the mesh\n    if self.generate_mesh_plot:\n        self.generate_plot(self.output_path)\n    # self.generate_plot(self.output_path)\n\n    # Obtain boundary Data\n    self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n    title = [\n        \"Number of Cells\",\n        \"Number of Quadrature Points\",\n        \"Number of Dirichlet Boundary Points\",\n        \"Quadrature Order\",\n        \"fe Order\",\n        \"fe Type\",\n        \"fe Transformation Type\",\n    ]\n    values = [\n        self.n_cells,\n        self.total_dofs,\n        self.total_dirichlet_dofs,\n        self.quad_order,\n        self.fe_order,\n        self.fe_type,\n        self.fe_transformation_type,\n    ]\n    # print the table\n    print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>","text":"<p>Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n            ).reshape(-1, 1)\n            y.append(val)\n\n    print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n    self.total_dirichlet_dofs = len(x)\n    print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n    print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.generate_dirichlet_boundary_data_vector","title":"<code>generate_dirichlet_boundary_data_vector(component)</code>","text":"<p>Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>int</code> <p>The component of the boundary data vector.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n    \"\"\"\n    Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n    Args:\n        component (int): The component of the boundary data vector.\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                dtype=np.float64,\n            ).reshape(-1, 1)\n            y.append(val)\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.generate_plot","title":"<code>generate_plot(output_path)</code>","text":"<p>Generate a plot of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_plot(self, output_path) -&gt; None:\n    \"\"\"\n    Generate a plot of the mesh.\n\n    Args:\n        output_path (str): The path to save the output files.\n\n    Returns:\n        None\n    \"\"\"\n    total_quad = 0\n    marker_list = [\n        \"o\",\n        \".\",\n        \",\",\n        \"x\",\n        \"+\",\n        \"P\",\n        \"s\",\n        \"D\",\n        \"d\",\n        \"^\",\n        \"v\",\n        \"&lt;\",\n        \"&gt;\",\n        \"p\",\n        \"h\",\n        \"H\",\n    ]\n\n    print(f\"[INFO] : Generating the plot of the mesh\")\n    # Plot the mesh\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # label flag ( to add the label only once)\n    label_set = False\n\n    # plot every cell as a quadrilateral\n    # loop over all the cells\n    for i in range(self.n_cells):\n        # get the coordinates of the cell\n        x = self.fe_cell[i].cell_coordinates[:, 0]\n        y = self.fe_cell[i].cell_coordinates[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        plt.plot(x, y, \"k-\", linewidth=0.5)\n\n        # plot the quadrature points\n        x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n        y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n        total_quad += x_quad.shape[0]\n\n        if not label_set:\n            plt.scatter(\n                x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n            )\n            label_set = True\n        else:\n            plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n    self.total_dofs = total_quad\n\n    bound_dof = 0\n    # plot the boundary points\n    # loop over all the boundary tags\n    for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n        # get the coordinates of the boundary points\n        x = bound_pts[:, 0]\n        y = bound_pts[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        bound_dof += x.shape[0]\n\n        plt.scatter(\n            x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n        )\n\n    self.total_boundary_dofs = bound_dof\n\n    plt.legend(bbox_to_anchor=(0.85, 1.02))\n    plt.axis(\"equal\")\n    plt.axis(\"off\")\n    plt.tight_layout()\n\n    plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n    plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n    # print the total number of quadrature points\n    print(f\"Plots generated\")\n    print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n    print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n    print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n    # so that it can be used to handle multiple dimensions on a vector valud problem\n\n    # get number of shape functions\n    n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    for i in range(n_shape_functions):\n        val = 0\n        for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n            x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n            y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n            # print(\"f_values[q] = \",f_values[q])\n\n            # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n            val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                cell_index\n            ].forcing_function(x, y)\n            # print(\"val = \", val)\n\n        f_integral[i] = val\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_forcing_function_values_vector","title":"<code>get_forcing_function_values_vector(cell_index, component)</code>","text":"<p>This function will return the forcing function values at the quadrature points based on the Component of the RHS Needed, for vector valued problems</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <code>component</code> <code>int</code> <p>The component of the forcing function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values_vector(\n    self, cell_index: int, component: int\n) -&gt; np.ndarray:\n    \"\"\"\n    This function will return the forcing function values at the quadrature points\n    based on the Component of the RHS Needed, for vector valued problems\n\n    Args:\n        cell_index (int): The index of the cell.\n        component (int): The component of the forcing function.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # get the coordinates\n    x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n    y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n    # compute the forcing function values\n    f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n    # compute the integral\n    f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_quadrature_weights","title":"<code>get_quadrature_weights(cell_index)</code>","text":"<p>Return the quadrature weights for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell for which the quadrature weights are needed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Return the quadrature weights for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n    Returns:\n        np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n    Raises:\n        ValueError: If cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].mult.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data(self, exact_solution, num_points: int):\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n    Currently, it only works for problems with an analytical solution.\n    Methodologies to obtain sensor data for problems from a file are not implemented yet.\n    It is also not implemented for external or complex meshes.\n\n    Args:\n        exact_solution (function): The exact solution function.\n        num_points (int): The number of points to sample.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n    \"\"\"\n    # generate random points within the bounds of the domain\n    # get the bounds of the domain\n    x_min = np.min(self.mesh.points[:, 0])\n    x_max = np.max(self.mesh.points[:, 0])\n    y_min = np.min(self.mesh.points[:, 1])\n    y_max = np.max(self.mesh.points[:, 1])\n    # sample n random points within the bounds of the domain\n    # Generate points in the unit square\n\n    num_internal_points = int(num_points * 0.9)\n\n    points = lhs(2, samples=num_internal_points)\n    points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n    points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n    # get the exact solution at the points\n    exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n    # print the shape of the points and the exact solution\n    print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n    print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n    # plot the points\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n    plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n    plt.axis(\"equal\")\n    plt.title(\"Sensor Points\")\n    plt.tight_layout()\n    plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>","text":"<p>This method is used to obtain the sensor data from an external file.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Note <p>This method reads the sensor data from a file and samples <code>num_points</code> from the data. The sensor data is then returned as a tuple containing the sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n    \"\"\"\n    This method is used to obtain the sensor data from an external file.\n\n    Args:\n        exact_sol (function): The exact solution function.\n        num_points (int): The number of points to sample.\n        file_name (str): The name of the file containing the sensor data.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n    Note:\n        This method reads the sensor data from a file and samples `num_points` from the data.\n        The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n    \"\"\"\n    # use pandas to read the file\n    df = pd.read_csv(file_name)\n\n    x = df.iloc[:, 0].values\n    y = df.iloc[:, 1].values\n    exact_sol = df.iloc[:, 2].values\n\n    # now sample num_points from the data\n    indices = np.random.randint(0, x.shape[0], num_points)\n\n    x = x[indices]\n    y = y[indices]\n    exact_sol = exact_sol[indices]\n\n    # stack them together\n    points = np.stack((x, y), axis=1)\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.set_finite_elements","title":"<code>set_finite_elements()</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    :return: None\n    \"\"\"\n    progress_bar = tqdm(\n        total=self.n_cells,\n        desc=\"Fe2D_cell Setup\",\n        unit=\"cells_assembled\",\n        bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n        colour=\"blue\",\n        ncols=100,\n    )\n\n    dof = 0\n    for i in range(self.n_cells):\n        self.fe_cell.append(\n            FE2D_Cell(\n                self.cells[i],\n                self.cell_type,\n                self.fe_order,\n                self.fe_type,\n                self.quad_order,\n                self.quad_type,\n                self.fe_transformation_type,\n                self.forcing_function,\n            )\n        )\n\n        # obtain the shape of the basis function (n_test, N_quad)\n        dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n        progress_bar.update(1)\n    # print the Shape details of all the matrices from cell 0 using print_table function\n    title = [\n        \"Shape function Matrix Shape\",\n        \"Shape function Gradient Matrix Shape\",\n        \"Jacobian Matrix Shape\",\n        \"Quadrature Points Shape\",\n        \"Quadrature Weights Shape\",\n        \"Quadrature Actual Coordinates Shape\",\n        \"Forcing Function Shape\",\n    ]\n    values = [\n        self.fe_cell[0].basis_at_quad.shape,\n        self.fe_cell[0].basis_gradx_at_quad.shape,\n        self.fe_cell[0].jacobian.shape,\n        self.fe_cell[0].quad_xi.shape,\n        self.fe_cell[0].quad_weight.shape,\n        self.fe_cell[0].quad_actual_coordinates.shape,\n        self.fe_cell[0].forcing_at_quad.shape,\n    ]\n    print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n    # update the total number of dofs\n    self.total_dofs = dof\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry","title":"<code>Geometry</code>","text":"<p>Abstract base class for geometry and mesh operations.</p> <p>This class defines the interface that all geometry implementations must follow, providing the basic structure for mesh handling operations in both 2D and 3D contexts.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> <code>mesh_generation_method</code> <p>Method for mesh generation ('internal'/'external')</p> Example <p>class Geometry2D(Geometry): ...     def init(self, mesh_type='quadrilateral', ...                  method='internal'): ...         super().init(mesh_type, method) ... ...     def read_mesh(self, mesh_file, boundary_level, ...                   sampling_method, refine_level): ...         # Implementation ...         pass ... ...     def generate_vtk_for_test(self): ...         # Implementation ...         pass ... ...     def get_test_points(self): ...         # Implementation ...         return points</p> Note <p>This is an abstract base class. Concrete implementations must override: - read_mesh() - generate_vtk_for_test() - get_test_points()</p> <p>Each implementation should provide appropriate mesh handling for its specific dimensional and element type requirements.</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>class Geometry:\n    \"\"\"Abstract base class for geometry and mesh operations.\n\n    This class defines the interface that all geometry implementations must\n    follow, providing the basic structure for mesh handling operations in\n    both 2D and 3D contexts.\n\n    Attributes:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Example:\n        &gt;&gt;&gt; class Geometry2D(Geometry):\n        ...     def __init__(self, mesh_type='quadrilateral',\n        ...                  method='internal'):\n        ...         super().__init__(mesh_type, method)\n        ...\n        ...     def read_mesh(self, mesh_file, boundary_level,\n        ...                   sampling_method, refine_level):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def generate_vtk_for_test(self):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def get_test_points(self):\n        ...         # Implementation\n        ...         return points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - read_mesh()\n        - generate_vtk_for_test()\n        - get_test_points()\n\n        Each implementation should provide appropriate mesh handling for its\n        specific dimensional and element type requirements.\n    \"\"\"\n\n    def __init__(self, mesh_type: str, mesh_generation_method: str):\n        \"\"\"\n        Constructor for the Geometry class.\n\n        Args:\n            mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n            mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n\n    @abstractmethod\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n        Args:\n            mesh_file (str): Path to the mesh file\n            boundary_point_refinement_level (int): Level of refinement for boundary points\n            bd_sampling_method (str): Sampling method for boundary points\n            refinement_level (int): Level of mesh refinement\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n        None\n\n        Returns:\n        None\n        \"\"\"\n\n    @abstractmethod\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            points (np.ndarray): Test points extracted from the mesh\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.__init__","title":"<code>__init__(mesh_type, mesh_generation_method)</code>","text":"<p>Constructor for the Geometry class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method for mesh generation ('internal'/'external')</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>def __init__(self, mesh_type: str, mesh_generation_method: str):\n    \"\"\"\n    Constructor for the Geometry class.\n\n    Args:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>  <code>abstractmethod</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Args: None</p> <p>Returns: None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n    None\n\n    Returns:\n    None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.get_test_points","title":"<code>get_test_points()</code>  <code>abstractmethod</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Test points extracted from the mesh</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        points (np.ndarray): Test points extracted from the mesh\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of refinement for boundary points</p> required <code>bd_sampling_method</code> <code>str</code> <p>Sampling method for boundary points</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n    Args:\n        mesh_file (str): Path to the mesh file\n        boundary_point_refinement_level (int): Level of refinement for boundary points\n        bd_sampling_method (str): Sampling method for boundary points\n        refinement_level (int): Level of mesh refinement\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D","title":"<code>Geometry_2D</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>Implements 2D geometry and mesh handling capabilities.</p> <p>This class provides comprehensive functionality for managing 2D meshes, including both internal generation and external mesh reading. It supports various mesh operations, boundary handling, and visualization capabilities.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements ('quadrilateral')</p> <code>mesh_generation_method</code> <p>Method of mesh generation ('internal'/'external')</p> <code>n_test_points_x</code> <p>Number of test points in x-direction</p> <code>n_test_points_y</code> <p>Number of test points in y-direction</p> <code>output_folder</code> <p>Path for output files</p> <code>is_optimized</code> <p>Flag for mesh optimization</p> <code>n_cells_x</code> <p>Number of cells in x-direction (internal mesh)</p> <code>n_cells_y</code> <p>Number of cells in y-direction (internal mesh)</p> <code>x_limits</code> <p>Domain limits in x-direction</p> <code>y_limits</code> <p>Domain limits in y-direction</p> <code>mesh_file_name</code> <p>Name of external mesh file</p> <code>mesh</code> <p>MeshIO mesh object</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <code>cell_points</code> <p>Array of cell vertices</p> <code>test_points</code> <p>Array of test points</p> Example <p>geometry = Geometry_2D( ...     mesh_type='quadrilateral', ...     mesh_generation_method='internal', ...     n_test_points_x=10, ...     n_test_points_y=10, ...     output_folder='./output' ... ) cells, bounds = geometry.generate_quad_mesh_internal( ...     x_limits=(0,1), ...     y_limits=(0,1), ...     n_cells_x=5, ...     n_cells_y=5, ...     num_boundary_points=40 ... )</p> Note <ul> <li>Only supports quadrilateral elements</li> <li>Internal mesh generation is limited to rectangular domains</li> <li>External mesh reading requires Gmsh format</li> <li>Boundary points can be sampled uniformly or using LHS</li> </ul> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>class Geometry_2D(Geometry):\n    \"\"\"Implements 2D geometry and mesh handling capabilities.\n\n    This class provides comprehensive functionality for managing 2D meshes,\n    including both internal generation and external mesh reading. It supports\n    various mesh operations, boundary handling, and visualization capabilities.\n\n    Attributes:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n        n_cells_x: Number of cells in x-direction (internal mesh)\n        n_cells_y: Number of cells in y-direction (internal mesh)\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        mesh_file_name: Name of external mesh file\n        mesh: MeshIO mesh object\n        bd_dict: Dictionary of boundary points\n        cell_points: Array of cell vertices\n        test_points: Array of test points\n\n    Example:\n        &gt;&gt;&gt; geometry = Geometry_2D(\n        ...     mesh_type='quadrilateral',\n        ...     mesh_generation_method='internal',\n        ...     n_test_points_x=10,\n        ...     n_test_points_y=10,\n        ...     output_folder='./output'\n        ... )\n        &gt;&gt;&gt; cells, bounds = geometry.generate_quad_mesh_internal(\n        ...     x_limits=(0,1),\n        ...     y_limits=(0,1),\n        ...     n_cells_x=5,\n        ...     n_cells_y=5,\n        ...     num_boundary_points=40\n        ... )\n\n    Note:\n        - Only supports quadrilateral elements\n        - Internal mesh generation is limited to rectangular domains\n        - External mesh reading requires Gmsh format\n        - Boundary points can be sampled uniformly or using LHS\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh_type: str,\n        mesh_generation_method: str,\n        n_test_points_x: int,\n        n_test_points_y: int,\n        output_folder: str,\n        is_optimized: bool = False,\n    ):\n        \"\"\"\n        Constructor for Geometry_2D class.\n\n        Args:\n            mesh_type: Type of mesh elements ('quadrilateral')\n            mesh_generation_method: Method of mesh generation ('internal'/'external')\n            n_test_points_x: Number of test points in x-direction\n            n_test_points_y: Number of test points in y-direction\n            output_folder: Path for output files\n            is_optimized: Flag for mesh optimization\n\n        Raises:\n            ValueError: If mesh type or generation method is invalid\n\n        Returns:\n            None\n        \"\"\"\n        # Call the super class constructor\n        super().__init__(mesh_type, mesh_generation_method)\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n        self.n_test_points_x = n_test_points_x\n        self.n_test_points_y = n_test_points_y\n        self.output_folder = output_folder\n        self.is_optimized = is_optimized\n\n        if self.mesh_generation_method not in [\"internal\", \"external\"]:\n            print(\n                f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                \"Mesh generation method should be either internal or external.\"\n            )\n\n        if self.mesh_type not in [\"quadrilateral\"]:\n            print(\n                f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n        # To be filled - only when mesh is internal\n        self.n_cells_x = None\n        self.n_cells_y = None\n        self.x_limits = None\n        self.y_limits = None\n\n        # to be filled by external\n        self.mesh_file_name = None\n        self.mesh = None\n        self.bd_dict = None\n        self.cell_points = None\n        self.test_points = None\n\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Reads mesh from a Gmsh .msh file and extracts cell information.\n\n        Args:\n            mesh_file: Path to the mesh file\n            boundary_point_refinement_level: Level of boundary point refinement\n            bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n            refinement_level: Level of mesh refinement\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n\n        Raises:\n            ValueError: If mesh file format is invalid\n        \"\"\"\n\n        self.mesh_file_name = mesh_file\n\n        # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n        file_extension = Path(mesh_file).suffix\n\n        if file_extension != \".mesh\":\n            raise ValueError(\"Mesh file should be in .mesh format.\")\n\n        # Read mesh using meshio\n        self.mesh = meshio.read(mesh_file)\n\n        if self.mesh_type == \"quadrilateral\":\n            # Extract cell information\n            cells = self.mesh.cells_dict[\"quad\"]\n\n        num_cells = cells.shape[0]\n        print(f\"[INFO] : Number of cells = {num_cells}\")\n        cell_points = self.mesh.points[cells][\n            :, :, 0:2\n        ]  # remove the z coordinate, which is 0 for all points\n\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(num_cells):\n            cell = cell_points[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cell_points[i] = cell[np.argsort(angles)]\n\n        # Extract number of points within each cell\n        print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n        # Collect the Boundary point id's within the domain\n        boundary_edges = self.mesh.cells_dict[\"line\"]\n\n        # Using the point id, collect the coordinates of the boundary points\n        boundary_coordinates = self.mesh.points[boundary_edges]\n\n        # Number of Existing Boundary points\n        print(\n            f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n        )\n\n        # now Get the physical tag of the boundary edges\n        boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n        # Generate a Dictionary of boundary tags and boundary coordinates\n        # Keys will be the boundary tags and values will be the list of coordinates\n        boundary_dict = {}\n\n        # refine the boundary points based on the number of boundary points needed\n        for i in range(boundary_coordinates.shape[0]):\n            p1 = boundary_coordinates[i, 0, :]\n            p2 = boundary_coordinates[i, 1, :]\n\n            if bd_sampling_method == \"uniform\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = np.linspace(\n                    p1, p2, pow(2, boundary_point_refinement_level) + 1\n                )\n            elif bd_sampling_method == \"lhs\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n                new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n                new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n            else:\n                print(\n                    f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n            # get the boundary tag\n            tag = boundary_tags[i]\n\n            if tag not in boundary_dict:\n                boundary_dict[tag] = new_points\n            else:\n                current_val = new_points\n                prev_val = boundary_dict[tag]\n                final = np.vstack([prev_val, current_val])\n                boundary_dict[tag] = final\n\n        # get unique\n        for tag in boundary_dict.keys():\n            val = boundary_dict[tag]\n            val = np.unique(val, axis=0)\n            boundary_dict[tag] = val\n\n        self.bd_dict = boundary_dict\n        # print the new boundary points  on each boundary tag (key) in a tabular format\n\n        total_bound_points = 0\n        print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n        print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n        for k, v in self.bd_dict.items():\n            print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n            total_bound_points += v.shape[0]\n\n        print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n        # Assign to class values\n        self.cell_points = cell_points\n\n        # generate testvtk\n        self.generate_vtk_for_test()\n\n        return cell_points, self.bd_dict\n\n    def generate_quad_mesh_internal(\n        self,\n        x_limits: tuple,\n        y_limits: tuple,\n        n_cells_x: int,\n        n_cells_y: int,\n        num_boundary_points: int,\n    ):\n        \"\"\"\n        Generate and save a quadrilateral mesh with physical curves.\n\n        Args:\n            x_limits: Domain limits in x-direction\n            y_limits: Domain limits in y-direction\n            n_cells_x: Number of cells in x-direction\n            n_cells_y: Number of cells in y-direction\n            num_boundary_points: Number of boundary points\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n        \"\"\"\n\n        self.n_cells_x = n_cells_x\n        self.n_cells_y = n_cells_y\n        self.x_limits = x_limits\n        self.y_limits = y_limits\n\n        # generate linspace of points in x and y direction\n        x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n        y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n        # Generate quad cells from the points\n        # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n        cells = []\n\n        for i in range(n_cells_x):\n            for j in range(n_cells_y):\n                # get the four points of the cell\n                p1 = [x[i], y[j]]\n                p2 = [x[i + 1], y[j]]\n                p3 = [x[i + 1], y[j + 1]]\n                p4 = [x[i], y[j + 1]]\n\n                # append the points to the cells\n                cells.append([p1, p2, p3, p4])\n\n        # convert to numpy array\n        cells = np.array(cells, dtype=np.float64)\n\n        # use arctan2 to sort the points in anticlockwise direction\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(cells.shape[0]):\n            cell = cells[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cells[i] = cell[np.argsort(angles)]\n\n        # generate a meshio mesh object using the cells\n        self.mesh = meshio.Mesh(\n            points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n        )\n\n        # lets generate the boundary points, this function will return a dictionary of boundary points\n        # the keys will be the boundary tags and values will be the list of boundary points\n        bd_points = {}\n\n        num_bound_per_side = int(num_boundary_points / 4)\n\n        def _temp_bd_func(start, end, num_pts):\n            \"\"\"\n            This function returns the boundary points between the start and end points\n            using lhs sampling.\n\n            Args:\n                start: Start point of the boundary\n                end: End point of the boundary\n                num_pts: Number of boundary points to be generated\n\n            Returns:\n                bd_pts: Array of boundary points\n            \"\"\"\n            # generate the boundary points using lhs as a np.float64 array\n            bd_pts = lhs(1, num_pts).astype(np.float64)\n            # scale the points\n            bd_pts = bd_pts * (end - start) + start\n\n            return bd_pts.reshape(-1)\n\n        # bottom boundary\n        y_bottom = (\n            np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n        ).reshape(-1)\n        x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n        # right boundary\n        x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n            -1\n        )\n        y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1001] = np.vstack([x_right, y_right]).T\n\n        # top boundary\n        y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n            -1\n        )\n        x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1002] = np.vstack([x_top, y_top]).T\n\n        # left boundary\n        x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n            -1\n        )\n        y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1003] = np.vstack([x_left, y_left]).T\n\n        self.cell_points = cells\n        self.bd_dict = bd_points\n\n        # generate vtk\n        if not self.is_optimized:\n            self.generate_vtk_for_test()\n\n        return self.cell_points, self.bd_dict\n\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # initialise the mesh\n            gmsh.initialize()\n\n            # Now, lets generate the mesh with the points.\n            x_range = self.x_limits[1] - self.x_limits[0]\n            y_range = self.y_limits[1] - self.y_limits[0]\n\n            mesh_size_x = x_range / self.n_test_points_x\n            mesh_size_y = y_range / self.n_test_points_y\n\n            # generate a gmsh with the given parameters\n            Xmin = self.x_limits[0]\n            Xmax = self.x_limits[1]\n            Ymin = self.y_limits[0]\n            Ymax = self.y_limits[1]\n\n            point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n            point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n            point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n            point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n            line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n            line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n            line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n            line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n            face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n            gmsh.model.geo.add_plane_surface([face1])\n\n            # Create the relevant Gmsh data structures\n            # from Gmsh model.\n            gmsh.model.geo.synchronize()\n\n            # Generate mesh:\n            gmsh.model.mesh.generate()\n\n            mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n            gmsh.write(str(mesh_file_name))\n            print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n            # close the gmsh\n            gmsh.finalize()\n\n            # read the mesh using meshio\n            mesh = meshio.gmsh.read(str(mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for internal mesh file generated at \",\n                str(mesh_file_name),\n            )\n\n        elif self.mesh_generation_method == \"external\":\n\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n            # Use the internal mesh to generate the vtk file\n            mesh = meshio.read(str(self.mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for external mesh file generated at \",\n                str(vtk_file_name),\n            )\n\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            test_points (np.ndarray): Array of test points\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n            # code over written to plot from np.linspace instead of vtk file\n            # generate linspace of points in x and y direction based on x and y limits\n            x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n            y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n            # generate meshgrid\n            x_grid, y_grid = np.meshgrid(x, y)\n            # stack the points\n            self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n            return self.test_points\n\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        mesh = meshio.read(str(vtk_file_name))\n        points = mesh.points\n        return points[:, 0:2]  # return only first two columns\n\n    def write_vtk(\n        self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n    ):\n        \"\"\"\n        Writes the data to a VTK file.\n\n        Args:\n            solution: The solution data to be written\n            output_path: The output path for the VTK file\n            filename: The name of the output file\n            data_names: List of data names\n\n        Returns:\n            None\n        \"\"\"\n        # read the existing vtk into file\n        if self.mesh_generation_method == \"internal\":\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        data = []\n        with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n            for line in File:\n                data.append(line)\n\n        # get the output file name\n        output_file_name = Path(output_path) / filename\n\n        if solution.shape[1] != len(data_names):\n            print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n            print(\n                \"Num Columns in solution = \",\n                solution.shape[1],\n                \" Num of data names = \",\n                len(data_names),\n            )\n            raise ValueError(\"Number of data names and solution columns are not equal\")\n\n        # write the data to the output file\n        with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n            for line in data:\n                FN.write(line)\n                if \"POINT_DATA\" in line.strip():\n                    break\n\n            for i in range(solution.shape[1]):\n                FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n                FN.write(\"LOOKUP_TABLE default\\n\")\n                np.savetxt(FN, solution[:, i])\n                FN.write(\"\\n\")\n\n        # save the vtk file as image\n        # self.save_vtk_as_image(str(output_file_name), data_names)\n\n    def plot_adaptive_mesh(\n        self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n    ):\n        \"\"\"\n        Plots the residuals in each cell of the mesh.\n\n        Args:\n            cells_list: List of cell vertices\n            area_averaged_cell_loss_list: List of area averaged cell loss\n            epoch: The epoch number\n            filename: The output filename\n\n        Returns:\n            None\n        \"\"\"\n\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # normalise colors\n        norm = mcolors.Normalize(\n            vmin=np.min(area_averaged_cell_loss_list),\n            vmax=np.max(area_averaged_cell_loss_list),\n        )\n\n        # Create a colormap\n        colormap = plt.cm.jet\n\n        for index, cell in enumerate(cells_list):\n            x = cell[:, 0]\n            y = cell[:, 1]\n\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n            color = colormap(norm(curr_cell_loss))\n\n            plt.fill(x, y, color=color, alpha=0.9)\n\n            plt.plot(x, y, \"k\")\n\n            # # compute x_min, x_max, y_min, y_max\n            # x_min = np.min(x)\n            # x_max = np.max(x)\n            # y_min = np.min(y)\n            # y_max = np.max(y)\n\n            # # compute centroid of the cells\n            # centroid = np.array([np.mean(x), np.mean(y)])\n\n            # plot the loss text within the cell\n            # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n        sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n        sm.set_array([])\n        plt.colorbar(sm)\n\n        # output filename\n        output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n        plt.title(f\"Cell Residual\")\n        plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.__init__","title":"<code>__init__(mesh_type, mesh_generation_method, n_test_points_x, n_test_points_y, output_folder, is_optimized=False)</code>","text":"<p>Constructor for Geometry_2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements ('quadrilateral')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method of mesh generation ('internal'/'external')</p> required <code>n_test_points_x</code> <code>int</code> <p>Number of test points in x-direction</p> required <code>n_test_points_y</code> <code>int</code> <p>Number of test points in y-direction</p> required <code>output_folder</code> <code>str</code> <p>Path for output files</p> required <code>is_optimized</code> <code>bool</code> <p>Flag for mesh optimization</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh type or generation method is invalid</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def __init__(\n    self,\n    mesh_type: str,\n    mesh_generation_method: str,\n    n_test_points_x: int,\n    n_test_points_y: int,\n    output_folder: str,\n    is_optimized: bool = False,\n):\n    \"\"\"\n    Constructor for Geometry_2D class.\n\n    Args:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n\n    Raises:\n        ValueError: If mesh type or generation method is invalid\n\n    Returns:\n        None\n    \"\"\"\n    # Call the super class constructor\n    super().__init__(mesh_type, mesh_generation_method)\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n    self.n_test_points_x = n_test_points_x\n    self.n_test_points_y = n_test_points_y\n    self.output_folder = output_folder\n    self.is_optimized = is_optimized\n\n    if self.mesh_generation_method not in [\"internal\", \"external\"]:\n        print(\n            f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\n            \"Mesh generation method should be either internal or external.\"\n        )\n\n    if self.mesh_type not in [\"quadrilateral\"]:\n        print(\n            f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n    # To be filled - only when mesh is internal\n    self.n_cells_x = None\n    self.n_cells_y = None\n    self.x_limits = None\n    self.y_limits = None\n\n    # to be filled by external\n    self.mesh_file_name = None\n    self.mesh = None\n    self.bd_dict = None\n    self.cell_points = None\n    self.test_points = None\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.generate_quad_mesh_internal","title":"<code>generate_quad_mesh_internal(x_limits, y_limits, n_cells_x, n_cells_y, num_boundary_points)</code>","text":"<p>Generate and save a quadrilateral mesh with physical curves.</p> <p>Parameters:</p> Name Type Description Default <code>x_limits</code> <code>tuple</code> <p>Domain limits in x-direction</p> required <code>y_limits</code> <code>tuple</code> <p>Domain limits in y-direction</p> required <code>n_cells_x</code> <code>int</code> <p>Number of cells in x-direction</p> required <code>n_cells_y</code> <code>int</code> <p>Number of cells in y-direction</p> required <code>num_boundary_points</code> <code>int</code> <p>Number of boundary points</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_quad_mesh_internal(\n    self,\n    x_limits: tuple,\n    y_limits: tuple,\n    n_cells_x: int,\n    n_cells_y: int,\n    num_boundary_points: int,\n):\n    \"\"\"\n    Generate and save a quadrilateral mesh with physical curves.\n\n    Args:\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        n_cells_x: Number of cells in x-direction\n        n_cells_y: Number of cells in y-direction\n        num_boundary_points: Number of boundary points\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n    \"\"\"\n\n    self.n_cells_x = n_cells_x\n    self.n_cells_y = n_cells_y\n    self.x_limits = x_limits\n    self.y_limits = y_limits\n\n    # generate linspace of points in x and y direction\n    x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n    y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n    # Generate quad cells from the points\n    # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n    cells = []\n\n    for i in range(n_cells_x):\n        for j in range(n_cells_y):\n            # get the four points of the cell\n            p1 = [x[i], y[j]]\n            p2 = [x[i + 1], y[j]]\n            p3 = [x[i + 1], y[j + 1]]\n            p4 = [x[i], y[j + 1]]\n\n            # append the points to the cells\n            cells.append([p1, p2, p3, p4])\n\n    # convert to numpy array\n    cells = np.array(cells, dtype=np.float64)\n\n    # use arctan2 to sort the points in anticlockwise direction\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(cells.shape[0]):\n        cell = cells[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cells[i] = cell[np.argsort(angles)]\n\n    # generate a meshio mesh object using the cells\n    self.mesh = meshio.Mesh(\n        points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n    )\n\n    # lets generate the boundary points, this function will return a dictionary of boundary points\n    # the keys will be the boundary tags and values will be the list of boundary points\n    bd_points = {}\n\n    num_bound_per_side = int(num_boundary_points / 4)\n\n    def _temp_bd_func(start, end, num_pts):\n        \"\"\"\n        This function returns the boundary points between the start and end points\n        using lhs sampling.\n\n        Args:\n            start: Start point of the boundary\n            end: End point of the boundary\n            num_pts: Number of boundary points to be generated\n\n        Returns:\n            bd_pts: Array of boundary points\n        \"\"\"\n        # generate the boundary points using lhs as a np.float64 array\n        bd_pts = lhs(1, num_pts).astype(np.float64)\n        # scale the points\n        bd_pts = bd_pts * (end - start) + start\n\n        return bd_pts.reshape(-1)\n\n    # bottom boundary\n    y_bottom = (\n        np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n    ).reshape(-1)\n    x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n    # right boundary\n    x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n        -1\n    )\n    y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1001] = np.vstack([x_right, y_right]).T\n\n    # top boundary\n    y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n        -1\n    )\n    x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1002] = np.vstack([x_top, y_top]).T\n\n    # left boundary\n    x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n        -1\n    )\n    y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1003] = np.vstack([x_left, y_left]).T\n\n    self.cell_points = cells\n    self.bd_dict = bd_points\n\n    # generate vtk\n    if not self.is_optimized:\n        self.generate_vtk_for_test()\n\n    return self.cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # initialise the mesh\n        gmsh.initialize()\n\n        # Now, lets generate the mesh with the points.\n        x_range = self.x_limits[1] - self.x_limits[0]\n        y_range = self.y_limits[1] - self.y_limits[0]\n\n        mesh_size_x = x_range / self.n_test_points_x\n        mesh_size_y = y_range / self.n_test_points_y\n\n        # generate a gmsh with the given parameters\n        Xmin = self.x_limits[0]\n        Xmax = self.x_limits[1]\n        Ymin = self.y_limits[0]\n        Ymax = self.y_limits[1]\n\n        point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n        point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n        point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n        point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n        line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n        line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n        line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n        line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n        face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n        gmsh.model.geo.add_plane_surface([face1])\n\n        # Create the relevant Gmsh data structures\n        # from Gmsh model.\n        gmsh.model.geo.synchronize()\n\n        # Generate mesh:\n        gmsh.model.mesh.generate()\n\n        mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n        gmsh.write(str(mesh_file_name))\n        print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n        # close the gmsh\n        gmsh.finalize()\n\n        # read the mesh using meshio\n        mesh = meshio.gmsh.read(str(mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for internal mesh file generated at \",\n            str(mesh_file_name),\n        )\n\n    elif self.mesh_generation_method == \"external\":\n\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        # Use the internal mesh to generate the vtk file\n        mesh = meshio.read(str(self.mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for external mesh file generated at \",\n            str(vtk_file_name),\n        )\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.get_test_points","title":"<code>get_test_points()</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>test_points</code> <code>ndarray</code> <p>Array of test points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        test_points (np.ndarray): Array of test points\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n        # code over written to plot from np.linspace instead of vtk file\n        # generate linspace of points in x and y direction based on x and y limits\n        x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n        y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n        # generate meshgrid\n        x_grid, y_grid = np.meshgrid(x, y)\n        # stack the points\n        self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n        return self.test_points\n\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    mesh = meshio.read(str(vtk_file_name))\n    points = mesh.points\n    return points[:, 0:2]  # return only first two columns\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.plot_adaptive_mesh","title":"<code>plot_adaptive_mesh(cells_list, area_averaged_cell_loss_list, epoch, filename='cell_residual')</code>","text":"<p>Plots the residuals in each cell of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>cells_list</code> <p>List of cell vertices</p> required <code>area_averaged_cell_loss_list</code> <p>List of area averaged cell loss</p> required <code>epoch</code> <p>The epoch number</p> required <code>filename</code> <p>The output filename</p> <code>'cell_residual'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def plot_adaptive_mesh(\n    self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n):\n    \"\"\"\n    Plots the residuals in each cell of the mesh.\n\n    Args:\n        cells_list: List of cell vertices\n        area_averaged_cell_loss_list: List of area averaged cell loss\n        epoch: The epoch number\n        filename: The output filename\n\n    Returns:\n        None\n    \"\"\"\n\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # normalise colors\n    norm = mcolors.Normalize(\n        vmin=np.min(area_averaged_cell_loss_list),\n        vmax=np.max(area_averaged_cell_loss_list),\n    )\n\n    # Create a colormap\n    colormap = plt.cm.jet\n\n    for index, cell in enumerate(cells_list):\n        x = cell[:, 0]\n        y = cell[:, 1]\n\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n        color = colormap(norm(curr_cell_loss))\n\n        plt.fill(x, y, color=color, alpha=0.9)\n\n        plt.plot(x, y, \"k\")\n\n        # # compute x_min, x_max, y_min, y_max\n        # x_min = np.min(x)\n        # x_max = np.max(x)\n        # y_min = np.min(y)\n        # y_max = np.max(y)\n\n        # # compute centroid of the cells\n        # centroid = np.array([np.mean(x), np.mean(y)])\n\n        # plot the loss text within the cell\n        # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n    sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n    sm.set_array([])\n    plt.colorbar(sm)\n\n    # output filename\n    output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n    plt.title(f\"Cell Residual\")\n    plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>","text":"<p>Reads mesh from a Gmsh .msh file and extracts cell information.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of boundary point refinement</p> required <code>bd_sampling_method</code> <code>str</code> <p>Method for boundary point sampling ('uniform'/'lhs')</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh file format is invalid</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Reads mesh from a Gmsh .msh file and extracts cell information.\n\n    Args:\n        mesh_file: Path to the mesh file\n        boundary_point_refinement_level: Level of boundary point refinement\n        bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n        refinement_level: Level of mesh refinement\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n\n    Raises:\n        ValueError: If mesh file format is invalid\n    \"\"\"\n\n    self.mesh_file_name = mesh_file\n\n    # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n    file_extension = Path(mesh_file).suffix\n\n    if file_extension != \".mesh\":\n        raise ValueError(\"Mesh file should be in .mesh format.\")\n\n    # Read mesh using meshio\n    self.mesh = meshio.read(mesh_file)\n\n    if self.mesh_type == \"quadrilateral\":\n        # Extract cell information\n        cells = self.mesh.cells_dict[\"quad\"]\n\n    num_cells = cells.shape[0]\n    print(f\"[INFO] : Number of cells = {num_cells}\")\n    cell_points = self.mesh.points[cells][\n        :, :, 0:2\n    ]  # remove the z coordinate, which is 0 for all points\n\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(num_cells):\n        cell = cell_points[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cell_points[i] = cell[np.argsort(angles)]\n\n    # Extract number of points within each cell\n    print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n    # Collect the Boundary point id's within the domain\n    boundary_edges = self.mesh.cells_dict[\"line\"]\n\n    # Using the point id, collect the coordinates of the boundary points\n    boundary_coordinates = self.mesh.points[boundary_edges]\n\n    # Number of Existing Boundary points\n    print(\n        f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n    )\n\n    # now Get the physical tag of the boundary edges\n    boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n    # Generate a Dictionary of boundary tags and boundary coordinates\n    # Keys will be the boundary tags and values will be the list of coordinates\n    boundary_dict = {}\n\n    # refine the boundary points based on the number of boundary points needed\n    for i in range(boundary_coordinates.shape[0]):\n        p1 = boundary_coordinates[i, 0, :]\n        p2 = boundary_coordinates[i, 1, :]\n\n        if bd_sampling_method == \"uniform\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = np.linspace(\n                p1, p2, pow(2, boundary_point_refinement_level) + 1\n            )\n        elif bd_sampling_method == \"lhs\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n            new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n            new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n        else:\n            print(\n                f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n        # get the boundary tag\n        tag = boundary_tags[i]\n\n        if tag not in boundary_dict:\n            boundary_dict[tag] = new_points\n        else:\n            current_val = new_points\n            prev_val = boundary_dict[tag]\n            final = np.vstack([prev_val, current_val])\n            boundary_dict[tag] = final\n\n    # get unique\n    for tag in boundary_dict.keys():\n        val = boundary_dict[tag]\n        val = np.unique(val, axis=0)\n        boundary_dict[tag] = val\n\n    self.bd_dict = boundary_dict\n    # print the new boundary points  on each boundary tag (key) in a tabular format\n\n    total_bound_points = 0\n    print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n    print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n    for k, v in self.bd_dict.items():\n        print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n        total_bound_points += v.shape[0]\n\n    print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n    # Assign to class values\n    self.cell_points = cell_points\n\n    # generate testvtk\n    self.generate_vtk_for_test()\n\n    return cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.write_vtk","title":"<code>write_vtk(solution, output_path, filename, data_names)</code>","text":"<p>Writes the data to a VTK file.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>ndarray</code> <p>The solution data to be written</p> required <code>output_path</code> <code>str</code> <p>The output path for the VTK file</p> required <code>filename</code> <code>str</code> <p>The name of the output file</p> required <code>data_names</code> <code>list</code> <p>List of data names</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def write_vtk(\n    self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n):\n    \"\"\"\n    Writes the data to a VTK file.\n\n    Args:\n        solution: The solution data to be written\n        output_path: The output path for the VTK file\n        filename: The name of the output file\n        data_names: List of data names\n\n    Returns:\n        None\n    \"\"\"\n    # read the existing vtk into file\n    if self.mesh_generation_method == \"internal\":\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    data = []\n    with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n        for line in File:\n            data.append(line)\n\n    # get the output file name\n    output_file_name = Path(output_path) / filename\n\n    if solution.shape[1] != len(data_names):\n        print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n        print(\n            \"Num Columns in solution = \",\n            solution.shape[1],\n            \" Num of data names = \",\n            len(data_names),\n        )\n        raise ValueError(\"Number of data names and solution columns are not equal\")\n\n    # write the data to the output file\n    with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n        for line in data:\n            FN.write(line)\n            if \"POINT_DATA\" in line.strip():\n                break\n\n        for i in range(solution.shape[1]):\n            FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n            FN.write(\"LOOKUP_TABLE default\\n\")\n            np.savetxt(FN, solution[:, i])\n            FN.write(\"\\n\")\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.print_table","title":"<code>print_table(title, columns, col_1_values, col_2_values)</code>","text":"<p>This function prints a table with two columns to the console.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>str: Title of the table</p> required <code>columns</code> <code>list</code> <p>list: List of column names</p> required <code>col_1_values</code> <code>list</code> <p>list: List of values for column 1</p> required <code>col_2_values</code> <code>list</code> <p>list: List of values for column</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\utils\\print_utils.py</code> <pre><code>def print_table(title: str, columns: list, col_1_values: list, col_2_values: list):\n    \"\"\"\n    This function prints a table with two columns to the console.\n\n    Args:\n        title: str: Title of the table\n        columns: list: List of column names\n        col_1_values: list: List of values for column 1\n        col_2_values: list: List of values for column\n\n    Returns:\n        None\n    \"\"\"\n\n    # Create a console object\n    console = Console()\n\n    # Create a table with a title\n    table = Table(show_header=True, header_style=\"bold magenta\", title=title)\n\n    # Add columns to the table\n    for column in columns:\n        table.add_column(column)\n\n    # Add rows to the table\n    for val_1, val_2 in zip(col_1_values, col_2_values):\n        # check if val_2 is a float\n        if isinstance(val_2, float):\n            # add the row to the table\n            table.add_row(val_1, f\"{val_2:.4f}\")\n        else:\n            table.add_row(val_1, str(val_2))\n\n    # Print the table to the console\n    console.print(table)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/","title":"Model","text":"<p>Neural Network Model Implementation for Variational Physics-Informed Neural Networks.</p> <p>This module implements the neural network architecture and training loop for solving PDEs using variational physics-informed neural networks (VPINNs). It provides a flexible framework for handling various PDEs through custom loss functions.</p> The implementation supports <ul> <li>Flexible neural network architectures</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations</li> <li>Automatic differentiation for gradients</li> </ul> Key classes <ul> <li>DenseModel: Neural network model for VPINN implementation</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel","title":"<code>DenseModel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for solving PDEs using variational formulation.</p> <p>This class implements a custom neural network architecture for solving partial differential equations using the variational form. It supports flexible layer configurations and various loss components.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>input_tensors_list</code> <p>List containing: [0]: input_tensor - Main computation points [1]: dirichlet_input - Boundary points [2]: dirichlet_actual - Boundary values</p> <code>orig_factor_matrices</code> <p>List containing: [0]: Shape function values [1]: x-derivative of shape functions [2]: y-derivative of shape functions</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32 ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The training process balances PDE residuals and boundary conditions through a weighted loss function. The implementation uses efficient tensor operations for computing variational residuals.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>class DenseModel(tf.keras.Model):\n    \"\"\"Neural network model for solving PDEs using variational formulation.\n\n    This class implements a custom neural network architecture for solving\n    partial differential equations using the variational form. It supports\n    flexible layer configurations and various loss components.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list: List containing:\n            [0]: input_tensor - Main computation points\n            [1]: dirichlet_input - Boundary points\n            [2]: dirichlet_actual - Boundary values\n        orig_factor_matrices: List containing:\n            [0]: Shape function values\n            [1]: x-derivative of shape functions\n            [2]: y-derivative of shape functions\n        tensor_dtype: TensorFlow data type for computations\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The training process balances PDE residuals and boundary conditions\n        through a weighted loss function. The implementation uses efficient\n        tensor operations for computing variational residuals.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        orig_factor_matrices: list,\n        force_function_list: list,\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n    ):\n        \"\"\"\n        Initialize the DenseModel class.\n\n        Args:\n            layer_dims (list): List of neurons per layer including input/output.\n            learning_rate_dict (dict): Learning rate configuration containing:\n                - initial_learning_rate: Starting learning rate\n                - use_lr_scheduler: Whether to use learning rate decay\n                - decay_steps: Steps between learning rate updates\n                - decay_rate: Factor for learning rate decay\n            params_dict (dict): Model parameters including:\n                - n_cells: Number of cells in the domain\n            loss_function: Custom loss function for PDE residuals\n            input_tensors_list: List containing:\n                [0]: input_tensor - Main computation points\n                [1]: dirichlet_input - Boundary points\n                [2]: dirichlet_actual - Boundary values\n            orig_factor_matrices: List containing:\n                [0]: Shape function values\n                [1]: x-derivative of shape functions\n                [2]: y-derivative of shape functions\n            force_function_list: List containing:\n                - forcing_function: Forcing function values\n            tensor_dtype: TensorFlow data type for computations\n            use_attention (bool): Whether to use attention mechanism, defaults to False.\n            activation (str): Activation function for hidden layers, defaults to \"tanh\".\n            hessian (bool): Whether to compute Hessian matrix, defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        super(DenseModel, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        # staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                TensorflowDense.create_layer(\n                    units=self.layer_dims[dim],\n                    activation=self.activation,\n                    dtype=self.tensor_dtype,\n                    kernel_initializer=\"glorot_uniform\",\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[-1],\n                activation=None,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    # def build(self, input_shape):\n    #     super(DenseModel, self).build(input_shape)\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"\n        The call method for the model.\n\n        Args:\n            inputs: The input tensor for the model.\n\n        Returns:\n            tf.Tensor: The output tensor from the model.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"\n        Get the configuration of the model.\n\n        Returns:\n            dict: The configuration of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"\n        The train step method for the model.\n\n        Args:\n            beta (int): The weight for the boundary loss, defaults to 10.\n            bilinear_params_dict (dict): The bilinear parameters dictionary, defaults to None.\n\n        Returns:\n            dict: The loss values for the model.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.__init__","title":"<code>__init__(layer_dims, learning_rate_dict, params_dict, loss_function, input_tensors_list, orig_factor_matrices, force_function_list, tensor_dtype, use_attention=False, activation='tanh', hessian=False)</code>","text":"<p>Initialize the DenseModel class.</p> <p>Parameters:</p> Name Type Description Default <code>layer_dims</code> <code>list</code> <p>List of neurons per layer including input/output.</p> required <code>learning_rate_dict</code> <code>dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> required <code>params_dict</code> <code>dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> required <code>loss_function</code> <p>Custom loss function for PDE residuals</p> required <code>input_tensors_list</code> <code>list</code> <p>List containing: [0]: input_tensor - Main computation points [1]: dirichlet_input - Boundary points [2]: dirichlet_actual - Boundary values</p> required <code>orig_factor_matrices</code> <code>list</code> <p>List containing: [0]: Shape function values [1]: x-derivative of shape functions [2]: y-derivative of shape functions</p> required <code>force_function_list</code> <code>list</code> <p>List containing: - forcing_function: Forcing function values</p> required <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> required <code>use_attention</code> <code>bool</code> <p>Whether to use attention mechanism, defaults to False.</p> <code>False</code> <code>activation</code> <code>str</code> <p>Activation function for hidden layers, defaults to \"tanh\".</p> <code>'tanh'</code> <code>hessian</code> <code>bool</code> <p>Whether to compute Hessian matrix, defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>def __init__(\n    self,\n    layer_dims: list,\n    learning_rate_dict: dict,\n    params_dict: dict,\n    loss_function,\n    input_tensors_list: list,\n    orig_factor_matrices: list,\n    force_function_list: list,\n    tensor_dtype,\n    use_attention=False,\n    activation=\"tanh\",\n    hessian=False,\n):\n    \"\"\"\n    Initialize the DenseModel class.\n\n    Args:\n        layer_dims (list): List of neurons per layer including input/output.\n        learning_rate_dict (dict): Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict (dict): Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list: List containing:\n            [0]: input_tensor - Main computation points\n            [1]: dirichlet_input - Boundary points\n            [2]: dirichlet_actual - Boundary values\n        orig_factor_matrices: List containing:\n            [0]: Shape function values\n            [1]: x-derivative of shape functions\n            [2]: y-derivative of shape functions\n        force_function_list: List containing:\n            - forcing_function: Forcing function values\n        tensor_dtype: TensorFlow data type for computations\n        use_attention (bool): Whether to use attention mechanism, defaults to False.\n        activation (str): Activation function for hidden layers, defaults to \"tanh\".\n        hessian (bool): Whether to compute Hessian matrix, defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    super(DenseModel, self).__init__()\n    self.layer_dims = layer_dims\n    self.use_attention = use_attention\n    self.activation = activation\n    self.layer_list = []\n    self.loss_function = loss_function\n    self.hessian = hessian\n\n    self.tensor_dtype = tensor_dtype\n\n    # if dtype is not a valid tensorflow dtype, raise an error\n    if not isinstance(self.tensor_dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    self.orig_factor_matrices = orig_factor_matrices\n    self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n    self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[1]\n    )\n    self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[2]\n    )\n\n    self.force_function_list = force_function_list\n\n    self.input_tensors_list = input_tensors_list\n    self.input_tensor = copy.deepcopy(input_tensors_list[0])\n    self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n    self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n    self.params_dict = params_dict\n\n    self.pre_multiplier_val = self.shape_function_mat_list\n    self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n    self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n    self.force_matrix = self.force_function_list\n\n    print(f\"{'-'*74}\")\n    print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n    print(f\"{'-'*74}\")\n    print(\n        f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n    )\n    print(\n        f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n    )\n    print(f\"{'-'*74}\")\n\n    self.n_cells = params_dict[\"n_cells\"]\n\n    ## ----------------------------------------------------------------- ##\n    ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # parse the learning rate dictionary\n    self.learning_rate_dict = learning_rate_dict\n    initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n    use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n    decay_steps = learning_rate_dict[\"decay_steps\"]\n    decay_rate = learning_rate_dict[\"decay_rate\"]\n    # staircase = learning_rate_dict[\"staircase\"]\n\n    if use_lr_scheduler:\n        learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n            initial_learning_rate, decay_steps, decay_rate, staircase=True\n        )\n    else:\n        learning_rate_fn = initial_learning_rate\n\n    self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n    ## ----------------------------------------------------------------- ##\n    ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # Build dense layers based on the input list\n    for dim in range(len(self.layer_dims) - 2):\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[dim],\n                activation=self.activation,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n    # Add a output layer with no activation\n    self.layer_list.append(\n        TensorflowDense.create_layer(\n            units=self.layer_dims[-1],\n            activation=None,\n            dtype=self.tensor_dtype,\n            kernel_initializer=\"glorot_uniform\",\n            bias_initializer=\"zeros\",\n        )\n    )\n\n    # Add attention layer if required\n    if self.use_attention:\n        self.attention_layer = layers.Attention()\n\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    self.build(input_shape=(None, self.layer_dims[0]))\n\n    # print the summary of the model\n    self.summary()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.call","title":"<code>call(inputs)</code>","text":"<p>The call method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input tensor for the model.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: The output tensor from the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"\n    The call method for the model.\n\n    Args:\n        inputs: The input tensor for the model.\n\n    Returns:\n        tf.Tensor: The output tensor from the model.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.get_config","title":"<code>get_config()</code>","text":"<p>Get the configuration of the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The configuration of the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"\n    Get the configuration of the model.\n\n    Returns:\n        dict: The configuration of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>The train step method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <code>int</code> <p>The weight for the boundary loss, defaults to 10.</p> <code>10</code> <code>bilinear_params_dict</code> <code>dict</code> <p>The bilinear parameters dictionary, defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loss values for the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"\n    The train step method for the model.\n\n    Args:\n        beta (int): The weight for the boundary loss, defaults to 10.\n        bilinear_params_dict (dict): The bilinear parameters dictionary, defaults to None.\n\n    Returns:\n        dict: The loss values for the model.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values = self(self.input_tensor)\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/","title":"Model hard","text":"<p>Neural Network Model Implementation for FastVPINNs with Hard Constraints.</p> <p>This module implements a custom neural network model designed specifically for FastVPINNs methodology, incorporating hard constraint enforcement. It extends TensorFlow's Keras Model class to provide efficient PDE residual computation and gradient-based training.</p> The implementation supports <ul> <li>Flexible neural network architecture definition</li> <li>Hard constraint enforcement through constraint functions</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations for PDE residuals</li> <li>Custom gradient computation and training loops</li> </ul> Key classes <ul> <li>DenseModel_Hard: Main neural network model with hard constraints</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard","title":"<code>DenseModel_Hard</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model with hard constraint enforcement for FastVPINNs.</p> <p>This class implements a custom neural network architecture specifically designed for solving PDEs using the FastVPINNs methodology. It supports hard constraint enforcement through custom constraint functions and efficient tensor operations for PDE residual computation.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay - staircase: Whether to use staircase decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>hessian</code> <p>Whether to compute second derivatives</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> <code>layer_list</code> <p>List of neural network layers</p> Example <p>model = DenseModel_Hard( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32 ... ) history = model.fit(x_train, epochs=1000)</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>class DenseModel_Hard(tf.keras.Model):\n    \"\"\"Neural network model with hard constraint enforcement for FastVPINNs.\n\n    This class implements a custom neural network architecture specifically\n    designed for solving PDEs using the FastVPINNs methodology. It supports\n    hard constraint enforcement through custom constraint functions and\n    efficient tensor operations for PDE residual computation.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n            - staircase: Whether to use staircase decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        tensor_dtype: TensorFlow data type for computations\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        hessian: Whether to compute second derivatives\n        optimizer: Adam optimizer with optional learning rate schedule\n        layer_list: List of neural network layers\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel_Hard(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims,\n        learning_rate_dict,\n        params_dict,\n        loss_function,\n        input_tensors_list,\n        orig_factor_matrices,\n        force_function_list,\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n        hard_constraint_function=None,\n    ):\n        super(DenseModel_Hard, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n        if hard_constraint_function is None:\n            self.hard_constraint_function = lambda x, y: y\n        else:\n            self.hard_constraint_function = hard_constraint_function\n\n        self.tensor_dtype = tensor_dtype\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        self.gradients = None\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                TensorflowDense.create_layer(\n                    units=self.layer_dims[dim + 1],\n                    activation=self.activation,\n                    dtype=self.tensor_dtype,\n                    kernel_initializer=\"glorot_uniform\",\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[-1],\n                activation=None,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    # def build(self, input_shape):\n    #     super(DenseModel, self).build(input_shape)\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"This method is used to define the forward pass of the model.\n\n        Args:\n            inputs: Input tensor to the model\n\n        Returns:\n            Output tensor from the model\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        x = self.hard_constraint_function(inputs, x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"This method is used to get the configuration of the model.\n\n        Args:\n            None\n\n        Returns:\n            Configuration dictionary of the model\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"This method is used to define the training step of the mode.\n\n        Args:\n            beta: The penalty parameter for the hard constraints\n            bilinear_params_dict: The bilinear parameters dictionary\n\n        Returns:\n            Dictionary containing the loss values\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # tf.print(\"Residual : \", residual)\n            # tf.print(\"Residual Shape : \", residual.shape)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # convert predicted_values_dirichlet to tf.float64\n            # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n            # tf.print(\"Boundary Loss : \", boundary_loss)\n            # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n            # tf.print(\"Total PDE Loss : \", total_pde_loss)\n            # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n            boundary_loss = 0.0\n            # Compute Total Loss\n            total_loss = total_pde_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard.call","title":"<code>call(inputs)</code>","text":"<p>This method is used to define the forward pass of the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>Input tensor to the model</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Output tensor from the model</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"This method is used to define the forward pass of the model.\n\n    Args:\n        inputs: Input tensor to the model\n\n    Returns:\n        Output tensor from the model\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    x = self.hard_constraint_function(inputs, x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard.get_config","title":"<code>get_config()</code>","text":"<p>This method is used to get the configuration of the model.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Configuration dictionary of the model</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"This method is used to get the configuration of the model.\n\n    Args:\n        None\n\n    Returns:\n        Configuration dictionary of the model\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>This method is used to define the training step of the mode.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <p>The penalty parameter for the hard constraints</p> <code>10</code> <code>bilinear_params_dict</code> <p>The bilinear parameters dictionary</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the loss values</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"This method is used to define the training step of the mode.\n\n    Args:\n        beta: The penalty parameter for the hard constraints\n        bilinear_params_dict: The bilinear parameters dictionary\n\n    Returns:\n        Dictionary containing the loss values\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values = self(self.input_tensor)\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # tf.print(\"Residual : \", residual)\n        # tf.print(\"Residual Shape : \", residual.shape)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # convert predicted_values_dirichlet to tf.float64\n        # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n        # tf.print(\"Boundary Loss : \", boundary_loss)\n        # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n        # tf.print(\"Total PDE Loss : \", total_pde_loss)\n        # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n        boundary_loss = 0.0\n        # Compute Total Loss\n        total_loss = total_pde_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/","title":"Model inverse","text":"<p>Neural Network Model Implementation for PDE Parameter Inverse Problems.</p> <p>This module implements the neural network architecture and training loop for solving inverse problems in PDEs using variational physics-informed neural  networks (VPINNs). It focuses on identifying constant parameters while solving the underlying PDE simultaneously.</p> The implementation supports <ul> <li>Parameter identification</li> <li>Sensor data incorporation</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations</li> </ul> Key classes <ul> <li>DenseModel_Inverse: Neural network model for inverse problems</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse","title":"<code>DenseModel_Inverse</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for PDE parameter identification.</p> <p>This class implements a custom neural network architecture for solving inverse problems in PDEs. It combines parameter identification with PDE solution while incorporating sensor data and boundary conditions.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay - staircase: Whether to use staircase decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>sensor_list</code> <p>List containing: [0]: sensor_points - Coordinates of sensor locations [1]: sensor_values - Measured values at sensors</p> <code>inverse_params_dict</code> <p>Dictionary of parameters to be identified, converted to trainable variables</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel_Inverse( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32, ...     sensor_list=[sensor_points, sensor_values], ...     inverse_params_dict={'eps': 0.1} ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The training process balances PDE residuals, boundary conditions, sensor data matching, and parameter identification through a weighted loss function.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>class DenseModel_Inverse(tf.keras.Model):\n    \"\"\"Neural network model for PDE parameter identification.\n\n    This class implements a custom neural network architecture for solving\n    inverse problems in PDEs. It combines parameter identification with\n    PDE solution while incorporating sensor data and boundary conditions.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n            - staircase: Whether to use staircase decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        tensor_dtype: TensorFlow data type for computations\n        sensor_list: List containing:\n            [0]: sensor_points - Coordinates of sensor locations\n            [1]: sensor_values - Measured values at sensors\n        inverse_params_dict: Dictionary of parameters to be identified,\n            converted to trainable variables\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel_Inverse(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32,\n        ...     sensor_list=[sensor_points, sensor_values],\n        ...     inverse_params_dict={'eps': 0.1}\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The training process balances PDE residuals, boundary conditions,\n        sensor data matching, and parameter identification through a\n        weighted loss function.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        orig_factor_matrices: list,\n        force_function_list: list,\n        sensor_list: list,  # for inverse problem\n        inverse_params_dict: dict,  # for inverse problem\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n    ):\n        super(DenseModel_Inverse, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        self.sensor_list = sensor_list\n        # obtain sensor values\n        self.sensor_points = sensor_list[0]\n        self.sensor_values = sensor_list[1]\n\n        # inverse params dict\n        self.inverse_params_dict = inverse_params_dict\n\n        # Conver all the values within inverse_params_dict to trainable variables\n        for key, value in self.inverse_params_dict.items():\n            self.inverse_params_dict[key] = tf.Variable(\n                value, dtype=self.tensor_dtype, trainable=True\n            )\n            tf.print(f\"Key : {key} , Value : {self.inverse_params_dict[key]}\")\n\n        # add the sensor points to the trainable variables of the model\n        self.trainable_variables.extend(self.inverse_params_dict.values())\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                layers.Dense(\n                    self.layer_dims[dim + 1],\n                    activation=self.activation,\n                    kernel_initializer=\"glorot_uniform\",\n                    dtype=self.tensor_dtype,\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            layers.Dense(\n                self.layer_dims[-1],\n                activation=None,\n                kernel_initializer=\"glorot_uniform\",\n                dtype=self.tensor_dtype,\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    def call(self, inputs):\n        \"\"\"\n        Applies the model to the input data.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The output of the model after applying all the layers.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self):\n        \"\"\"\n        Returns the configuration of the model.\n\n        This method is used to serialize the model configuration. It returns a dictionary\n        containing all the necessary information to recreate the model.\n\n        Returns:\n            dict: The configuration dictionary of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n                \"sensor_list\": self.sensor_list,\n                \"inverse_params_dict\": self.inverse_params_dict,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"\n        Performs a single training step on the model.\n\n        Args:\n            beta: The weight for the boundary condition loss.\n            bilinear_params_dict: The bilinear parameters dictionary.\n\n        Returns:\n            dict: A dictionary containing the loss values.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n\n            # predict the sensor values\n            predicted_sensor_values = self(self.sensor_points)\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n                inverse_params_dict=self.inverse_params_dict,\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # tf.print(\"Residual : \", residual)\n            # tf.print(\"Residual Shape : \", residual.shape)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # convert predicted_values_dirichlet to tf.float64\n            # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Sensor loss\n            sensor_loss = tf.reduce_mean(\n                tf.square(predicted_sensor_values - self.sensor_values), axis=0\n            )\n\n            # tf.print(\"Boundary Loss : \", boundary_loss)\n            # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n            # tf.print(\"Total PDE Loss : \", total_pde_loss)\n            # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n            \"inverse_params\": self.inverse_params_dict,\n            \"sensor_loss\": sensor_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse.call","title":"<code>call(inputs)</code>","text":"<p>Applies the model to the input data.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input data.</p> required <p>Returns:</p> Type Description <p>The output of the model after applying all the layers.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>def call(self, inputs):\n    \"\"\"\n    Applies the model to the input data.\n\n    Args:\n        inputs: The input data.\n\n    Returns:\n        The output of the model after applying all the layers.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse.get_config","title":"<code>get_config()</code>","text":"<p>Returns the configuration of the model.</p> <p>This method is used to serialize the model configuration. It returns a dictionary containing all the necessary information to recreate the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The configuration dictionary of the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>def get_config(self):\n    \"\"\"\n    Returns the configuration of the model.\n\n    This method is used to serialize the model configuration. It returns a dictionary\n    containing all the necessary information to recreate the model.\n\n    Returns:\n        dict: The configuration dictionary of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n            \"sensor_list\": self.sensor_list,\n            \"inverse_params_dict\": self.inverse_params_dict,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>Performs a single training step on the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <p>The weight for the boundary condition loss.</p> <code>10</code> <code>bilinear_params_dict</code> <p>The bilinear parameters dictionary.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the loss values.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"\n    Performs a single training step on the model.\n\n    Args:\n        beta: The weight for the boundary condition loss.\n        bilinear_params_dict: The bilinear parameters dictionary.\n\n    Returns:\n        dict: A dictionary containing the loss values.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n\n        # predict the sensor values\n        predicted_sensor_values = self(self.sensor_points)\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values = self(self.input_tensor)\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n            inverse_params_dict=self.inverse_params_dict,\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # tf.print(\"Residual : \", residual)\n        # tf.print(\"Residual Shape : \", residual.shape)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # convert predicted_values_dirichlet to tf.float64\n        # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Sensor loss\n        sensor_loss = tf.reduce_mean(\n            tf.square(predicted_sensor_values - self.sensor_values), axis=0\n        )\n\n        # tf.print(\"Boundary Loss : \", boundary_loss)\n        # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n        # tf.print(\"Total PDE Loss : \", total_pde_loss)\n        # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n        \"inverse_params\": self.inverse_params_dict,\n        \"sensor_loss\": sensor_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/","title":"Model inverse domain","text":"<p>Neural Network Model Implementation for Domain-Based PDE Inverse Problems.</p> <p>This module implements the neural network architecture and training loop for solving inverse problems in PDEs where parameters are constant over the domain. The implementation follows the FastVPINNs methodology for efficient training of variational physics-informed neural networks.</p> The implementation supports <ul> <li>Domain-based parameter identification</li> <li>Sensor data incorporation</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations</li> </ul> Key classes <ul> <li>DenseModel_Inverse_Domain: Neural network model for inverse problems</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of variational residuals in inverse problems.</p> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain","title":"<code>DenseModel_Inverse_Domain</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for domain-based PDE inverse problems.</p> <p>This class implements a custom neural network architecture specifically designed for solving inverse problems in PDEs where parameters are constant over the domain. It incorporates sensor data and boundary conditions in the training process.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>sensor_list</code> <p>List containing: - sensor_points: Coordinates of sensor locations - sensor_values: Measured values at sensors</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel_Inverse_Domain( ...     layer_dims=[2, 64, 64, 2],  # Last layer has 2 outputs ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32, ...     sensor_list=[sensor_points, sensor_values] ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The model outputs include both the solution and the identified parameter. The training process balances PDE residuals, boundary conditions, and sensor data matching.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>class DenseModel_Inverse_Domain(tf.keras.Model):\n    \"\"\"Neural network model for domain-based PDE inverse problems.\n\n    This class implements a custom neural network architecture specifically\n    designed for solving inverse problems in PDEs where parameters are\n    constant over the domain. It incorporates sensor data and boundary\n    conditions in the training process.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        tensor_dtype: TensorFlow data type for computations\n        sensor_list: List containing:\n            - sensor_points: Coordinates of sensor locations\n            - sensor_values: Measured values at sensors\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel_Inverse_Domain(\n        ...     layer_dims=[2, 64, 64, 2],  # Last layer has 2 outputs\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32,\n        ...     sensor_list=[sensor_points, sensor_values]\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The model outputs include both the solution and the identified\n        parameter. The training process balances PDE residuals, boundary\n        conditions, and sensor data matching.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        orig_factor_matrices: list,\n        force_function_list: list,\n        sensor_list: list,  # for inverse problem\n        tensor_dtype,\n        use_attention: bool = False,\n        activation: str = \"tanh\",\n        hessian: bool = False,\n    ):\n        \"\"\"\n        Constructor for the DenseModel_Inverse_Domain class.\n\n        Args:\n            layer_dims (list): List of neurons per layer including input/output\n            learning_rate_dict (dict): Learning rate configuration\n            params_dict (dict): Model parameters\n            loss_function: Custom loss function for PDE residuals\n            input_tensors_list (list): List of input tensors\n            orig_factor_matrices (list): List of factor matrices\n            force_function_list (list): List of force functions\n            sensor_list (list): List of sensor data\n            tensor_dtype: TensorFlow data type for computations\n            use_attention (bool): Whether to use attention mechanism\n            activation (str): Activation function for hidden layers\n            hessian (bool): Whether to compute Hessian\n\n        Returns:\n            None\n        \"\"\"\n        super(DenseModel_Inverse_Domain, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        self.sensor_list = sensor_list\n        # obtain sensor values\n        self.sensor_points = sensor_list[0]\n        self.sensor_values = sensor_list[1]\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        # staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        # build the model using the input shape of the first layer in self.layer_dims\n        input_shape = (None, self.layer_dims[0])\n        # build the model\n        self.build(input_shape=input_shape)\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        # print model summary\n        self.summary()\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                layers.Dense(\n                    self.layer_dims[dim + 1],\n                    activation=self.activation,\n                    kernel_initializer=\"glorot_uniform\",\n                    dtype=self.tensor_dtype,\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            layers.Dense(\n                self.layer_dims[-1],\n                activation=None,\n                kernel_initializer=\"glorot_uniform\",\n                dtype=self.tensor_dtype,\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"\n        The call method for the model.\n\n        Args:\n            inputs: The input tensor to the model.\n\n        Returns:\n            tf.Tensor: The output tensor from the model.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"\n        Get the configuration of the model.\n\n        Returns:\n            dict: The configuration of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n                \"sensor_list\": self.sensor_list,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"\n        The train step method for the model.\n\n        Args:\n            beta: The weight for the boundary loss\n            bilinear_params_dict: The bilinear parameters dictionary\n\n        Returns:\n            dict: The loss values for the model.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n            # reshape the predicted values to (, 1)\n            predicted_values_dirichlet = tf.reshape(\n                predicted_values_dirichlet[:, 0], [-1, 1]\n            )\n\n            # predict the sensor values\n            predicted_sensor_values = self(self.sensor_points)\n            # reshape the predicted values to (, 1)\n            predicted_sensor_values = tf.reshape(predicted_sensor_values[:, 0], [-1, 1])\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values_actual = self(self.input_tensor)\n\n                predicted_values = predicted_values_actual[:, 0]\n                inverse_param_values = predicted_values_actual[:, 1]\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            # First column of the predicted values is the predicted value of the PDE\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # obtain inverse param gradients\n            inverse_param_gradients = tape1.gradient(\n                inverse_param_values, self.input_tensor\n            )\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            # First column of the predicted values is the predicted value of the PDE and reshape it to (N_cells, N_quadrature_points)\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            # reshape the second column of the predicted value and reshape it to (N_cells, N_quadrature_points)\n            inverse_param_values = tf.reshape(\n                inverse_param_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n                inverse_params_list=[inverse_param_values],\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Sensor loss\n            sensor_loss = tf.reduce_mean(\n                tf.square(predicted_sensor_values - self.sensor_values), axis=0\n            )\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n            \"sensor_loss\": sensor_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.__init__","title":"<code>__init__(layer_dims, learning_rate_dict, params_dict, loss_function, input_tensors_list, orig_factor_matrices, force_function_list, sensor_list, tensor_dtype, use_attention=False, activation='tanh', hessian=False)</code>","text":"<p>Constructor for the DenseModel_Inverse_Domain class.</p> <p>Parameters:</p> Name Type Description Default <code>layer_dims</code> <code>list</code> <p>List of neurons per layer including input/output</p> required <code>learning_rate_dict</code> <code>dict</code> <p>Learning rate configuration</p> required <code>params_dict</code> <code>dict</code> <p>Model parameters</p> required <code>loss_function</code> <p>Custom loss function for PDE residuals</p> required <code>input_tensors_list</code> <code>list</code> <p>List of input tensors</p> required <code>orig_factor_matrices</code> <code>list</code> <p>List of factor matrices</p> required <code>force_function_list</code> <code>list</code> <p>List of force functions</p> required <code>sensor_list</code> <code>list</code> <p>List of sensor data</p> required <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> required <code>use_attention</code> <code>bool</code> <p>Whether to use attention mechanism</p> <code>False</code> <code>activation</code> <code>str</code> <p>Activation function for hidden layers</p> <code>'tanh'</code> <code>hessian</code> <code>bool</code> <p>Whether to compute Hessian</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>def __init__(\n    self,\n    layer_dims: list,\n    learning_rate_dict: dict,\n    params_dict: dict,\n    loss_function,\n    input_tensors_list: list,\n    orig_factor_matrices: list,\n    force_function_list: list,\n    sensor_list: list,  # for inverse problem\n    tensor_dtype,\n    use_attention: bool = False,\n    activation: str = \"tanh\",\n    hessian: bool = False,\n):\n    \"\"\"\n    Constructor for the DenseModel_Inverse_Domain class.\n\n    Args:\n        layer_dims (list): List of neurons per layer including input/output\n        learning_rate_dict (dict): Learning rate configuration\n        params_dict (dict): Model parameters\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list (list): List of input tensors\n        orig_factor_matrices (list): List of factor matrices\n        force_function_list (list): List of force functions\n        sensor_list (list): List of sensor data\n        tensor_dtype: TensorFlow data type for computations\n        use_attention (bool): Whether to use attention mechanism\n        activation (str): Activation function for hidden layers\n        hessian (bool): Whether to compute Hessian\n\n    Returns:\n        None\n    \"\"\"\n    super(DenseModel_Inverse_Domain, self).__init__()\n    self.layer_dims = layer_dims\n    self.use_attention = use_attention\n    self.activation = activation\n    self.layer_list = []\n    self.loss_function = loss_function\n    self.hessian = hessian\n\n    self.tensor_dtype = tensor_dtype\n\n    self.sensor_list = sensor_list\n    # obtain sensor values\n    self.sensor_points = sensor_list[0]\n    self.sensor_values = sensor_list[1]\n\n    # if dtype is not a valid tensorflow dtype, raise an error\n    if not isinstance(self.tensor_dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    self.orig_factor_matrices = orig_factor_matrices\n    self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n    self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[1]\n    )\n    self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[2]\n    )\n\n    self.force_function_list = force_function_list\n\n    self.input_tensors_list = input_tensors_list\n    self.input_tensor = copy.deepcopy(input_tensors_list[0])\n    self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n    self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n    self.params_dict = params_dict\n\n    self.pre_multiplier_val = self.shape_function_mat_list\n    self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n    self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n    self.force_matrix = self.force_function_list\n\n    print(f\"{'-'*74}\")\n    print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n    print(f\"{'-'*74}\")\n    print(\n        f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n    )\n    print(\n        f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n    )\n    print(f\"{'-'*74}\")\n\n    self.n_cells = params_dict[\"n_cells\"]\n\n    ## ----------------------------------------------------------------- ##\n    ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # parse the learning rate dictionary\n    self.learning_rate_dict = learning_rate_dict\n    initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n    use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n    decay_steps = learning_rate_dict[\"decay_steps\"]\n    decay_rate = learning_rate_dict[\"decay_rate\"]\n    # staircase = learning_rate_dict[\"staircase\"]\n\n    if use_lr_scheduler:\n        learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n            initial_learning_rate, decay_steps, decay_rate, staircase=True\n        )\n    else:\n        learning_rate_fn = initial_learning_rate\n\n    self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n    # build the model using the input shape of the first layer in self.layer_dims\n    input_shape = (None, self.layer_dims[0])\n    # build the model\n    self.build(input_shape=input_shape)\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    # print model summary\n    self.summary()\n\n    ## ----------------------------------------------------------------- ##\n    ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # Build dense layers based on the input list\n    for dim in range(len(self.layer_dims) - 2):\n        self.layer_list.append(\n            layers.Dense(\n                self.layer_dims[dim + 1],\n                activation=self.activation,\n                kernel_initializer=\"glorot_uniform\",\n                dtype=self.tensor_dtype,\n                bias_initializer=\"zeros\",\n            )\n        )\n\n    # Add a output layer with no activation\n    self.layer_list.append(\n        layers.Dense(\n            self.layer_dims[-1],\n            activation=None,\n            kernel_initializer=\"glorot_uniform\",\n            dtype=self.tensor_dtype,\n            bias_initializer=\"zeros\",\n        )\n    )\n\n    # Add attention layer if required\n    if self.use_attention:\n        self.attention_layer = layers.Attention()\n\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    self.build(input_shape=(None, self.layer_dims[0]))\n\n    # print the summary of the model\n    self.summary()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.call","title":"<code>call(inputs)</code>","text":"<p>The call method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input tensor to the model.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: The output tensor from the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"\n    The call method for the model.\n\n    Args:\n        inputs: The input tensor to the model.\n\n    Returns:\n        tf.Tensor: The output tensor from the model.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.get_config","title":"<code>get_config()</code>","text":"<p>Get the configuration of the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The configuration of the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"\n    Get the configuration of the model.\n\n    Returns:\n        dict: The configuration of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n            \"sensor_list\": self.sensor_list,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>The train step method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <p>The weight for the boundary loss</p> <code>10</code> <code>bilinear_params_dict</code> <p>The bilinear parameters dictionary</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loss values for the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"\n    The train step method for the model.\n\n    Args:\n        beta: The weight for the boundary loss\n        bilinear_params_dict: The bilinear parameters dictionary\n\n    Returns:\n        dict: The loss values for the model.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n        # reshape the predicted values to (, 1)\n        predicted_values_dirichlet = tf.reshape(\n            predicted_values_dirichlet[:, 0], [-1, 1]\n        )\n\n        # predict the sensor values\n        predicted_sensor_values = self(self.sensor_points)\n        # reshape the predicted values to (, 1)\n        predicted_sensor_values = tf.reshape(predicted_sensor_values[:, 0], [-1, 1])\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values_actual = self(self.input_tensor)\n\n            predicted_values = predicted_values_actual[:, 0]\n            inverse_param_values = predicted_values_actual[:, 1]\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        # First column of the predicted values is the predicted value of the PDE\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # obtain inverse param gradients\n        inverse_param_gradients = tape1.gradient(\n            inverse_param_values, self.input_tensor\n        )\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        # First column of the predicted values is the predicted value of the PDE and reshape it to (N_cells, N_quadrature_points)\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        # reshape the second column of the predicted value and reshape it to (N_cells, N_quadrature_points)\n        inverse_param_values = tf.reshape(\n            inverse_param_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n            inverse_params_list=[inverse_param_values],\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Sensor loss\n        sensor_loss = tf.reduce_mean(\n            tf.square(predicted_sensor_values - self.sensor_values), axis=0\n        )\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n        \"sensor_loss\": sensor_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d/","title":"cd2d","text":"<p>Loss Function Implementation for 2D Convection-Diffusion Problem.</p> <p>This module implements the loss function for solving 2D convection-diffusion  equations using neural networks. It focuses on computing residuals in the weak  form of the PDE with known coefficients.</p> Key functions <ul> <li>pde_loss_cd2d: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d/#scirex.core.sciml.fastvpinns.physics.cd2d.pde_loss_cd2d","title":"<code>pde_loss_cd2d(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params)</code>","text":"<p>Calculates residual for 2D convection-diffusion problem.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D convection-diffusion equations with known coefficients using efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient b_x: x-direction convection coefficient b_y: y-direction convection coefficient c: reaction coefficient</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9 - Reaction term: \u222bcuv d\u03a9 where \u03b5, b, and c are known coefficients.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\cd2d.py</code> <pre><code>def pde_loss_cd2d(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for 2D convection-diffusion problem.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D convection-diffusion equations with known coefficients using\n    efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            eps: Diffusion coefficient\n            b_x: x-direction convection coefficient\n            b_y: y-direction convection coefficient\n            c: reaction coefficient\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9\n        - Reaction term: \u222bcuv d\u03a9\n        where \u03b5, b, and c are known coefficients.\n    \"\"\"\n\n    # Loss Function : \u222bdu/dx. dv/dx  +  \u222bdu/dy. dv/dy - \u222bf.v\n\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = bilinear_params[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    # \u222bdu/dx. v d\u03a9\n    conv_x = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_x_nn))\n\n    # # \u222bdu/dy. v d\u03a9\n    conv_y = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_y_nn))\n\n    # # b(x) * \u222bdu/dx. v d\u03a9 + b(y) * \u222bdu/dy. v d\u03a9\n    conv = bilinear_params[\"b_x\"] * conv_x + bilinear_params[\"b_y\"] * conv_y\n\n    # reaction term\n    # \u222bc.u.v d\u03a9\n    reaction = bilinear_params[\"c\"] * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = (pde_diffusion + conv + reaction) - forcing_function\n\n    # Perform Reduce mean along the axis 0\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse/","title":"cd2d_inverse","text":"<p>Loss Function Implementation for Convection-Diffusion 2D Inverse Problems.</p> <p>This module implements the loss function for solving inverse problems in 2D convection-diffusion equations with constant coefficients using neural networks. It focuses on computing residuals in the weak form of the PDE for parameter identification.</p> Key functions <ul> <li>pde_loss_cd2d: Computes domain-based PDE loss for constant coefficients</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse/#scirex.core.sciml.fastvpinns.physics.cd2d_inverse.pde_loss_cd2d","title":"<code>pde_loss_cd2d(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params_dict, inverse_param_dict)</code>","text":"<p>Calculates residual for convection-diffusion inverse problem with constant coefficients.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D convection-diffusion inverse problems. Handles constant coefficient identification through efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params_dict</code> <code>dict</code> <p>Dictionary containing: b_x: x-direction convection coefficient b_y: y-direction convection coefficient c: reaction coefficient</p> required <code>inverse_param_dict</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient to be identified</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9 - Reaction term: \u222bcuv d\u03a9 where \u03b5 is the constant diffusion coefficient to be identified.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\cd2d_inverse.py</code> <pre><code>def pde_loss_cd2d(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params_dict: dict,\n    inverse_param_dict: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for convection-diffusion inverse problem with constant coefficients.\n\n    Implements the FastVPINNs methodology for computing variational residuals in 2D\n    convection-diffusion inverse problems. Handles constant coefficient identification\n    through efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params_dict: Dictionary containing:\n            b_x: x-direction convection coefficient\n            b_y: y-direction convection coefficient\n            c: reaction coefficient\n        inverse_param_dict: Dictionary containing:\n            eps: Diffusion coefficient to be identified\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9\n        - Reaction term: \u222bcuv d\u03a9\n        where \u03b5 is the constant diffusion coefficient to be identified.\n    \"\"\"\n\n    # Loss Function : \u222bdu/dx. dv/dx  +  \u222bdu/dy. dv/dy - \u222bf.v\n\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = inverse_param_dict[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    # \u222bdu/dx. v d\u03a9\n    conv_x = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_x_nn))\n\n    # # \u222bdu/dy. v d\u03a9\n    conv_y = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_y_nn))\n\n    # # b(x) * \u222bdu/dx. v d\u03a9 + b(y) * \u222bdu/dy. v d\u03a9\n    conv = bilinear_params_dict[\"b_x\"] * conv_x + bilinear_params_dict[\"b_y\"] * conv_y\n\n    # reaction term\n    # \u222bc.u.v d\u03a9\n    reaction = bilinear_params_dict[\"c\"] * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = (pde_diffusion + conv + reaction) - forcing_function\n\n    # Perform Reduce mean along the axis 0\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse_domain/","title":"cd2d_inverse_domain","text":"<p>Loss Function Implementation for Convection-Diffusion 2D Inverse Problems.</p> <p>This module implements the loss function for solving inverse problems in 2D convection-diffusion equations using neural networks. It focuses on computing residuals in the weak form of the PDE for parameter identification.</p> Key functions <ul> <li>pde_loss_cd2d_inverse_domain: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries  DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse_domain/#scirex.core.sciml.fastvpinns.physics.cd2d_inverse_domain.pde_loss_cd2d_inverse_domain","title":"<code>pde_loss_cd2d_inverse_domain(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params, inverse_params_list)</code>","text":"<p>Computes domain-based loss for 2D convection-diffusion inverse problem.</p> <p>Implements the weak form residual calculation for parameter identification in 2D convection-diffusion equations. The loss includes diffusion, convection, and reaction terms.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: - b_x: x-direction convection coefficient - b_y: y-direction convection coefficient - c: reaction coefficient</p> required <code>inverse_params_list</code> <code>list</code> <p>List containing: - diffusion coefficient neural network</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Notes <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9 - Reaction term: \u222bcuv d\u03a9 where \u03b5 is the diffusion coefficient to be identified.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\cd2d_inverse_domain.py</code> <pre><code>def pde_loss_cd2d_inverse_domain(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n    inverse_params_list: list,\n) -&gt; tf.Tensor:\n    \"\"\"Computes domain-based loss for 2D convection-diffusion inverse problem.\n\n    Implements the weak form residual calculation for parameter identification\n    in 2D convection-diffusion equations. The loss includes diffusion,\n    convection, and reaction terms.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            - b_x: x-direction convection coefficient\n            - b_y: y-direction convection coefficient\n            - c: reaction coefficient\n        inverse_params_list: List containing:\n            - diffusion coefficient neural network\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Notes:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9\n        - Reaction term: \u222bcuv d\u03a9\n        where \u03b5 is the diffusion coefficient to be identified.\n    \"\"\"\n\n    # The first values in the inverse_params_list is the number of inverse problems\n    diffusion_coeff_NN = inverse_params_list[0]\n\n    # \u222b\u03b5.du/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(\n        tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn * diffusion_coeff_NN)\n    )\n\n    # \u222b\u03b5.du/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(\n        tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn * diffusion_coeff_NN)\n    )\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    # Here our eps is a variable which is to be learned, Which is already premultiplied with the predicted gradient of the neural network\n    pde_diffusion = pde_diffusion_x + pde_diffusion_y\n\n    # \u222bdu/dx. v d\u03a9\n    conv_x = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_x_nn))\n\n    # # \u222bdu/dy. v d\u03a9\n    conv_y = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_y_nn))\n\n    # # b(x) * \u222bdu/dx. v d\u03a9 + b(y) * \u222bdu/dy. v d\u03a9\n    conv = bilinear_params[\"b_x\"] * conv_x + bilinear_params[\"b_y\"] * conv_y\n\n    # reaction term\n    # \u222bc.u.v d\u03a9\n    reaction = bilinear_params[\"c\"] * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = (pde_diffusion + conv + reaction) - forcing_function\n\n    # Perform Reduce mean along the axis 0\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/helmholtz2d/","title":"helmholtz2d","text":"<p>Loss Function Implementation for 2D Helmholtz Problem.</p> <p>This module implements the loss function for solving the 2D Helmholtz equation using neural networks. It focuses on computing residuals in the weak form  of the PDE with wave number parameter.</p> Key functions <ul> <li>pde_loss_helmholtz: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/helmholtz2d/#scirex.core.sciml.fastvpinns.physics.helmholtz2d.pde_loss_helmholtz","title":"<code>pde_loss_helmholtz(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params)</code>","text":"<p>Calculates residual for 2D Helmholtz equation.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D Helmholtz equation (-\u0394u - k\u00b2u = f) using efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient (typically 1.0) k: Wave number parameter</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: -\u222b\u2207u\u00b7\u2207v d\u03a9 - Wave term: \u222bk\u00b2uv d\u03a9 Implementation handles high wave numbers through efficient tensor operations.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\helmholtz2d.py</code> <pre><code>def pde_loss_helmholtz(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for 2D Helmholtz equation.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D Helmholtz equation (-\u0394u - k\u00b2u = f) using efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            eps: Diffusion coefficient (typically 1.0)\n            k: Wave number parameter\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: -\u222b\u2207u\u00b7\u2207v d\u03a9\n        - Wave term: \u222bk\u00b2uv d\u03a9\n        Implementation handles high wave numbers through efficient\n        tensor operations.\n    \"\"\"\n    #  \u222b (du/dx. dv/dx ) d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    #  \u222b (du/dy. dv/dy ) d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = bilinear_params[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    # \\int(k^2 (u).v) dw\n    helmholtz_additional = (bilinear_params[\"k\"] ** 2) * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = -1.0 * (pde_diffusion) + helmholtz_additional - forcing_function\n\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/helmholtz2d/#helmholtz-equation-loss-calculation-module","title":"Helmholtz Equation Loss Calculation Module","text":""},{"location":"api/core/sciml/fastvpinns/physics/poisson2d/","title":"poisson2d","text":"<p>Implementation of Tensor-Based Loss Calculation for 2D Poisson Equation.</p> <p>This module implements an efficient tensor-based approach for calculating variational residuals in 2D Poisson problems. The implementation leverages TensorFlow's tensor operations for fast computation of weak form terms.</p> Key functions <ul> <li>pde_loss_poisson: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/poisson2d/#scirex.core.sciml.fastvpinns.physics.poisson2d.pde_loss_poisson","title":"<code>pde_loss_poisson(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params)</code>","text":"<p>Calculates residual for 2D Poisson equation.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D Poisson equation (-\u2207\u00b7(\u03b5\u2207u) = f) using efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 The implementation uses efficient tensor operations for computing the variational residual.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\poisson2d.py</code> <pre><code>def pde_loss_poisson(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for 2D Poisson equation.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D Poisson equation (-\u2207\u00b7(\u03b5\u2207u) = f) using efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            eps: Diffusion coefficient\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        The implementation uses efficient tensor operations for\n        computing the variational residual.\n    \"\"\"\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = bilinear_params[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    residual_matrix = pde_diffusion - forcing_function\n\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/poisson_2d_inverse/","title":"poissson2d Inverse","text":"<p>Loss Function Implementation for 2D Poisson Inverse Problem.</p> <p>This module implements the loss function for solving the inverse Poisson equation with constant coefficient using neural networks. It focuses on computing residuals in the weak form of the PDE for diffusion coefficient identification.</p> Key functions <ul> <li>pde_loss_poisson_inverse: Computes domain-based PDE loss for   constant coefficient identification</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/poisson_2d_inverse/#scirex.core.sciml.fastvpinns.physics.poisson2d_inverse.pde_loss_poisson_inverse","title":"<code>pde_loss_poisson_inverse(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params, inverse_params_dict)</code>","text":"<p>Calculates residual for Poisson inverse problem with constant coefficient.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D Poisson inverse problems (-\u2207\u00b7(\u03b5\u2207u) = f) with unknown constant diffusion coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Additional bilinear form parameters (if any)</p> required <code>inverse_params_dict</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient to be identified</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 where \u03b5 is the constant diffusion coefficient to be identified.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\poisson2d_inverse.py</code> <pre><code>def pde_loss_poisson_inverse(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n    inverse_params_dict: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for Poisson inverse problem with constant coefficient.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D Poisson inverse problems (-\u2207\u00b7(\u03b5\u2207u) = f) with unknown constant\n    diffusion coefficient.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Additional bilinear form parameters (if any)\n        inverse_params_dict: Dictionary containing:\n            eps: Diffusion coefficient to be identified\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        where \u03b5 is the constant diffusion coefficient to be identified.\n    \"\"\"\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = inverse_params_dict[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    residual_matrix = pde_diffusion - forcing_function\n\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/","title":"Chebyshev","text":"<p>Module: basis_2d_qn_chebyshev_2.py</p> <p>This module implements a specialized basis function class for 2D finite elements using Chebyshev polynomials.  It provides functionality for computing basis functions and their derivatives in two dimensions, primarily used  in variational physics-informed neural networks (VPINNs) with domain decomposition.</p> <p>Classes:</p> Name Description <code>Basis2DQNChebyshev2</code> <p>Main class implementing 2D basis functions using Chebyshev polynomials</p> Dependencies <ul> <li>numpy: For numerical computations and array operations</li> <li>scipy.special: For Jacobi polynomial calculations and evaluations</li> <li>.basis_function_2d: For base class BasisFunction2D implementation</li> </ul> Key Features <ul> <li>Implementation of 2D element basis functions using Chebyshev polynomials</li> <li>Computation of function values and derivatives up to second order</li> <li>Tensor product construction of 2D basis functions from 1D components</li> <li>Specialized handling of Jacobi polynomials for test functions</li> <li>Support for variable number of shape functions through initialization</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> Version Info <p>27/Dec/2024: Initial version: Thivin Anandh D</p> References <ul> <li>hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/","title":"jacobi","text":"<p>Module: basis_2d_QN_Jacobi.py</p> <p>This module implements a specialized basis function class for 2D QN finite elements using Jacobi polynomials.   It provides functionality for computing basis functions and their derivatives in two dimensions, primarily used   in variational physics-informed neural networks (VPINNs) with domain decomposition.</p> <p>Classes:      Basis2DQNJacobi: Main class implementing 2D basis functions using Jacobi polynomials</p> <p>Dependencies:      - numpy: For numerical computations      - scipy.special: For Jacobi polynomial calculations      - .basis_function_2d: For base class implementation</p> <p>Key Features:      - Implementation of 2D QN element basis functions using Jacobi polynomials      - Computation of function values and derivatives up to second order      - Tensor product construction of 2D basis functions from 1D components      - Specialized handling of Jacobi polynomials for test functions      - Support for variable number of shape functions</p> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> <p>Version Info:      27/Dec/2024: Initial version: Thivin Anandh D</p> <p>References:      - hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition: https://github.com/ehsankharazmi/hp-VPINNs/</p>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/","title":"Legendre","text":"<p>Module: basis_2d_QN_Legendre.py</p> <p>This module implements a specialized basis function class for 2D Quad elements using Legendre polynomials.  It provides functionality for computing basis functions and their derivatives in two dimensions, primarily used  in variational physics-informed neural networks (VPINNs) with domain decomposition.</p> <p>Classes:</p> Name Description <code>Basis2DQNLegendre</code> <p>Main class implementing 2D basis functions using Legendre polynomials</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>scipy.special: For Jacobi polynomial calculations</li> <li>.basis_function_2d: For base class implementation</li> </ul> Key Features <ul> <li>Implementation of 2D Q1 element basis functions using Legendre polynomials</li> <li>Computation of function values and derivatives up to second order</li> <li>Tensor product construction of 2D basis functions from 1D components</li> <li>Specialized handling of Jacobi polynomials for test functions</li> <li>Support for variable number of shape functions</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> <p>Version Info:     27/Dec/2024: Initial version: Thivin Anandh D</p> References <ul> <li>hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/","title":"Legendre_Special","text":"<p>Module: basis_2d_QN_Legendre_Special.py</p> <p>This module implements a specialized basis function class for 2D Quad elements using Legendre polynomials.  It provides functionality for computing basis functions and their derivatives in two dimensions, with a  special formulation based on differences of consecutive Legendre polynomials.</p> <p>Classes:</p> Name Description <code>Basis2DQNLegendreSpecial</code> <p>Main class implementing 2D basis functions using special Legendre polynomials</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>scipy.special: For Legendre polynomial calculations</li> <li>matplotlib.pyplot: For visualization support</li> <li>.basis_function_2d: For base class implementation</li> </ul> Key Features <ul> <li>Implementation of 2D Quad element basis functions using Legendre polynomials</li> <li>Special formulation using differences of consecutive polynomials</li> <li>Computation of function values and derivatives up to second order</li> <li>Tensor product construction of 2D basis functions from 1D components</li> <li>Support for variable number of shape functions</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> <p>Version Info:     27/Dec/2024: Initial version: Thivin Anandh D References:     None</p>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/","title":"Function 2D","text":"<p>Module: basis_function_2d.py</p> <p>This module provides the abstract base class for all 2D finite element basis functions  used in the FE2D code. It defines the interface for computing basis functions and their  derivatives in reference coordinates.</p> <p>Classes:</p> Name Description <code>BasisFunction2D</code> <p>Abstract base class for 2D finite element basis functions</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Abstract interface for 2D basis function evaluation</li> <li>Support for first and second order derivatives</li> <li>Reference coordinate system (xi, eta) implementation</li> <li>Unified interface for different polynomial bases</li> <li>Common structure for Legendre, Jacobi, and Chebyshev implementations</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> Version Info <p>27/Dec/2024: Initial version: Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D","title":"<code>BasisFunction2D</code>","text":"<p>An abstract base class defining the interface for two-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 2D basis functions (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines the required methods for function evaluation and derivatives.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Number of shape functions in the element. Typically a perfect square for tensor-product bases.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates basis functions at given reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of basis functions at (xi, eta)</p> <code>gradx</code> <p>Computes x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of x-derivatives at (xi, eta)</p> <code>grady</code> <p>Computes y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of y-derivatives at (xi, eta)</p> <code>gradxx</code> <p>Computes second x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second x-derivatives at (xi, eta)</p> <code>gradxy</code> <p>Computes mixed derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of mixed derivatives at (xi, eta)</p> <code>gradyy</code> <p>Computes second y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second y-derivatives at (xi, eta)</p> Notes <ul> <li>All coordinate inputs (xi, eta) should be in the reference element range</li> <li>Subclasses must implement all abstract methods</li> <li>Used as base class for specific polynomial implementations:<ul> <li>Legendre polynomials (normal and special variants)</li> <li>Jacobi polynomials</li> <li>Chebyshev polynomials</li> </ul> </li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>class BasisFunction2D:\n    \"\"\"\n    An abstract base class defining the interface for two-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 2D basis functions\n    (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines\n    the required methods for function evaluation and derivatives.\n\n    Attributes:\n        num_shape_functions (int): Number of shape functions in the element.\n            Typically a perfect square for tensor-product bases.\n\n    Methods:\n        value(xi, eta): Evaluates basis functions at given reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of basis functions at (xi, eta)\n\n        gradx(xi, eta): Computes x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of x-derivatives at (xi, eta)\n\n        grady(xi, eta): Computes y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of y-derivatives at (xi, eta)\n\n        gradxx(xi, eta): Computes second x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second x-derivatives at (xi, eta)\n\n        gradxy(xi, eta): Computes mixed derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of mixed derivatives at (xi, eta)\n\n        gradyy(xi, eta): Computes second y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second y-derivatives at (xi, eta)\n\n    Notes:\n        - All coordinate inputs (xi, eta) should be in the reference element range\n        - Subclasses must implement all abstract methods\n        - Used as base class for specific polynomial implementations:\n            - Legendre polynomials (normal and special variants)\n            - Jacobi polynomials\n            - Chebyshev polynomials\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (float): The xi coordinate.\n            eta (float): The eta coordinate.\n\n        Returns:\n            float: The value of the basis function at ( xi, eta).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradx","title":"<code>gradx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradxx","title":"<code>gradxx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradxy","title":"<code>gradxy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.grady","title":"<code>grady(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradyy","title":"<code>gradyy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.value","title":"<code>value(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>float</code> <p>The xi coordinate.</p> required <code>eta</code> <code>float</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>The value of the basis function at ( xi, eta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (float): The xi coordinate.\n        eta (float): The eta coordinate.\n\n    Returns:\n        float: The value of the basis function at ( xi, eta).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/","title":"Function 3D","text":"<p>Module: basis_function_3d.py</p> <p>This module provides the abstract base class for all 3D finite element basis functions.  It defines the interface for computing basis functions and their derivatives in three-dimensional  reference coordinates.</p> <p>Classes:</p> Name Description <code>BasisFunction3D</code> <p>Abstract base class for 3D finite element basis functions</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Abstract interface for 3D basis function evaluation</li> <li>Support for first and second order derivatives</li> <li>Reference coordinate system (xi, eta, zeta) implementation</li> <li>Unified interface for different polynomial bases</li> <li>Systematic derivative computation in three dimensions</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version: Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D","title":"<code>BasisFunction3D</code>","text":"<p>An abstract base class defining the interface for three-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 3D basis functions used in finite element computations. It defines the required methods for function evaluation and derivatives in three dimensions.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>The number of shape functions in the 3D element. Must be specified during initialization.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates the basis function at given coordinates Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Value of basis function at (xi, eta, zeta)</p> <code>gradx</code> <p>Computes derivative w.r.t. xi Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Partial derivative w.r.t. xi</p> <code>grady</code> <p>Computes derivative w.r.t. eta Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Partial derivative w.r.t. eta</p> <code>gradxx</code> <p>Computes second derivative w.r.t. xi Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Second partial derivative w.r.t. xi</p> <code>gradxy</code> <p>Computes mixed derivative w.r.t. xi and eta Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Mixed partial derivative w.r.t. xi and eta</p> <code>gradyy</code> <p>Computes second derivative w.r.t. eta Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Second partial derivative w.r.t. eta</p> Notes <ul> <li>All coordinate inputs (xi, eta, zeta) should be in the reference element range</li> <li>All methods are abstract and must be implemented by derived classes</li> <li>Implementation should ensure proper handling of 3D tensor-product bases</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>class BasisFunction3D:  # pragma: no cover\n    \"\"\"\n    An abstract base class defining the interface for three-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 3D basis functions\n    used in finite element computations. It defines the required methods for function\n    evaluation and derivatives in three dimensions.\n\n    Attributes:\n        num_shape_functions (int): The number of shape functions in the 3D element.\n            Must be specified during initialization.\n\n    Methods:\n        value(xi, eta, zeta): Evaluates the basis function at given coordinates\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Value of basis function at (xi, eta, zeta)\n\n        gradx(xi, eta, zeta): Computes derivative w.r.t. xi\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Partial derivative w.r.t. xi\n\n        grady(xi, eta, zeta): Computes derivative w.r.t. eta\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Partial derivative w.r.t. eta\n\n        gradxx(xi, eta, zeta): Computes second derivative w.r.t. xi\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Second partial derivative w.r.t. xi\n\n        gradxy(xi, eta, zeta): Computes mixed derivative w.r.t. xi and eta\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Mixed partial derivative w.r.t. xi and eta\n\n        gradyy(xi, eta, zeta): Computes second derivative w.r.t. eta\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Second partial derivative w.r.t. eta\n\n    Notes:\n        - All coordinate inputs (xi, eta, zeta) should be in the reference element range\n        - All methods are abstract and must be implemented by derived classes\n        - Implementation should ensure proper handling of 3D tensor-product bases\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi, eta, zeta):\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The value of the basis function at (xi, eta, zeta).\n        \"\"\"\n\n    @abstractmethod\n    def gradx(self, xi, eta, zeta):\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n\n    @abstractmethod\n    def grady(self, xi, eta, zeta):\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n\n    @abstractmethod\n    def gradxx(self, xi, eta, zeta):\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n\n    @abstractmethod\n    def gradxy(self, xi, eta, zeta):\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n\n    @abstractmethod\n    def gradyy(self, xi, eta, zeta):\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradx","title":"<code>gradx(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi, eta, zeta):\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradxx","title":"<code>gradxx(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi, eta, zeta):\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradxy","title":"<code>gradxy(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi, eta, zeta):\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.grady","title":"<code>grady(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi, eta, zeta):\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradyy","title":"<code>gradyy(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi, eta, zeta):\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.value","title":"<code>value(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The value of the basis function at (xi, eta, zeta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef value(self, xi, eta, zeta):\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The value of the basis function at (xi, eta, zeta).\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/","title":"Fe2d cell","text":"<p>Module: FE2D_Cell.py</p> <p>This module provides functionality for setting up and managing finite element  calculations for individual 2D cells, including basis functions, quadrature  rules, and transformations.</p> <p>Classes:</p> Name Description <code>FE2D_Cell</code> <p>Main class for managing cell-level FE computations</p> Dependencies <ul> <li>basis_function_2d: Base classes for 2D basis functions</li> <li>quadratureformulas_quad2d: Quadrature rules for 2D elements</li> <li>fe2d_setup_main: Setup utilities for 2D FE calculations</li> <li>numpy: Numerical computations</li> </ul> Key Features <ul> <li>Cell-level finite element value storage</li> <li>Basis function evaluation at quadrature points</li> <li>Reference to physical domain transformations</li> <li>Gradient and derivative computations</li> <li>Quadrature rule implementation</li> <li>Forcing function integration</li> <li>Support for different element types and orders</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> Notes <p>The implementation includes optimization for gradient calculations where grad_x_orig and grad_y_orig store multiplication factors for reference gradients to improve computational efficiency.</p>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D","title":"<code>BasisFunction2D</code>","text":"<p>An abstract base class defining the interface for two-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 2D basis functions (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines the required methods for function evaluation and derivatives.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Number of shape functions in the element. Typically a perfect square for tensor-product bases.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates basis functions at given reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of basis functions at (xi, eta)</p> <code>gradx</code> <p>Computes x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of x-derivatives at (xi, eta)</p> <code>grady</code> <p>Computes y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of y-derivatives at (xi, eta)</p> <code>gradxx</code> <p>Computes second x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second x-derivatives at (xi, eta)</p> <code>gradxy</code> <p>Computes mixed derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of mixed derivatives at (xi, eta)</p> <code>gradyy</code> <p>Computes second y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second y-derivatives at (xi, eta)</p> Notes <ul> <li>All coordinate inputs (xi, eta) should be in the reference element range</li> <li>Subclasses must implement all abstract methods</li> <li>Used as base class for specific polynomial implementations:<ul> <li>Legendre polynomials (normal and special variants)</li> <li>Jacobi polynomials</li> <li>Chebyshev polynomials</li> </ul> </li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>class BasisFunction2D:\n    \"\"\"\n    An abstract base class defining the interface for two-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 2D basis functions\n    (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines\n    the required methods for function evaluation and derivatives.\n\n    Attributes:\n        num_shape_functions (int): Number of shape functions in the element.\n            Typically a perfect square for tensor-product bases.\n\n    Methods:\n        value(xi, eta): Evaluates basis functions at given reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of basis functions at (xi, eta)\n\n        gradx(xi, eta): Computes x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of x-derivatives at (xi, eta)\n\n        grady(xi, eta): Computes y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of y-derivatives at (xi, eta)\n\n        gradxx(xi, eta): Computes second x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second x-derivatives at (xi, eta)\n\n        gradxy(xi, eta): Computes mixed derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of mixed derivatives at (xi, eta)\n\n        gradyy(xi, eta): Computes second y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second y-derivatives at (xi, eta)\n\n    Notes:\n        - All coordinate inputs (xi, eta) should be in the reference element range\n        - Subclasses must implement all abstract methods\n        - Used as base class for specific polynomial implementations:\n            - Legendre polynomials (normal and special variants)\n            - Jacobi polynomials\n            - Chebyshev polynomials\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (float): The xi coordinate.\n            eta (float): The eta coordinate.\n\n        Returns:\n            float: The value of the basis function at ( xi, eta).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradx","title":"<code>gradx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradxx","title":"<code>gradxx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradxy","title":"<code>gradxy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.grady","title":"<code>grady(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradyy","title":"<code>gradyy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.value","title":"<code>value(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>float</code> <p>The xi coordinate.</p> required <code>eta</code> <code>float</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>The value of the basis function at ( xi, eta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (float): The xi coordinate.\n        eta (float): The eta coordinate.\n\n    Returns:\n        float: The value of the basis function at ( xi, eta).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain","title":"<code>FE2DSetupMain</code>","text":"<p>Main configuration class for 2D finite element analysis setup.</p> <p>This class handles the configuration and initialization of finite element analysis components, including basis functions, quadrature rules, and geometric transformations.</p> <p>Attributes:</p> Name Type Description <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the element</p> Example <p>setup = FE2DSetupMain( ...     cell_type='quadrilateral', ...     fe_order=2, ...     fe_type='legendre', ...     quad_order=3, ...     quad_type='gauss' ... ) basis = setup.assign_basis_function() weights, xi, eta = setup.assign_quadrature_rules()</p> Notes <ul> <li>Supports only quadrilateral elements currently</li> <li>Validates all input parameters for correctness</li> <li>Provides different polynomial basis options</li> <li>Handles both affine and bilinear transformations</li> <li>Quadrature order must be &gt;= 3 for accuracy</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>class FE2DSetupMain:\n    \"\"\"\n    Main configuration class for 2D finite element analysis setup.\n\n    This class handles the configuration and initialization of finite element\n    analysis components, including basis functions, quadrature rules, and\n    geometric transformations.\n\n    Attributes:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n        n_nodes (int): Number of nodes in the element\n\n    Example:\n        &gt;&gt;&gt; setup = FE2DSetupMain(\n        ...     cell_type='quadrilateral',\n        ...     fe_order=2,\n        ...     fe_type='legendre',\n        ...     quad_order=3,\n        ...     quad_type='gauss'\n        ... )\n        &gt;&gt;&gt; basis = setup.assign_basis_function()\n        &gt;&gt;&gt; weights, xi, eta = setup.assign_quadrature_rules()\n\n    Notes:\n        - Supports only quadrilateral elements currently\n        - Validates all input parameters for correctness\n        - Provides different polynomial basis options\n        - Handles both affine and bilinear transformations\n        - Quadrature order must be &gt;= 3 for accuracy\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n    ):\n        \"\"\"\n        Constructor for the FE2DSetupMain class.\n\n        Args:\n            cell_type (str): Type of finite element ('quadrilateral')\n            fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n            fe_type (str): Type of basis functions\n                ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n            quad_order (int): Order of quadrature rule (&gt;= 2)\n            quad_type (str): Type of quadrature formula\n\n        Raises:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.assign_basis_function()\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function based on the cell type and the fe_order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function object for the given configuration.\n\n        Raises:\n            ValueError: If the fe order is invalid or the cell type is invalid.\n        \"\"\"\n        # check for fe order lower bound and higher bound\n        if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n        if self.cell_type == \"quadrilateral\":\n            self.n_nodes = 4\n\n            # --- LEGENDRE --- #\n            if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n                # jacobi is added for backward compatibility with prev pushes\n                # generally, jacobi is referred to as Legendre basis on previous iterations\n                return Basis2DQNLegendre(self.fe_order**2)\n\n            elif self.fe_type == \"legendre_special\":\n                return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n            # ----- CHEBYSHEV ---- #\n            elif self.fe_type == \"chebyshev_2\":\n                return Basis2DQNChebyshev2(self.fe_order**2)\n\n            # ----- PLain jacobi ---- #\n            elif self.fe_type == \"jacobi_plain\":\n                return Basis2DQNJacobi(self.fe_order**2)\n\n            else:\n                print(\n                    f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\n                    'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n                )\n\n        print(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_quadrature_rules(self):\n        \"\"\"\n        Assigns the quadrature rule based on the quad_order.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n        Raises:\n            ValueError: If the quad_order is invalid\n            ValueError: If the cell type is invalid\n            ValueError: If the quad_order is not between 1 and 9999\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if self.quad_order &lt; 3:\n                raise ValueError(\"Quad order should be greater than 2.\")\n            elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n                weights, xi, eta = Quadratureformulas_Quad2D(\n                    self.quad_order, self.quad_type\n                ).get_quad_values()\n                return weights, xi, eta\n            else:\n                print(\n                    f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_fe_transformation(\n        self, fe_transformation_type: str, cell_coordinates: np.ndarray\n    ) -&gt; FETransforamtion2D:\n        \"\"\"\n        Assigns the fe transformation based on the cell type.\n\n        Args:\n            fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n            cell_coordinates (np.ndarray): The cell coordinates\n\n        Returns:\n            FETransforamtion2D: The fe transformation object for the given configuration.\n\n        Raises:\n            ValueError: If the cell type is invalid\n            ValueError: If the fe transformation type is invalid\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if fe_transformation_type == \"affine\":\n                return QuadAffin(cell_coordinates)\n            elif fe_transformation_type == \"bilinear\":\n                return QuadBilinear(cell_coordinates)\n            else:\n                raise ValueError(\n                    f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n                )\n\n        else:\n            raise ValueError(\n                f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.__init__","title":"<code>__init__(cell_type, fe_order, fe_type, quad_order, quad_type)</code>","text":"<p>Constructor for the FE2DSetupMain class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> required <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> required <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def __init__(\n    self,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n):\n    \"\"\"\n    Constructor for the FE2DSetupMain class.\n\n    Args:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n\n    Raises:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function based on the cell type and the fe_order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the fe order is invalid or the cell type is invalid.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function based on the cell type and the fe_order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function object for the given configuration.\n\n    Raises:\n        ValueError: If the fe order is invalid or the cell type is invalid.\n    \"\"\"\n    # check for fe order lower bound and higher bound\n    if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n        print(\n            f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n    if self.cell_type == \"quadrilateral\":\n        self.n_nodes = 4\n\n        # --- LEGENDRE --- #\n        if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n            # jacobi is added for backward compatibility with prev pushes\n            # generally, jacobi is referred to as Legendre basis on previous iterations\n            return Basis2DQNLegendre(self.fe_order**2)\n\n        elif self.fe_type == \"legendre_special\":\n            return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n        # ----- CHEBYSHEV ---- #\n        elif self.fe_type == \"chebyshev_2\":\n            return Basis2DQNChebyshev2(self.fe_order**2)\n\n        # ----- PLain jacobi ---- #\n        elif self.fe_type == \"jacobi_plain\":\n            return Basis2DQNJacobi(self.fe_order**2)\n\n        else:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n            )\n\n    print(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.assign_fe_transformation","title":"<code>assign_fe_transformation(fe_transformation_type, cell_coordinates)</code>","text":"<p>Assigns the fe transformation based on the cell type.</p> <p>Parameters:</p> Name Type Description Default <code>fe_transformation_type</code> <code>str</code> <p>Type of fe transformation ('affine', 'bilinear')</p> required <code>cell_coordinates</code> <code>ndarray</code> <p>The cell coordinates</p> required <p>Returns:</p> Name Type Description <code>FETransforamtion2D</code> <code>FETransforamtion2D</code> <p>The fe transformation object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the fe transformation type is invalid</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_fe_transformation(\n    self, fe_transformation_type: str, cell_coordinates: np.ndarray\n) -&gt; FETransforamtion2D:\n    \"\"\"\n    Assigns the fe transformation based on the cell type.\n\n    Args:\n        fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n        cell_coordinates (np.ndarray): The cell coordinates\n\n    Returns:\n        FETransforamtion2D: The fe transformation object for the given configuration.\n\n    Raises:\n        ValueError: If the cell type is invalid\n        ValueError: If the fe transformation type is invalid\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if fe_transformation_type == \"affine\":\n            return QuadAffin(cell_coordinates)\n        elif fe_transformation_type == \"bilinear\":\n            return QuadBilinear(cell_coordinates)\n        else:\n            raise ValueError(\n                f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n\n    else:\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.assign_quadrature_rules","title":"<code>assign_quadrature_rules()</code>","text":"<p>Assigns the quadrature rule based on the quad_order.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quad_order is invalid</p> <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the quad_order is not between 1 and 9999</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_quadrature_rules(self):\n    \"\"\"\n    Assigns the quadrature rule based on the quad_order.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n    Raises:\n        ValueError: If the quad_order is invalid\n        ValueError: If the cell type is invalid\n        ValueError: If the quad_order is not between 1 and 9999\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if self.quad_order &lt; 3:\n            raise ValueError(\"Quad order should be greater than 2.\")\n        elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n            weights, xi, eta = Quadratureformulas_Quad2D(\n                self.quad_order, self.quad_type\n            ).get_quad_values()\n            return weights, xi, eta\n        else:\n            print(\n                f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n    raise ValueError(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell","title":"<code>FE2D_Cell</code>","text":"<p>A class for managing finite element computations at the cell level.</p> <p>This class handles the storage and computation of finite element values, including basis functions, quadrature rules, and transformations for a single cell in a 2D mesh.</p> <p>Attributes:</p> Name Type Description <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation</code> <code>str</code> <p>Type of geometric transformation</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>basis_function</code> <code>BasisFunction2D</code> <p>Basis function implementation</p> <code>quad_xi</code> <code>ndarray</code> <p>Xi coordinates of quadrature points</p> <code>quad_eta</code> <code>ndarray</code> <p>Eta coordinates of quadrature points</p> <code>quad_weight</code> <code>ndarray</code> <p>Quadrature weights</p> <code>jacobian</code> <code>ndarray</code> <p>Transformation Jacobian</p> <code>basis_at_quad</code> <code>ndarray</code> <p>Basis values at quadrature points</p> <code>basis_gradx_at_quad</code> <code>ndarray</code> <p>X-derivatives at quadrature points</p> <code>basis_grady_at_quad</code> <code>ndarray</code> <p>Y-derivatives at quadrature points</p> <code>quad_actual_coordinates</code> <code>ndarray</code> <p>Physical quadrature point coordinates</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) cell = FE2D_Cell( ...     cell_coordinates=coords, ...     cell_type='quad', ...     fe_order=2, ...     fe_type='lagrange', ...     quad_order=3, ...     quad_type='gauss', ...     fe_transformation_type='bilinear', ...     forcing_function=lambda x, y: x*y ... ) cell.basis_at_quad  # Get basis values at quadrature points</p> Notes <ul> <li>All gradient and derivative values are stored in the reference domain</li> <li>Jacobian and quadrature weights are combined for efficiency</li> <li>Forcing function values are typically computed in the fespace class</li> <li>Supports multiple types of transformations and element types</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>class FE2D_Cell:\n    \"\"\"\n    A class for managing finite element computations at the cell level.\n\n    This class handles the storage and computation of finite element values,\n    including basis functions, quadrature rules, and transformations for a\n    single cell in a 2D mesh.\n\n    Attributes:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n        basis_function (BasisFunction2D): Basis function implementation\n        quad_xi (np.ndarray): Xi coordinates of quadrature points\n        quad_eta (np.ndarray): Eta coordinates of quadrature points\n        quad_weight (np.ndarray): Quadrature weights\n        jacobian (np.ndarray): Transformation Jacobian\n        basis_at_quad (np.ndarray): Basis values at quadrature points\n        basis_gradx_at_quad (np.ndarray): X-derivatives at quadrature points\n        basis_grady_at_quad (np.ndarray): Y-derivatives at quadrature points\n        quad_actual_coordinates (np.ndarray): Physical quadrature point coordinates\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; cell = FE2D_Cell(\n        ...     cell_coordinates=coords,\n        ...     cell_type='quad',\n        ...     fe_order=2,\n        ...     fe_type='lagrange',\n        ...     quad_order=3,\n        ...     quad_type='gauss',\n        ...     fe_transformation_type='bilinear',\n        ...     forcing_function=lambda x, y: x*y\n        ... )\n        &gt;&gt;&gt; cell.basis_at_quad  # Get basis values at quadrature points\n\n    Notes:\n        - All gradient and derivative values are stored in the reference domain\n        - Jacobian and quadrature weights are combined for efficiency\n        - Forcing function values are typically computed in the fespace class\n        - Supports multiple types of transformations and element types\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_coordinates: np.ndarray,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        forcing_function,\n    ):\n        \"\"\"\n        Constructor for the FE2D_Cell class.\n\n        Args:\n            cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n            cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n            fe_order (int): Order of the finite element approximation\n            fe_type (str): Type of finite element basis\n            quad_order (int): Order of quadrature rule\n            quad_type (str): Type of quadrature formula\n            fe_transformation_type (str): Type of geometric transformation\n            forcing_function (callable): Source term function\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_coordinates = cell_coordinates\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.fe_transformation = fe_transformation_type\n        self.forcing_function = forcing_function\n\n        # Basis function Class\n        self.basis_function = None\n\n        # Quadrature Values\n        self.quad_xi = None\n        self.quad_eta = None\n        self.quad_weight = None\n        self.jacobian = None\n        self.mult = None\n\n        # FE Values\n        self.basis_at_quad = None\n        self.basis_gradx_at_quad = None\n        self.basis_grady_at_quad = None\n        self.basis_gradxy_at_quad = None\n        self.basis_gradxx_at_quad = None\n        self.basis_gradyy_at_quad = None\n\n        # Quadrature Coordinates\n        self.quad_actual_coordinates = None\n\n        # Forcing function values at the quadrature points\n        self.forcing_at_quad = None\n\n        # FE Transformation Class\n        self.fetransformation = None\n\n        # get instance of the FE_setup class\n        self.fe_setup = FE2DSetupMain(\n            cell_type=self.cell_type,\n            fe_order=self.fe_order,\n            fe_type=self.fe_type,\n            quad_order=self.quad_order,\n            quad_type=self.quad_type,\n        )\n\n        # Call the function to assign the basis function\n        self.assign_basis_function()\n\n        # Assign the quadrature points and weights\n        self.assign_quadrature()\n\n        # Assign the FE Transformation\n        self.assign_fe_transformation()\n\n        # calculate mult -&gt; quadrature weights * Jacobian\n        self.assign_quad_weights_and_jacobian()\n\n        # Calculate the basis function values at the quadrature points\n        self.assign_basis_values_at_quadrature_points()\n\n        # calculate the actual coordinates of the quadrature points\n        self.assign_quadrature_coordinates()\n\n        # Calculate the forcing function values at the actual quadrature points\n        # NOTE : The function is just for printing the shape of the force matrix, the\n        # actual calculation is performed on the fespace class\n        self.assign_forcing_term(self.forcing_function)\n\n        # # print the values\n        # print(\"============================================================================\")\n        # print(\"Cell Co-ord : \", self.cell_coordinates)\n        # print(\"Basis function values at the quadrature points: \\n\", self.basis_at_quad / self.mult)\n        # print(\"Basis function gradx at the quadrature points: \\n\", self.basis_gradx_at_quad)\n        # print(\"Basis function grady at the quadrature points: \\n\", self.basis_grady_at_quad)\n        # print(\"Forcing function values at the quadrature points: \\n\", self.forcing_at_quad)\n\n        # grad_x = np.array([5,6,7,8])\n        # grad_y = np.array([1,2,3,4])\n\n        # pde = np.matmul(self.basis_gradx_at_quad, grad_x.reshape(-1,1)) + np.matmul(self.basis_grady_at_quad, grad_y.reshape(-1,1))\n        # print(\"PDE values at the quadrature points: \\n\", pde)\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function class based on the cell type and the FE order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function class for the given cell type and FE order.\n        \"\"\"\n        self.basis_function = self.fe_setup.assign_basis_function()\n\n    def assign_quadrature(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_weight, self.quad_xi, self.quad_eta = (\n            self.fe_setup.assign_quadrature_rules()\n        )\n\n    def assign_fe_transformation(self) -&gt; None:\n        \"\"\"\n        Assigns the FE Transformation class based on the cell type and the FE order.\n\n        This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n        It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.fetransformation = self.fe_setup.assign_fe_transformation(\n            self.fe_transformation, self.cell_coordinates\n        )\n        # Sets cell co-ordinates for the FE Transformation\n        self.fetransformation.set_cell()\n\n        # obtains the Jacobian of the transformation\n        self.jacobian = self.fetransformation.get_jacobian(\n            self.quad_xi, self.quad_eta\n        ).reshape(-1, 1)\n\n    def assign_basis_values_at_quadrature_points(self) -&gt; None:\n        \"\"\"\n        Assigns the basis function values at the quadrature points.\n\n        This method calculates the values of the basis functions and their gradients at the quadrature points.\n        The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n        `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n        `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.basis_at_quad = []\n        self.basis_gradx_at_quad = []\n        self.basis_grady_at_quad = []\n        self.basis_gradxy_at_quad = []\n        self.basis_gradxx_at_quad = []\n        self.basis_gradyy_at_quad = []\n\n        self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n        # For Gradients we need to perform a transformation to the original cell\n        grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n        grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n        grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n            grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n        )\n\n        self.basis_gradx_at_quad = grad_x_orig\n        self.basis_grady_at_quad = grad_y_orig\n\n        self.basis_gradx_at_quad_ref = grad_x_ref\n        self.basis_grady_at_quad_ref = grad_y_ref\n\n        # get the double derivatives of the basis functions ( ref co-ordinates )\n        grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n        grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n        grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n        # get the double derivatives of the basis functions ( orig co-ordinates )\n        grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n            self.fetransformation.get_orig_from_ref_second_derivative(\n                grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n            )\n        )\n\n        # = the value\n        self.basis_gradxy_at_quad = grad_xy_orig\n        self.basis_gradxx_at_quad = grad_xx_orig\n        self.basis_gradyy_at_quad = grad_yy_orig\n\n        # Multiply each row with the quadrature weights\n        # Basis at Quad - n_test * N_quad\n        self.basis_at_quad = self.basis_at_quad * self.mult\n        self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n        self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n        self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n        self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n        self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n\n    def assign_quad_weights_and_jacobian(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature weights and the Jacobian of the transformation.\n\n        This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n        for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n        and stored in the `mult` attribute of the class.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.mult = self.quad_weight * self.jacobian.flatten()\n\n    def assign_quadrature_coordinates(self) -&gt; None:\n        \"\"\"\n        Assigns the actual coordinates of the quadrature points.\n\n        This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n        The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n        The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        actual_co_ord = []\n        for xi, eta in zip(self.quad_xi, self.quad_eta):\n            actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n        self.quad_actual_coordinates = np.array(actual_co_ord)\n\n    def assign_forcing_term(self, forcing_function) -&gt; None:\n        \"\"\"\n        Assigns the forcing function values at the quadrature points.\n\n        This function computes the values of the forcing function at the quadrature points\n        and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n        Args:\n            forcing_function (callable): The forcing function to be integrated\n\n        Returns:\n            None\n\n        Notes:\n            - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n            - This function is for backward compatibility with old code and currently assigns\n              the values as zeros. The actual calculation is performed in the fespace class.\n        \"\"\"\n        # get number of shape functions\n        n_shape_functions = self.basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n        # the actual calculation is performed in the fespace class\n\n        # for i in range(n_shape_functions):\n        #     val = 0\n        #     for q in range(self.basis_at_quad.shape[1]):\n        #         x = self.quad_actual_coordinates[q, 0]\n        #         y = self.quad_actual_coordinates[q, 1]\n        #         # print(\"f_values[q] = \",f_values[q])\n\n        #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n        #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n        #         # print(\"val = \", val)\n\n        #     f_integral[i] = val\n\n        self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.__init__","title":"<code>__init__(cell_coordinates, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, forcing_function)</code>","text":"<p>Constructor for the FE2D_Cell class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> required <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> required <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> required <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> required <code>forcing_function</code> <code>callable</code> <p>Source term function</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def __init__(\n    self,\n    cell_coordinates: np.ndarray,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    forcing_function,\n):\n    \"\"\"\n    Constructor for the FE2D_Cell class.\n\n    Args:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_coordinates = cell_coordinates\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.fe_transformation = fe_transformation_type\n    self.forcing_function = forcing_function\n\n    # Basis function Class\n    self.basis_function = None\n\n    # Quadrature Values\n    self.quad_xi = None\n    self.quad_eta = None\n    self.quad_weight = None\n    self.jacobian = None\n    self.mult = None\n\n    # FE Values\n    self.basis_at_quad = None\n    self.basis_gradx_at_quad = None\n    self.basis_grady_at_quad = None\n    self.basis_gradxy_at_quad = None\n    self.basis_gradxx_at_quad = None\n    self.basis_gradyy_at_quad = None\n\n    # Quadrature Coordinates\n    self.quad_actual_coordinates = None\n\n    # Forcing function values at the quadrature points\n    self.forcing_at_quad = None\n\n    # FE Transformation Class\n    self.fetransformation = None\n\n    # get instance of the FE_setup class\n    self.fe_setup = FE2DSetupMain(\n        cell_type=self.cell_type,\n        fe_order=self.fe_order,\n        fe_type=self.fe_type,\n        quad_order=self.quad_order,\n        quad_type=self.quad_type,\n    )\n\n    # Call the function to assign the basis function\n    self.assign_basis_function()\n\n    # Assign the quadrature points and weights\n    self.assign_quadrature()\n\n    # Assign the FE Transformation\n    self.assign_fe_transformation()\n\n    # calculate mult -&gt; quadrature weights * Jacobian\n    self.assign_quad_weights_and_jacobian()\n\n    # Calculate the basis function values at the quadrature points\n    self.assign_basis_values_at_quadrature_points()\n\n    # calculate the actual coordinates of the quadrature points\n    self.assign_quadrature_coordinates()\n\n    # Calculate the forcing function values at the actual quadrature points\n    # NOTE : The function is just for printing the shape of the force matrix, the\n    # actual calculation is performed on the fespace class\n    self.assign_forcing_term(self.forcing_function)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function class based on the cell type and the FE order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function class for the given cell type and FE order.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function class based on the cell type and the FE order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function class for the given cell type and FE order.\n    \"\"\"\n    self.basis_function = self.fe_setup.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_basis_values_at_quadrature_points","title":"<code>assign_basis_values_at_quadrature_points()</code>","text":"<p>Assigns the basis function values at the quadrature points.</p> <p>This method calculates the values of the basis functions and their gradients at the quadrature points. The basis function values are stored in <code>self.basis_at_quad</code>, while the gradients are stored in <code>self.basis_gradx_at_quad</code>, <code>self.basis_grady_at_quad</code>, <code>self.basis_gradxy_at_quad</code>, <code>self.basis_gradxx_at_quad</code>, and <code>self.basis_gradyy_at_quad</code>.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_values_at_quadrature_points(self) -&gt; None:\n    \"\"\"\n    Assigns the basis function values at the quadrature points.\n\n    This method calculates the values of the basis functions and their gradients at the quadrature points.\n    The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n    `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n    `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.basis_at_quad = []\n    self.basis_gradx_at_quad = []\n    self.basis_grady_at_quad = []\n    self.basis_gradxy_at_quad = []\n    self.basis_gradxx_at_quad = []\n    self.basis_gradyy_at_quad = []\n\n    self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n    # For Gradients we need to perform a transformation to the original cell\n    grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n    grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n    grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n        grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n    )\n\n    self.basis_gradx_at_quad = grad_x_orig\n    self.basis_grady_at_quad = grad_y_orig\n\n    self.basis_gradx_at_quad_ref = grad_x_ref\n    self.basis_grady_at_quad_ref = grad_y_ref\n\n    # get the double derivatives of the basis functions ( ref co-ordinates )\n    grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n    grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n    grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n    # get the double derivatives of the basis functions ( orig co-ordinates )\n    grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n        self.fetransformation.get_orig_from_ref_second_derivative(\n            grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n        )\n    )\n\n    # = the value\n    self.basis_gradxy_at_quad = grad_xy_orig\n    self.basis_gradxx_at_quad = grad_xx_orig\n    self.basis_gradyy_at_quad = grad_yy_orig\n\n    # Multiply each row with the quadrature weights\n    # Basis at Quad - n_test * N_quad\n    self.basis_at_quad = self.basis_at_quad * self.mult\n    self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n    self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n    self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n    self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n    self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_fe_transformation","title":"<code>assign_fe_transformation()</code>","text":"<p>Assigns the FE Transformation class based on the cell type and the FE order.</p> <p>This method assigns the appropriate FE Transformation class based on the cell type and the FE order. It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_fe_transformation(self) -&gt; None:\n    \"\"\"\n    Assigns the FE Transformation class based on the cell type and the FE order.\n\n    This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n    It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.fetransformation = self.fe_setup.assign_fe_transformation(\n        self.fe_transformation, self.cell_coordinates\n    )\n    # Sets cell co-ordinates for the FE Transformation\n    self.fetransformation.set_cell()\n\n    # obtains the Jacobian of the transformation\n    self.jacobian = self.fetransformation.get_jacobian(\n        self.quad_xi, self.quad_eta\n    ).reshape(-1, 1)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_forcing_term","title":"<code>assign_forcing_term(forcing_function)</code>","text":"<p>Assigns the forcing function values at the quadrature points.</p> <p>This function computes the values of the forcing function at the quadrature points and assigns them to the <code>forcing_at_quad</code> attribute of the FE2D_Cell object.</p> <p>Parameters:</p> Name Type Description Default <code>forcing_function</code> <code>callable</code> <p>The forcing function to be integrated</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Notes <ul> <li>The final shape of <code>forcing_at_quad</code> will be N_shape_functions x 1.</li> <li>This function is for backward compatibility with old code and currently assigns   the values as zeros. The actual calculation is performed in the fespace class.</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_forcing_term(self, forcing_function) -&gt; None:\n    \"\"\"\n    Assigns the forcing function values at the quadrature points.\n\n    This function computes the values of the forcing function at the quadrature points\n    and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n    Args:\n        forcing_function (callable): The forcing function to be integrated\n\n    Returns:\n        None\n\n    Notes:\n        - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n        - This function is for backward compatibility with old code and currently assigns\n          the values as zeros. The actual calculation is performed in the fespace class.\n    \"\"\"\n    # get number of shape functions\n    n_shape_functions = self.basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n    # the actual calculation is performed in the fespace class\n\n    # for i in range(n_shape_functions):\n    #     val = 0\n    #     for q in range(self.basis_at_quad.shape[1]):\n    #         x = self.quad_actual_coordinates[q, 0]\n    #         y = self.quad_actual_coordinates[q, 1]\n    #         # print(\"f_values[q] = \",f_values[q])\n\n    #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n    #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n    #         # print(\"val = \", val)\n\n    #     f_integral[i] = val\n\n    self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_quad_weights_and_jacobian","title":"<code>assign_quad_weights_and_jacobian()</code>","text":"<p>Assigns the quadrature weights and the Jacobian of the transformation.</p> <p>This method calculates and assigns the quadrature weights and the Jacobian of the transformation for the current cell. The quadrature weights are multiplied by the flattened Jacobian array and stored in the <code>mult</code> attribute of the class.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quad_weights_and_jacobian(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature weights and the Jacobian of the transformation.\n\n    This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n    for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n    and stored in the `mult` attribute of the class.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.mult = self.quad_weight * self.jacobian.flatten()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_quadrature","title":"<code>assign_quadrature()</code>","text":"<p>Assigns the quadrature points and weights based on the cell type and the quadrature order.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_weight, self.quad_xi, self.quad_eta = (\n        self.fe_setup.assign_quadrature_rules()\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_quadrature_coordinates","title":"<code>assign_quadrature_coordinates()</code>","text":"<p>Assigns the actual coordinates of the quadrature points.</p> <p>This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values. The Xi and Eta values are obtained from the <code>quad_xi</code> and <code>quad_eta</code> attributes of the class. The calculated coordinates are stored in the <code>quad_actual_coordinates</code> attribute as a NumPy array.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature_coordinates(self) -&gt; None:\n    \"\"\"\n    Assigns the actual coordinates of the quadrature points.\n\n    This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n    The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n    The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    actual_co_ord = []\n    for xi, eta in zip(self.quad_xi, self.quad_eta):\n        actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n    self.quad_actual_coordinates = np.array(actual_co_ord)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D","title":"<code>FETransforamtion2D</code>","text":"<p>A base class for 2D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 2D finite element analysis. Implementations must provide specific transformation rules for different element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes.</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes.</p> Example <p>class QuadTransform(FETransformation2D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>class FETransforamtion2D:\n    \"\"\"\n    A base class for 2D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 2D finite element analysis. Implementations must provide specific\n    transformation rules for different element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n\n        get_jacobian(xi, eta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n\n    Example:\n        &gt;&gt;&gt; class QuadTransform(FETransformation2D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n        ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransforamtion2D class.\n        \"\"\"\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        :return: None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransforamtion2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransforamtion2D class.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas","title":"<code>Quadratureformulas</code>","text":"<p>Abstract base class for numerical quadrature formulas.</p> <p>This class defines the interface that all quadrature implementations must follow. It provides the basic structure for implementing various quadrature rules while ensuring consistent access to quadrature data.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of the quadrature rule</p> <code>quad_type</code> <p>Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points</p> Example <p>class MyQuadrature(Quadratureformulas): ...     def init(self): ...         super().init(quad_order=3, ...                         quad_type='custom', ...                         num_quad_points=9) ...     def get_quad_values(self): ...         # Implementation ...         pass ...     def get_num_quad_points(self): ...         return self.num_quad_points</p> Note <p>This is an abstract base class. Concrete implementations must override: - get_quad_values() - get_num_quad_points()</p> <p>The implementation should ensure proper initialization of: - Quadrature points - Quadrature weights - Number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>class Quadratureformulas:\n    \"\"\"Abstract base class for numerical quadrature formulas.\n\n    This class defines the interface that all quadrature implementations must\n    follow. It provides the basic structure for implementing various quadrature\n    rules while ensuring consistent access to quadrature data.\n\n    Attributes:\n        quad_order: Order of the quadrature rule\n        quad_type: Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Example:\n        &gt;&gt;&gt; class MyQuadrature(Quadratureformulas):\n        ...     def __init__(self):\n        ...         super().__init__(quad_order=3,\n        ...                         quad_type='custom',\n        ...                         num_quad_points=9)\n        ...     def get_quad_values(self):\n        ...         # Implementation\n        ...         pass\n        ...     def get_num_quad_points(self):\n        ...         return self.num_quad_points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - get_quad_values()\n        - get_num_quad_points()\n\n        The implementation should ensure proper initialization of:\n        - Quadrature points\n        - Quadrature weights\n        - Number of quadrature points\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n            num_quad_points: Total number of quadrature points\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.num_quad_points = num_quad_points\n\n    @abstractmethod\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            weights: Weights for each quadrature point\n            xi: x-coordinates of quadrature points in reference element\n            eta: y-coordinates of quadrature points in reference element\n        \"\"\"\n\n    @abstractmethod\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            num_quad_points: Total number of quadrature points\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas.__init__","title":"<code>__init__(quad_order, quad_type, num_quad_points)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <code>num_quad_points</code> <code>int</code> <p>Total number of quadrature points</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.num_quad_points = num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas.get_num_quad_points","title":"<code>get_num_quad_points()</code>  <code>abstractmethod</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>num_quad_points</code> <p>Total number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        num_quad_points: Total number of quadrature points\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas.get_quad_values","title":"<code>get_quad_values()</code>  <code>abstractmethod</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>weights</code> <p>Weights for each quadrature point</p> <code>xi</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta</code> <p>y-coordinates of quadrature points in reference element</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        weights: Weights for each quadrature point\n        xi: x-coordinates of quadrature points in reference element\n        eta: y-coordinates of quadrature points in reference element\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D","title":"<code>Quadratureformulas_Quad2D</code>","text":"<p>               Bases: <code>Quadratureformulas</code></p> <p>Implements quadrature formulas for 2D quadrilateral elements.</p> <p>This class provides methods to compute quadrature points and weights for 2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi quadrature schemes. The implementation uses tensor products of 1D rules.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of quadrature rule</p> <code>quad_type</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points (quad_order^2)</p> <code>xi_quad</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta_quad</code> <p>y-coordinates of quadrature points in reference element</p> <code>quad_weights</code> <p>Weights for each quadrature point</p> Example <p>quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre') weights, xi, eta = quad.get_quad_values() n_points = quad.get_num_quad_points()</p> Note <ul> <li>Gauss-Legendre points are optimal for polynomial integrands</li> <li>Gauss-Jacobi points include element vertices (useful for certain FEM applications)</li> <li>All computations are performed in the reference element [-1,1]\u00d7[-1,1]</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>class Quadratureformulas_Quad2D(Quadratureformulas):\n    \"\"\"Implements quadrature formulas for 2D quadrilateral elements.\n\n    This class provides methods to compute quadrature points and weights for\n    2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi\n    quadrature schemes. The implementation uses tensor products of 1D rules.\n\n    Attributes:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points (quad_order^2)\n        xi_quad: x-coordinates of quadrature points in reference element\n        eta_quad: y-coordinates of quadrature points in reference element\n        quad_weights: Weights for each quadrature point\n\n    Example:\n        &gt;&gt;&gt; quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre')\n        &gt;&gt;&gt; weights, xi, eta = quad.get_quad_values()\n        &gt;&gt;&gt; n_points = quad.get_num_quad_points()\n\n    Note:\n        - Gauss-Legendre points are optimal for polynomial integrands\n        - Gauss-Jacobi points include element vertices (useful for certain FEM applications)\n        - All computations are performed in the reference element [-1,1]\u00d7[-1,1]\n\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the quadrature type is not supported.\n        \"\"\"\n        # initialize the super class\n        super().__init__(\n            quad_order=quad_order,\n            quad_type=quad_type,\n            num_quad_points=quad_order * quad_order,\n        )\n\n        # Calculate the Gauss-Legendre quadrature points and weights for 1D\n        # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n        quad_type = self.quad_type\n\n        if quad_type == \"gauss-legendre\":\n            # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n            # if quad_order == 2:\n            #     nodes_1d = np.array([-1, 1])\n            #     weights_1d = np.array([1, 1])\n            # else:\n            nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n                quad_order\n            )  # Interior points\n            # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n            # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        elif quad_type == \"gauss-jacobi\":\n\n            def GaussJacobiWeights(Q: int, a, b):\n                [X, W] = roots_jacobi(Q, a, b)\n                return [X, W]\n\n            def jacobi_wrapper(n, a, b, x):\n\n                x = np.array(x, dtype=np.float64)\n\n                return jacobi(n, a, b)(x)\n\n            # Weight coefficients\n            def GaussLobattoJacobiWeights(Q: int, a, b):\n                W = []\n                X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n                if a == 0 and b == 0:\n                    W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                    Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                    Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n                else:\n                    W = (\n                        2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                        )\n                    )\n                    Wl = (\n                        (b + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                        )\n                    )\n                    Wr = (\n                        (a + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                        )\n                    )\n                W = np.append(W, Wr)\n                W = np.append(Wl, W)\n                X = np.append(X, 1)\n                X = np.append(-1, X)\n                return [X, W]\n\n            # get quadrature points and weights in 1D\n            x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(x, x)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (w[:, np.newaxis] * w).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        else:\n            print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n            print(\n                f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quadrature type not supported.\")\n\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format\n        \"\"\"\n        return self.quad_weights, self.xi_quad, self.eta_quad\n\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            int: The number of quadrature points\n        \"\"\"\n        return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D.__init__","title":"<code>__init__(quad_order, quad_type)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quadrature type is not supported.</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the quadrature type is not supported.\n    \"\"\"\n    # initialize the super class\n    super().__init__(\n        quad_order=quad_order,\n        quad_type=quad_type,\n        num_quad_points=quad_order * quad_order,\n    )\n\n    # Calculate the Gauss-Legendre quadrature points and weights for 1D\n    # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n    quad_type = self.quad_type\n\n    if quad_type == \"gauss-legendre\":\n        # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n        # if quad_order == 2:\n        #     nodes_1d = np.array([-1, 1])\n        #     weights_1d = np.array([1, 1])\n        # else:\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n            quad_order\n        )  # Interior points\n        # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n        # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    elif quad_type == \"gauss-jacobi\":\n\n        def GaussJacobiWeights(Q: int, a, b):\n            [X, W] = roots_jacobi(Q, a, b)\n            return [X, W]\n\n        def jacobi_wrapper(n, a, b, x):\n\n            x = np.array(x, dtype=np.float64)\n\n            return jacobi(n, a, b)(x)\n\n        # Weight coefficients\n        def GaussLobattoJacobiWeights(Q: int, a, b):\n            W = []\n            X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n            if a == 0 and b == 0:\n                W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n            else:\n                W = (\n                    2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                    )\n                )\n                Wl = (\n                    (b + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                    )\n                )\n                Wr = (\n                    (a + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                    )\n                )\n            W = np.append(W, Wr)\n            W = np.append(Wl, W)\n            X = np.append(X, 1)\n            X = np.append(-1, X)\n            return [X, W]\n\n        # get quadrature points and weights in 1D\n        x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(x, x)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (w[:, np.newaxis] * w).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    else:\n        print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n        print(\n            f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Quadrature type not supported.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D.get_num_quad_points","title":"<code>get_num_quad_points()</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of quadrature points\n    \"\"\"\n    return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D.get_quad_values","title":"<code>get_quad_values()</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format\n    \"\"\"\n    return self.quad_weights, self.xi_quad, self.eta_quad\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/","title":"fe2d_setup_main","text":"<p>Module: fe2d_setup_main.py</p> <p>This module provides the main setup and configuration functionality for 2D  finite element analysis, handling basis function assignment, quadrature rules,  and transformations.</p> <p>Classes:</p> Name Description <code>FE2DSetupMain</code> <p>Core class for configuring FE2D computations</p> Dependencies <ul> <li>basis_function_2d: Base classes for 2D basis functions</li> <li>quadratureformulas_quad2d: Quadrature rule implementations</li> <li>fe_transformation_2d: Geometric transformation handlers</li> </ul> Key Features <ul> <li>Flexible basis function selection</li> <li>Multiple polynomial basis options<ul> <li>Legendre polynomials</li> <li>Special Legendre polynomials</li> <li>Chebyshev polynomials</li> <li>Jacobi polynomials</li> </ul> </li> <li>Configurable quadrature rules</li> <li>Support for different element transformations</li> <li>Automatic validation of parameters</li> <li>Element type specific handling</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> Notes <p>Currently supports quadrilateral elements with various polynomial  basis options and transformation types. The implementation focuses  on flexibility and extensibility for different element types.</p>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D","title":"<code>BasisFunction2D</code>","text":"<p>An abstract base class defining the interface for two-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 2D basis functions (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines the required methods for function evaluation and derivatives.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Number of shape functions in the element. Typically a perfect square for tensor-product bases.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates basis functions at given reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of basis functions at (xi, eta)</p> <code>gradx</code> <p>Computes x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of x-derivatives at (xi, eta)</p> <code>grady</code> <p>Computes y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of y-derivatives at (xi, eta)</p> <code>gradxx</code> <p>Computes second x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second x-derivatives at (xi, eta)</p> <code>gradxy</code> <p>Computes mixed derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of mixed derivatives at (xi, eta)</p> <code>gradyy</code> <p>Computes second y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second y-derivatives at (xi, eta)</p> Notes <ul> <li>All coordinate inputs (xi, eta) should be in the reference element range</li> <li>Subclasses must implement all abstract methods</li> <li>Used as base class for specific polynomial implementations:<ul> <li>Legendre polynomials (normal and special variants)</li> <li>Jacobi polynomials</li> <li>Chebyshev polynomials</li> </ul> </li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>class BasisFunction2D:\n    \"\"\"\n    An abstract base class defining the interface for two-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 2D basis functions\n    (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines\n    the required methods for function evaluation and derivatives.\n\n    Attributes:\n        num_shape_functions (int): Number of shape functions in the element.\n            Typically a perfect square for tensor-product bases.\n\n    Methods:\n        value(xi, eta): Evaluates basis functions at given reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of basis functions at (xi, eta)\n\n        gradx(xi, eta): Computes x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of x-derivatives at (xi, eta)\n\n        grady(xi, eta): Computes y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of y-derivatives at (xi, eta)\n\n        gradxx(xi, eta): Computes second x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second x-derivatives at (xi, eta)\n\n        gradxy(xi, eta): Computes mixed derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of mixed derivatives at (xi, eta)\n\n        gradyy(xi, eta): Computes second y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second y-derivatives at (xi, eta)\n\n    Notes:\n        - All coordinate inputs (xi, eta) should be in the reference element range\n        - Subclasses must implement all abstract methods\n        - Used as base class for specific polynomial implementations:\n            - Legendre polynomials (normal and special variants)\n            - Jacobi polynomials\n            - Chebyshev polynomials\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (float): The xi coordinate.\n            eta (float): The eta coordinate.\n\n        Returns:\n            float: The value of the basis function at ( xi, eta).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradx","title":"<code>gradx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradxx","title":"<code>gradxx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradxy","title":"<code>gradxy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.grady","title":"<code>grady(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradyy","title":"<code>gradyy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.value","title":"<code>value(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>float</code> <p>The xi coordinate.</p> required <code>eta</code> <code>float</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>The value of the basis function at ( xi, eta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (float): The xi coordinate.\n        eta (float): The eta coordinate.\n\n    Returns:\n        float: The value of the basis function at ( xi, eta).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain","title":"<code>FE2DSetupMain</code>","text":"<p>Main configuration class for 2D finite element analysis setup.</p> <p>This class handles the configuration and initialization of finite element analysis components, including basis functions, quadrature rules, and geometric transformations.</p> <p>Attributes:</p> Name Type Description <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the element</p> Example <p>setup = FE2DSetupMain( ...     cell_type='quadrilateral', ...     fe_order=2, ...     fe_type='legendre', ...     quad_order=3, ...     quad_type='gauss' ... ) basis = setup.assign_basis_function() weights, xi, eta = setup.assign_quadrature_rules()</p> Notes <ul> <li>Supports only quadrilateral elements currently</li> <li>Validates all input parameters for correctness</li> <li>Provides different polynomial basis options</li> <li>Handles both affine and bilinear transformations</li> <li>Quadrature order must be &gt;= 3 for accuracy</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>class FE2DSetupMain:\n    \"\"\"\n    Main configuration class for 2D finite element analysis setup.\n\n    This class handles the configuration and initialization of finite element\n    analysis components, including basis functions, quadrature rules, and\n    geometric transformations.\n\n    Attributes:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n        n_nodes (int): Number of nodes in the element\n\n    Example:\n        &gt;&gt;&gt; setup = FE2DSetupMain(\n        ...     cell_type='quadrilateral',\n        ...     fe_order=2,\n        ...     fe_type='legendre',\n        ...     quad_order=3,\n        ...     quad_type='gauss'\n        ... )\n        &gt;&gt;&gt; basis = setup.assign_basis_function()\n        &gt;&gt;&gt; weights, xi, eta = setup.assign_quadrature_rules()\n\n    Notes:\n        - Supports only quadrilateral elements currently\n        - Validates all input parameters for correctness\n        - Provides different polynomial basis options\n        - Handles both affine and bilinear transformations\n        - Quadrature order must be &gt;= 3 for accuracy\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n    ):\n        \"\"\"\n        Constructor for the FE2DSetupMain class.\n\n        Args:\n            cell_type (str): Type of finite element ('quadrilateral')\n            fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n            fe_type (str): Type of basis functions\n                ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n            quad_order (int): Order of quadrature rule (&gt;= 2)\n            quad_type (str): Type of quadrature formula\n\n        Raises:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.assign_basis_function()\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function based on the cell type and the fe_order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function object for the given configuration.\n\n        Raises:\n            ValueError: If the fe order is invalid or the cell type is invalid.\n        \"\"\"\n        # check for fe order lower bound and higher bound\n        if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n        if self.cell_type == \"quadrilateral\":\n            self.n_nodes = 4\n\n            # --- LEGENDRE --- #\n            if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n                # jacobi is added for backward compatibility with prev pushes\n                # generally, jacobi is referred to as Legendre basis on previous iterations\n                return Basis2DQNLegendre(self.fe_order**2)\n\n            elif self.fe_type == \"legendre_special\":\n                return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n            # ----- CHEBYSHEV ---- #\n            elif self.fe_type == \"chebyshev_2\":\n                return Basis2DQNChebyshev2(self.fe_order**2)\n\n            # ----- PLain jacobi ---- #\n            elif self.fe_type == \"jacobi_plain\":\n                return Basis2DQNJacobi(self.fe_order**2)\n\n            else:\n                print(\n                    f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\n                    'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n                )\n\n        print(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_quadrature_rules(self):\n        \"\"\"\n        Assigns the quadrature rule based on the quad_order.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n        Raises:\n            ValueError: If the quad_order is invalid\n            ValueError: If the cell type is invalid\n            ValueError: If the quad_order is not between 1 and 9999\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if self.quad_order &lt; 3:\n                raise ValueError(\"Quad order should be greater than 2.\")\n            elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n                weights, xi, eta = Quadratureformulas_Quad2D(\n                    self.quad_order, self.quad_type\n                ).get_quad_values()\n                return weights, xi, eta\n            else:\n                print(\n                    f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_fe_transformation(\n        self, fe_transformation_type: str, cell_coordinates: np.ndarray\n    ) -&gt; FETransforamtion2D:\n        \"\"\"\n        Assigns the fe transformation based on the cell type.\n\n        Args:\n            fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n            cell_coordinates (np.ndarray): The cell coordinates\n\n        Returns:\n            FETransforamtion2D: The fe transformation object for the given configuration.\n\n        Raises:\n            ValueError: If the cell type is invalid\n            ValueError: If the fe transformation type is invalid\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if fe_transformation_type == \"affine\":\n                return QuadAffin(cell_coordinates)\n            elif fe_transformation_type == \"bilinear\":\n                return QuadBilinear(cell_coordinates)\n            else:\n                raise ValueError(\n                    f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n                )\n\n        else:\n            raise ValueError(\n                f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.__init__","title":"<code>__init__(cell_type, fe_order, fe_type, quad_order, quad_type)</code>","text":"<p>Constructor for the FE2DSetupMain class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> required <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> required <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def __init__(\n    self,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n):\n    \"\"\"\n    Constructor for the FE2DSetupMain class.\n\n    Args:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n\n    Raises:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function based on the cell type and the fe_order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the fe order is invalid or the cell type is invalid.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function based on the cell type and the fe_order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function object for the given configuration.\n\n    Raises:\n        ValueError: If the fe order is invalid or the cell type is invalid.\n    \"\"\"\n    # check for fe order lower bound and higher bound\n    if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n        print(\n            f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n    if self.cell_type == \"quadrilateral\":\n        self.n_nodes = 4\n\n        # --- LEGENDRE --- #\n        if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n            # jacobi is added for backward compatibility with prev pushes\n            # generally, jacobi is referred to as Legendre basis on previous iterations\n            return Basis2DQNLegendre(self.fe_order**2)\n\n        elif self.fe_type == \"legendre_special\":\n            return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n        # ----- CHEBYSHEV ---- #\n        elif self.fe_type == \"chebyshev_2\":\n            return Basis2DQNChebyshev2(self.fe_order**2)\n\n        # ----- PLain jacobi ---- #\n        elif self.fe_type == \"jacobi_plain\":\n            return Basis2DQNJacobi(self.fe_order**2)\n\n        else:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n            )\n\n    print(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.assign_fe_transformation","title":"<code>assign_fe_transformation(fe_transformation_type, cell_coordinates)</code>","text":"<p>Assigns the fe transformation based on the cell type.</p> <p>Parameters:</p> Name Type Description Default <code>fe_transformation_type</code> <code>str</code> <p>Type of fe transformation ('affine', 'bilinear')</p> required <code>cell_coordinates</code> <code>ndarray</code> <p>The cell coordinates</p> required <p>Returns:</p> Name Type Description <code>FETransforamtion2D</code> <code>FETransforamtion2D</code> <p>The fe transformation object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the fe transformation type is invalid</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_fe_transformation(\n    self, fe_transformation_type: str, cell_coordinates: np.ndarray\n) -&gt; FETransforamtion2D:\n    \"\"\"\n    Assigns the fe transformation based on the cell type.\n\n    Args:\n        fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n        cell_coordinates (np.ndarray): The cell coordinates\n\n    Returns:\n        FETransforamtion2D: The fe transformation object for the given configuration.\n\n    Raises:\n        ValueError: If the cell type is invalid\n        ValueError: If the fe transformation type is invalid\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if fe_transformation_type == \"affine\":\n            return QuadAffin(cell_coordinates)\n        elif fe_transformation_type == \"bilinear\":\n            return QuadBilinear(cell_coordinates)\n        else:\n            raise ValueError(\n                f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n\n    else:\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.assign_quadrature_rules","title":"<code>assign_quadrature_rules()</code>","text":"<p>Assigns the quadrature rule based on the quad_order.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quad_order is invalid</p> <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the quad_order is not between 1 and 9999</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_quadrature_rules(self):\n    \"\"\"\n    Assigns the quadrature rule based on the quad_order.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n    Raises:\n        ValueError: If the quad_order is invalid\n        ValueError: If the cell type is invalid\n        ValueError: If the quad_order is not between 1 and 9999\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if self.quad_order &lt; 3:\n            raise ValueError(\"Quad order should be greater than 2.\")\n        elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n            weights, xi, eta = Quadratureformulas_Quad2D(\n                self.quad_order, self.quad_type\n            ).get_quad_values()\n            return weights, xi, eta\n        else:\n            print(\n                f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n    raise ValueError(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D","title":"<code>FETransforamtion2D</code>","text":"<p>A base class for 2D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 2D finite element analysis. Implementations must provide specific transformation rules for different element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes.</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes.</p> Example <p>class QuadTransform(FETransformation2D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>class FETransforamtion2D:\n    \"\"\"\n    A base class for 2D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 2D finite element analysis. Implementations must provide specific\n    transformation rules for different element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n\n        get_jacobian(xi, eta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n\n    Example:\n        &gt;&gt;&gt; class QuadTransform(FETransformation2D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n        ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransforamtion2D class.\n        \"\"\"\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        :return: None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransforamtion2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransforamtion2D class.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas","title":"<code>Quadratureformulas</code>","text":"<p>Abstract base class for numerical quadrature formulas.</p> <p>This class defines the interface that all quadrature implementations must follow. It provides the basic structure for implementing various quadrature rules while ensuring consistent access to quadrature data.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of the quadrature rule</p> <code>quad_type</code> <p>Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points</p> Example <p>class MyQuadrature(Quadratureformulas): ...     def init(self): ...         super().init(quad_order=3, ...                         quad_type='custom', ...                         num_quad_points=9) ...     def get_quad_values(self): ...         # Implementation ...         pass ...     def get_num_quad_points(self): ...         return self.num_quad_points</p> Note <p>This is an abstract base class. Concrete implementations must override: - get_quad_values() - get_num_quad_points()</p> <p>The implementation should ensure proper initialization of: - Quadrature points - Quadrature weights - Number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>class Quadratureformulas:\n    \"\"\"Abstract base class for numerical quadrature formulas.\n\n    This class defines the interface that all quadrature implementations must\n    follow. It provides the basic structure for implementing various quadrature\n    rules while ensuring consistent access to quadrature data.\n\n    Attributes:\n        quad_order: Order of the quadrature rule\n        quad_type: Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Example:\n        &gt;&gt;&gt; class MyQuadrature(Quadratureformulas):\n        ...     def __init__(self):\n        ...         super().__init__(quad_order=3,\n        ...                         quad_type='custom',\n        ...                         num_quad_points=9)\n        ...     def get_quad_values(self):\n        ...         # Implementation\n        ...         pass\n        ...     def get_num_quad_points(self):\n        ...         return self.num_quad_points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - get_quad_values()\n        - get_num_quad_points()\n\n        The implementation should ensure proper initialization of:\n        - Quadrature points\n        - Quadrature weights\n        - Number of quadrature points\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n            num_quad_points: Total number of quadrature points\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.num_quad_points = num_quad_points\n\n    @abstractmethod\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            weights: Weights for each quadrature point\n            xi: x-coordinates of quadrature points in reference element\n            eta: y-coordinates of quadrature points in reference element\n        \"\"\"\n\n    @abstractmethod\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            num_quad_points: Total number of quadrature points\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas.__init__","title":"<code>__init__(quad_order, quad_type, num_quad_points)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <code>num_quad_points</code> <code>int</code> <p>Total number of quadrature points</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.num_quad_points = num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas.get_num_quad_points","title":"<code>get_num_quad_points()</code>  <code>abstractmethod</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>num_quad_points</code> <p>Total number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        num_quad_points: Total number of quadrature points\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas.get_quad_values","title":"<code>get_quad_values()</code>  <code>abstractmethod</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>weights</code> <p>Weights for each quadrature point</p> <code>xi</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta</code> <p>y-coordinates of quadrature points in reference element</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        weights: Weights for each quadrature point\n        xi: x-coordinates of quadrature points in reference element\n        eta: y-coordinates of quadrature points in reference element\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D","title":"<code>Quadratureformulas_Quad2D</code>","text":"<p>               Bases: <code>Quadratureformulas</code></p> <p>Implements quadrature formulas for 2D quadrilateral elements.</p> <p>This class provides methods to compute quadrature points and weights for 2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi quadrature schemes. The implementation uses tensor products of 1D rules.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of quadrature rule</p> <code>quad_type</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points (quad_order^2)</p> <code>xi_quad</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta_quad</code> <p>y-coordinates of quadrature points in reference element</p> <code>quad_weights</code> <p>Weights for each quadrature point</p> Example <p>quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre') weights, xi, eta = quad.get_quad_values() n_points = quad.get_num_quad_points()</p> Note <ul> <li>Gauss-Legendre points are optimal for polynomial integrands</li> <li>Gauss-Jacobi points include element vertices (useful for certain FEM applications)</li> <li>All computations are performed in the reference element [-1,1]\u00d7[-1,1]</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>class Quadratureformulas_Quad2D(Quadratureformulas):\n    \"\"\"Implements quadrature formulas for 2D quadrilateral elements.\n\n    This class provides methods to compute quadrature points and weights for\n    2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi\n    quadrature schemes. The implementation uses tensor products of 1D rules.\n\n    Attributes:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points (quad_order^2)\n        xi_quad: x-coordinates of quadrature points in reference element\n        eta_quad: y-coordinates of quadrature points in reference element\n        quad_weights: Weights for each quadrature point\n\n    Example:\n        &gt;&gt;&gt; quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre')\n        &gt;&gt;&gt; weights, xi, eta = quad.get_quad_values()\n        &gt;&gt;&gt; n_points = quad.get_num_quad_points()\n\n    Note:\n        - Gauss-Legendre points are optimal for polynomial integrands\n        - Gauss-Jacobi points include element vertices (useful for certain FEM applications)\n        - All computations are performed in the reference element [-1,1]\u00d7[-1,1]\n\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the quadrature type is not supported.\n        \"\"\"\n        # initialize the super class\n        super().__init__(\n            quad_order=quad_order,\n            quad_type=quad_type,\n            num_quad_points=quad_order * quad_order,\n        )\n\n        # Calculate the Gauss-Legendre quadrature points and weights for 1D\n        # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n        quad_type = self.quad_type\n\n        if quad_type == \"gauss-legendre\":\n            # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n            # if quad_order == 2:\n            #     nodes_1d = np.array([-1, 1])\n            #     weights_1d = np.array([1, 1])\n            # else:\n            nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n                quad_order\n            )  # Interior points\n            # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n            # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        elif quad_type == \"gauss-jacobi\":\n\n            def GaussJacobiWeights(Q: int, a, b):\n                [X, W] = roots_jacobi(Q, a, b)\n                return [X, W]\n\n            def jacobi_wrapper(n, a, b, x):\n\n                x = np.array(x, dtype=np.float64)\n\n                return jacobi(n, a, b)(x)\n\n            # Weight coefficients\n            def GaussLobattoJacobiWeights(Q: int, a, b):\n                W = []\n                X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n                if a == 0 and b == 0:\n                    W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                    Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                    Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n                else:\n                    W = (\n                        2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                        )\n                    )\n                    Wl = (\n                        (b + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                        )\n                    )\n                    Wr = (\n                        (a + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                        )\n                    )\n                W = np.append(W, Wr)\n                W = np.append(Wl, W)\n                X = np.append(X, 1)\n                X = np.append(-1, X)\n                return [X, W]\n\n            # get quadrature points and weights in 1D\n            x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(x, x)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (w[:, np.newaxis] * w).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        else:\n            print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n            print(\n                f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quadrature type not supported.\")\n\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format\n        \"\"\"\n        return self.quad_weights, self.xi_quad, self.eta_quad\n\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            int: The number of quadrature points\n        \"\"\"\n        return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D.__init__","title":"<code>__init__(quad_order, quad_type)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quadrature type is not supported.</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the quadrature type is not supported.\n    \"\"\"\n    # initialize the super class\n    super().__init__(\n        quad_order=quad_order,\n        quad_type=quad_type,\n        num_quad_points=quad_order * quad_order,\n    )\n\n    # Calculate the Gauss-Legendre quadrature points and weights for 1D\n    # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n    quad_type = self.quad_type\n\n    if quad_type == \"gauss-legendre\":\n        # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n        # if quad_order == 2:\n        #     nodes_1d = np.array([-1, 1])\n        #     weights_1d = np.array([1, 1])\n        # else:\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n            quad_order\n        )  # Interior points\n        # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n        # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    elif quad_type == \"gauss-jacobi\":\n\n        def GaussJacobiWeights(Q: int, a, b):\n            [X, W] = roots_jacobi(Q, a, b)\n            return [X, W]\n\n        def jacobi_wrapper(n, a, b, x):\n\n            x = np.array(x, dtype=np.float64)\n\n            return jacobi(n, a, b)(x)\n\n        # Weight coefficients\n        def GaussLobattoJacobiWeights(Q: int, a, b):\n            W = []\n            X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n            if a == 0 and b == 0:\n                W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n            else:\n                W = (\n                    2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                    )\n                )\n                Wl = (\n                    (b + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                    )\n                )\n                Wr = (\n                    (a + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                    )\n                )\n            W = np.append(W, Wr)\n            W = np.append(Wl, W)\n            X = np.append(X, 1)\n            X = np.append(-1, X)\n            return [X, W]\n\n        # get quadrature points and weights in 1D\n        x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(x, x)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (w[:, np.newaxis] * w).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    else:\n        print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n        print(\n            f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Quadrature type not supported.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D.get_num_quad_points","title":"<code>get_num_quad_points()</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of quadrature points\n    \"\"\"\n    return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D.get_quad_values","title":"<code>get_quad_values()</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format\n    \"\"\"\n    return self.quad_weights, self.xi_quad, self.eta_quad\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/","title":"FE_transformation_2d","text":"<p>Module: fe_transformation_2d.py</p> <p>This module provides the abstract base class for all 2D finite element transformations.  It defines the interface for mapping between reference and physical coordinates in  two-dimensional finite element analysis.</p> <p>Classes:</p> Name Description <code>FETransformation2D</code> <p>Abstract base class for 2D finite element transformations</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> <li>quad_affine: For affine transformation implementations</li> <li>quad_bilinear: For bilinear transformation implementations</li> </ul> Key Features <ul> <li>Abstract interface for coordinate transformations</li> <li>Reference to physical domain mapping</li> <li>Jacobian matrix computation</li> <li>Support for different element geometries</li> <li>Cell geometry specification interface</li> <li>Systematic transformation validation</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D","title":"<code>FETransforamtion2D</code>","text":"<p>A base class for 2D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 2D finite element analysis. Implementations must provide specific transformation rules for different element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes.</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes.</p> Example <p>class QuadTransform(FETransformation2D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>class FETransforamtion2D:\n    \"\"\"\n    A base class for 2D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 2D finite element analysis. Implementations must provide specific\n    transformation rules for different element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n\n        get_jacobian(xi, eta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n\n    Example:\n        &gt;&gt;&gt; class QuadTransform(FETransformation2D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n        ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransforamtion2D class.\n        \"\"\"\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        :return: None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransforamtion2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransforamtion2D class.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/","title":"FE_transformation_3d","text":"<p>Module: fe_transformation_3d.py</p> <p>This module provides the abstract base class for all 3D finite element transformations. It defines the interface for mapping between reference and physical coordinates in  three-dimensional finite element analysis.</p> <p>Classes:</p> Name Description <code>FETransformation3D</code> <p>Abstract base class for 3D finite element transformations</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Abstract interface for 3D coordinate transformations</li> <li>Reference to physical domain mapping</li> <li>3D Jacobian matrix computation</li> <li>Support for different 3D element geometries</li> <li>Cell geometry specification interface</li> <li>Systematic transformation validation</li> <li>Three-dimensional coordinate mapping (xi, eta, zeta)</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D","title":"<code>FETransforamtion3D</code>","text":"<p>A base class for 3D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 3D finite element analysis. Implementations must provide specific transformation rules for different three-dimensional element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes. Args: xi, eta, zeta - Reference coordinates Returns: (x, y, z) physical coordinates</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes. Args: xi, eta, zeta - Reference coordinates Returns: determinant of the Jacobian at all the quadrature points</p> Example <p>class HexTransform(FETransformation3D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi, eta, zeta): ...         # Implementation for hexahedral element ...         pass ...     def get_jacobian(self, xi, eta, zeta): ...         # Implementation for hexahedral element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> <li>Coordinate order is consistently (xi, eta, zeta) -&gt; (x, y, z)</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>class FETransforamtion3D:  # pragma: no cover\n    \"\"\"\n    A base class for 3D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 3D finite element analysis. Implementations must provide specific\n    transformation rules for different three-dimensional element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta, zeta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n            Args: xi, eta, zeta - Reference coordinates\n            Returns: (x, y, z) physical coordinates\n\n        get_jacobian(xi, eta, zeta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n            Args: xi, eta, zeta - Reference coordinates\n            Returns: determinant of the Jacobian at all the quadrature points\n\n    Example:\n        &gt;&gt;&gt; class HexTransform(FETransformation3D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi, eta, zeta):\n        ...         # Implementation for hexahedral element\n        ...         pass\n        ...     def get_jacobian(self, xi, eta, zeta):\n        ...         # Implementation for hexahedral element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n        - Coordinate order is consistently (xi, eta, zeta) -&gt; (x, y, z)\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransformation3D class.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell co-ordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(\n        self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(\n        self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original co-ordinates from the reference co-ordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original co-ordinates from the reference co-ordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(\n        self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransformation3D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransformation3D class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.get_jacobian","title":"<code>get_jacobian(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(\n    self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original co-ordinates from the reference co-ordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original co-ordinates from the reference co-ordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(\n    self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original co-ordinates from the reference co-ordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original co-ordinates from the reference co-ordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell co-ordinates, which will be used to calculate the Jacobian and actual values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell co-ordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/","title":"fespace","text":"<p>Module: fespace.py</p> <p>This module provides abstract base functionality for finite element space  implementations, defining core interfaces for fe computations and analysis.</p> <p>Classes:</p> Name Description <code>Fespace</code> <p>Abstract base class for finite element space implementations</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Mesh handling and cell management</li> <li>Shape function evaluation and manipulation</li> <li>Boundary condition implementation<ul> <li>Dirichlet boundary handling</li> <li>Boundary function management</li> </ul> </li> <li>Quadrature point management</li> <li>Forcing function integration</li> <li>Sensor data handling for inverse problems</li> <li>Reference and physical space transformations</li> <li>Gradient computation in both spaces</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> Notes <p>This module serves as the foundation for specific finite element space implementations. It defines the minimum interface required for fe computations while allowing flexibility in concrete implementations.</p>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace","title":"<code>Fespace</code>","text":"<p>Abstract base class defining the interface for finite element spaces.</p> <p>This class provides the foundation for implementing finite element spaces, including mesh handling, element operations, and solution computations.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <p>Mesh object containing geometric information</p> <code>cells</code> <code>ndarray</code> <p>Array of cell indices</p> <code>boundary_points</code> <code>dict</code> <p>Dictionary of boundary point information</p> <code>cell_type</code> <code>str</code> <p>Type of finite element cell</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> <code>bound_function_dict</code> <code>dict</code> <p>Dictionary of boundary condition functions</p> <code>bound_condition_dict</code> <code>dict</code> <p>Dictionary of boundary condition types</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>output_path</code> <code>str</code> <p>Path for output files</p> Example <p>class MyFespace(Fespace): ...     def set_finite_elements(self): ...         # Implementation ...         pass ...     def generate_dirichlet_boundary_data(self): ...         # Implementation ...         pass ...     # Implement other abstract methods</p> Notes <ul> <li>All coordinate transformations must be implemented</li> <li>Shape function values and gradients are available in both reference and physical spaces</li> <li>Supports both internal and external sensor data for inverse problems</li> <li>Boundary conditions must be properly specified through the boundary dictionaries</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>class Fespace:\n    \"\"\"\n    Abstract base class defining the interface for finite element spaces.\n\n    This class provides the foundation for implementing finite element spaces,\n    including mesh handling, element operations, and solution computations.\n\n    Attributes:\n        mesh: Mesh object containing geometric information\n        cells (ndarray): Array of cell indices\n        boundary_points (dict): Dictionary of boundary point information\n        cell_type (str): Type of finite element cell\n        fe_order (int): Order of finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        bound_function_dict (dict): Dictionary of boundary condition functions\n        bound_condition_dict (dict): Dictionary of boundary condition types\n        forcing_function (callable): Source term function\n        output_path (str): Path for output files\n\n    Example:\n        &gt;&gt;&gt; class MyFespace(Fespace):\n        ...     def set_finite_elements(self):\n        ...         # Implementation\n        ...         pass\n        ...     def generate_dirichlet_boundary_data(self):\n        ...         # Implementation\n        ...         pass\n        ...     # Implement other abstract methods\n\n    Notes:\n        - All coordinate transformations must be implemented\n        - Shape function values and gradients are available in both\n        reference and physical spaces\n        - Supports both internal and external sensor data for\n        inverse problems\n        - Boundary conditions must be properly specified through\n        the boundary dictionaries\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n\n        Args:\n            mesh: The mesh object.\n            cells: The cells of the mesh.\n            boundary_points: The boundary points of the mesh.\n            cell_type: The type of the cell.\n            fe_order: The order of the finite element.\n            fe_type: The type of the finite element.\n            quad_order: The order of the quadrature.\n            quad_type: The type of the quadrature.\n            fe_transformation_type: The type of the finite element transformation.\n            bound_function_dict: The dictionary of the boundary functions.\n            bound_condition_dict: The dictionary of the boundary conditions.\n            forcing_function: The forcing function.\n            output_path: The path to the output directory.\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh = mesh\n        self.boundary_points = boundary_points\n        self.cells = cells\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.fe_transformation_type = fe_transformation_type\n        self.output_path = output_path\n        self.bound_function_dict = bound_function_dict\n        self.bound_condition_dict = bound_condition_dict\n        self.forcing_function = forcing_function\n\n    @abstractmethod\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data.\n\n        This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            np.ndarray: The boundary points and their values.\n\n        Notes:\n            The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual values of the shape functions.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n\n    @abstractmethod\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n            object.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        Args:\n            exact_solution (ndarray): The exact solution values.\n            num_points (int): The number of points to sample from the domain.\n\n        Returns:\n            np.ndarray: The sensor data at the given points.\n\n        Notes:\n            This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n            Methodologies to obtain sensor data for problems from a file are not implemented yet.\n            It is also not implemented for external or complex meshes.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data_external(\n        self, exact_sol, num_points: int, file_name: str\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n        Args:\n            exact_sol: The exact solution values.\n            num_points: The number of points to sample from the domain.\n            file_name: The name of the file containing the sensor data.\n\n        Returns:\n            np.ndarray: The sensor data at the given points based on the external file.\n\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path)</code>","text":"<p>The constructor of the Fespace2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <p>The mesh object.</p> required <code>cells</code> <p>The cells of the mesh.</p> required <code>boundary_points</code> <p>The boundary points of the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell.</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element.</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature.</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation.</p> required <code>bound_function_dict</code> <code>dict</code> <p>The dictionary of the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>The dictionary of the boundary conditions.</p> required <code>forcing_function</code> <p>The forcing function.</p> required <code>output_path</code> <code>str</code> <p>The path to the output directory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n\n    Args:\n        mesh: The mesh object.\n        cells: The cells of the mesh.\n        boundary_points: The boundary points of the mesh.\n        cell_type: The type of the cell.\n        fe_order: The order of the finite element.\n        fe_type: The type of the finite element.\n        quad_order: The order of the quadrature.\n        quad_type: The type of the quadrature.\n        fe_transformation_type: The type of the finite element transformation.\n        bound_function_dict: The dictionary of the boundary functions.\n        bound_condition_dict: The dictionary of the boundary conditions.\n        forcing_function: The forcing function.\n        output_path: The path to the output directory.\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh = mesh\n    self.boundary_points = boundary_points\n    self.cells = cells\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.fe_transformation_type = fe_transformation_type\n    self.output_path = output_path\n    self.bound_function_dict = bound_function_dict\n    self.bound_condition_dict = bound_condition_dict\n    self.forcing_function = forcing_function\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>  <code>abstractmethod</code>","text":"<p>Generate Dirichlet boundary data.</p> <p>This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The boundary points and their values.</p> Notes <p>The boundary points and values are stored in the <code>boundary_points</code> attribute of the <code>Fespace</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data.\n\n    This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        np.ndarray: The boundary points and their values.\n\n    Notes:\n        The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object. The forcing function is evaluated using the <code>forcing_function</code> method of the <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n        object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>  <code>abstractmethod</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>ndarray</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points.</p> Notes <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    Args:\n        exact_solution (ndarray): The exact solution values.\n        num_points (int): The number of points to sample from the domain.\n\n    Returns:\n        np.ndarray: The sensor data at the given points.\n\n    Notes:\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>  <code>abstractmethod</code>","text":"<p>This method is used to obtain the sensor data from an external file when there is no analytical solution available.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points based on the external file.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data_external(\n    self, exact_sol, num_points: int, file_name: str\n) -&gt; np.ndarray:\n    \"\"\"\n    This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n    Args:\n        exact_sol: The exact solution values.\n        num_points: The number of points to sample from the domain.\n        file_name: The name of the file containing the sensor data.\n\n    Returns:\n        np.ndarray: The sensor data at the given points based on the external file.\n\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to y.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual values of the shape functions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual values of the shape functions.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.set_finite_elements","title":"<code>set_finite_elements()</code>  <code>abstractmethod</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/","title":"fespace2d","text":"<p>Finite Element Space Implementation for 2D Problems.</p> <p>This module implements finite element space functionality for 2D domains, providing a framework for handling mesh elements, boundary conditions, and numerical integration.</p> Key classes <ul> <li>Fespace2D: Main class for managing 2D finite element spaces</li> <li>FE2D_Cell: Implementation of individual finite element cells</li> </ul> Key functionalities <ul> <li>Finite element space construction and management</li> <li>Boundary condition handling (Dirichlet)</li> <li>Shape function and gradient computations</li> <li>Quadrature point and weight management</li> <li>Forcing function evaluation</li> <li>Sensor data generation for inverse problems</li> </ul> The implementation supports <ul> <li>Various element types (currently focused on quadrilateral elements)</li> <li>Different orders of finite elements</li> <li>Custom quadrature rules</li> <li>Multiple boundary conditions</li> <li>Forcing function integration</li> <li>Mesh visualization</li> </ul> Note <p>Triangle mesh support is currently not implemented.</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>meshio: For mesh handling</li> <li>matplotlib: For visualization</li> <li>tensorflow: For optimization tasks</li> <li>pyDOE: For Latin Hypercube Sampling</li> <li>pandas: For data handling</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D","title":"<code>Fespace2D</code>","text":"<p>               Bases: <code>Fespace</code></p> <p>Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces, including mesh generation, basis function evaluation, and boundary condition handling.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh object containing the mesh information.</p> required <code>cells</code> <code>ndarray</code> <p>The cell information from the mesh.</p> required <code>boundary_points</code> <code>dict</code> <p>The boundary points information from the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell (e.g., 'quadrilateral').</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element basis functions.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element basis functions (e.g., 'legendre').</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature rule.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature rule (e.g., 'gauss-legendre').</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation (e.g., 'affine').</p> required <code>bound_function_dict</code> <code>dict</code> <p>A dictionary containing the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>A dictionary containing the boundary conditions.</p> required <code>forcing_function</code> <code>function</code> <p>The forcing function for the problem.</p> required <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <code>generate_mesh_plot</code> <code>bool</code> <p>Flag to generate the mesh plot (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is not supported.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>class Fespace2D(Fespace):\n    \"\"\"\n    Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces,\n    including mesh generation, basis function evaluation, and boundary condition handling.\n\n    Args:\n        mesh (meshio.Mesh): The mesh object containing the mesh information.\n        cells (np.ndarray): The cell information from the mesh.\n        boundary_points (dict): The boundary points information from the mesh.\n        cell_type (str): The type of the cell (e.g., 'quadrilateral').\n        fe_order (int): The order of the finite element basis functions.\n        fe_type (str): The type of the finite element basis functions (e.g., 'legendre').\n        quad_order (int): The order of the quadrature rule.\n        quad_type (str): The type of the quadrature rule (e.g., 'gauss-legendre').\n        fe_transformation_type (str): The type of the finite element transformation (e.g., 'affine').\n        bound_function_dict (dict): A dictionary containing the boundary functions.\n        bound_condition_dict (dict): A dictionary containing the boundary conditions.\n        forcing_function (function): The forcing function for the problem.\n        output_path (str): The path to save the output files.\n        generate_mesh_plot (bool): Flag to generate the mesh plot (default: False).\n\n    Raises:\n        ValueError: If the cell type is not supported.\n\n    Returns:\n        None\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n        generate_mesh_plot: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n        \"\"\"\n        # call the constructor of the parent class\n        super().__init__(\n            mesh=mesh,\n            cells=cells,\n            boundary_points=boundary_points,\n            cell_type=cell_type,\n            fe_order=fe_order,\n            fe_type=fe_type,\n            quad_order=quad_order,\n            quad_type=quad_type,\n            fe_transformation_type=fe_transformation_type,\n            bound_function_dict=bound_function_dict,\n            bound_condition_dict=bound_condition_dict,\n            forcing_function=forcing_function,\n            output_path=output_path,\n        )\n\n        if self.cell_type == \"triangle\":\n            raise ValueError(\n                \"Triangle Mesh is not supported yet\"\n            )  # added by thivin - to remove support for triangular mesh\n\n        self.generate_mesh_plot = generate_mesh_plot\n\n        # to be calculated in the plot function\n        self.total_dofs = 0\n        self.total_boundary_dofs = 0\n\n        # to be calculated on get_boundary_data_dirichlet function\n        self.total_dirichlet_dofs = 0\n\n        # get the number of cells\n        self.n_cells = self.cells.shape[0]\n\n        self.fe_cell = []\n\n        # Function which assigns the fe_cell for each cell\n        self.set_finite_elements()\n\n        # generate the plot of the mesh\n        if self.generate_mesh_plot:\n            self.generate_plot(self.output_path)\n        # self.generate_plot(self.output_path)\n\n        # Obtain boundary Data\n        self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n        title = [\n            \"Number of Cells\",\n            \"Number of Quadrature Points\",\n            \"Number of Dirichlet Boundary Points\",\n            \"Quadrature Order\",\n            \"fe Order\",\n            \"fe Type\",\n            \"fe Transformation Type\",\n        ]\n        values = [\n            self.n_cells,\n            self.total_dofs,\n            self.total_dirichlet_dofs,\n            self.quad_order,\n            self.fe_order,\n            self.fe_type,\n            self.fe_transformation_type,\n        ]\n        # print the table\n        print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        :return: None\n        \"\"\"\n        progress_bar = tqdm(\n            total=self.n_cells,\n            desc=\"Fe2D_cell Setup\",\n            unit=\"cells_assembled\",\n            bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n            colour=\"blue\",\n            ncols=100,\n        )\n\n        dof = 0\n        for i in range(self.n_cells):\n            self.fe_cell.append(\n                FE2D_Cell(\n                    self.cells[i],\n                    self.cell_type,\n                    self.fe_order,\n                    self.fe_type,\n                    self.quad_order,\n                    self.quad_type,\n                    self.fe_transformation_type,\n                    self.forcing_function,\n                )\n            )\n\n            # obtain the shape of the basis function (n_test, N_quad)\n            dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n            progress_bar.update(1)\n        # print the Shape details of all the matrices from cell 0 using print_table function\n        title = [\n            \"Shape function Matrix Shape\",\n            \"Shape function Gradient Matrix Shape\",\n            \"Jacobian Matrix Shape\",\n            \"Quadrature Points Shape\",\n            \"Quadrature Weights Shape\",\n            \"Quadrature Actual Coordinates Shape\",\n            \"Forcing Function Shape\",\n        ]\n        values = [\n            self.fe_cell[0].basis_at_quad.shape,\n            self.fe_cell[0].basis_gradx_at_quad.shape,\n            self.fe_cell[0].jacobian.shape,\n            self.fe_cell[0].quad_xi.shape,\n            self.fe_cell[0].quad_weight.shape,\n            self.fe_cell[0].quad_actual_coordinates.shape,\n            self.fe_cell[0].forcing_at_quad.shape,\n        ]\n        print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n        # update the total number of dofs\n        self.total_dofs = dof\n\n    def generate_plot(self, output_path) -&gt; None:\n        \"\"\"\n        Generate a plot of the mesh.\n\n        Args:\n            output_path (str): The path to save the output files.\n\n        Returns:\n            None\n        \"\"\"\n        total_quad = 0\n        marker_list = [\n            \"o\",\n            \".\",\n            \",\",\n            \"x\",\n            \"+\",\n            \"P\",\n            \"s\",\n            \"D\",\n            \"d\",\n            \"^\",\n            \"v\",\n            \"&lt;\",\n            \"&gt;\",\n            \"p\",\n            \"h\",\n            \"H\",\n        ]\n\n        print(f\"[INFO] : Generating the plot of the mesh\")\n        # Plot the mesh\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # label flag ( to add the label only once)\n        label_set = False\n\n        # plot every cell as a quadrilateral\n        # loop over all the cells\n        for i in range(self.n_cells):\n            # get the coordinates of the cell\n            x = self.fe_cell[i].cell_coordinates[:, 0]\n            y = self.fe_cell[i].cell_coordinates[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            plt.plot(x, y, \"k-\", linewidth=0.5)\n\n            # plot the quadrature points\n            x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n            y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n            total_quad += x_quad.shape[0]\n\n            if not label_set:\n                plt.scatter(\n                    x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n                )\n                label_set = True\n            else:\n                plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n        self.total_dofs = total_quad\n\n        bound_dof = 0\n        # plot the boundary points\n        # loop over all the boundary tags\n        for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n            # get the coordinates of the boundary points\n            x = bound_pts[:, 0]\n            y = bound_pts[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            bound_dof += x.shape[0]\n\n            plt.scatter(\n                x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n            )\n\n        self.total_boundary_dofs = bound_dof\n\n        plt.legend(bbox_to_anchor=(0.85, 1.02))\n        plt.axis(\"equal\")\n        plt.axis(\"off\")\n        plt.tight_layout()\n\n        plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n        plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n        # print the total number of quadrature points\n        print(f\"Plots generated\")\n        print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n        print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n        print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n                ).reshape(-1, 1)\n                y.append(val)\n\n        print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n        self.total_dirichlet_dofs = len(x)\n        print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n        print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n        return x, y\n\n    def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n        \"\"\"\n        Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n        Args:\n            component (int): The component of the boundary data vector.\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                    dtype=np.float64,\n                ).reshape(-1, 1)\n                y.append(val)\n\n        return x, y\n\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_at_quad.copy()\n\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n\n    def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Return the quadrature weights for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n        Returns:\n            np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n        Raises:\n            ValueError: If cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].mult.copy()\n\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n        # so that it can be used to handle multiple dimensions on a vector valud problem\n\n        # get number of shape functions\n        n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        for i in range(n_shape_functions):\n            val = 0\n            for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n                x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n                y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n                # print(\"f_values[q] = \",f_values[q])\n\n                # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n                val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                    cell_index\n                ].forcing_function(x, y)\n                # print(\"val = \", val)\n\n            f_integral[i] = val\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_forcing_function_values_vector(\n        self, cell_index: int, component: int\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This function will return the forcing function values at the quadrature points\n        based on the Component of the RHS Needed, for vector valued problems\n\n        Args:\n            cell_index (int): The index of the cell.\n            component (int): The component of the forcing function.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # get the coordinates\n        x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n        y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n        # compute the forcing function values\n        f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n        # compute the integral\n        f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_sensor_data(self, exact_solution, num_points: int):\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n        Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n\n        Args:\n            exact_solution (function): The exact solution function.\n            num_points (int): The number of points to sample.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n        \"\"\"\n        # generate random points within the bounds of the domain\n        # get the bounds of the domain\n        x_min = np.min(self.mesh.points[:, 0])\n        x_max = np.max(self.mesh.points[:, 0])\n        y_min = np.min(self.mesh.points[:, 1])\n        y_max = np.max(self.mesh.points[:, 1])\n        # sample n random points within the bounds of the domain\n        # Generate points in the unit square\n\n        num_internal_points = int(num_points * 0.9)\n\n        points = lhs(2, samples=num_internal_points)\n        points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n        points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n        # get the exact solution at the points\n        exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n        # print the shape of the points and the exact solution\n        print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n        print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n        # plot the points\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n        plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n        plt.axis(\"equal\")\n        plt.title(\"Sensor Points\")\n        plt.tight_layout()\n        plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n        return points, exact_sol\n\n    def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n        \"\"\"\n        This method is used to obtain the sensor data from an external file.\n\n        Args:\n            exact_sol (function): The exact solution function.\n            num_points (int): The number of points to sample.\n            file_name (str): The name of the file containing the sensor data.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n        Note:\n            This method reads the sensor data from a file and samples `num_points` from the data.\n            The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n        \"\"\"\n        # use pandas to read the file\n        df = pd.read_csv(file_name)\n\n        x = df.iloc[:, 0].values\n        y = df.iloc[:, 1].values\n        exact_sol = df.iloc[:, 2].values\n\n        # now sample num_points from the data\n        indices = np.random.randint(0, x.shape[0], num_points)\n\n        x = x[indices]\n        y = y[indices]\n        exact_sol = exact_sol[indices]\n\n        # stack them together\n        points = np.stack((x, y), axis=1)\n\n        return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path, generate_mesh_plot=False)</code>","text":"<p>The constructor of the Fespace2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n    generate_mesh_plot: bool = False,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n    \"\"\"\n    # call the constructor of the parent class\n    super().__init__(\n        mesh=mesh,\n        cells=cells,\n        boundary_points=boundary_points,\n        cell_type=cell_type,\n        fe_order=fe_order,\n        fe_type=fe_type,\n        quad_order=quad_order,\n        quad_type=quad_type,\n        fe_transformation_type=fe_transformation_type,\n        bound_function_dict=bound_function_dict,\n        bound_condition_dict=bound_condition_dict,\n        forcing_function=forcing_function,\n        output_path=output_path,\n    )\n\n    if self.cell_type == \"triangle\":\n        raise ValueError(\n            \"Triangle Mesh is not supported yet\"\n        )  # added by thivin - to remove support for triangular mesh\n\n    self.generate_mesh_plot = generate_mesh_plot\n\n    # to be calculated in the plot function\n    self.total_dofs = 0\n    self.total_boundary_dofs = 0\n\n    # to be calculated on get_boundary_data_dirichlet function\n    self.total_dirichlet_dofs = 0\n\n    # get the number of cells\n    self.n_cells = self.cells.shape[0]\n\n    self.fe_cell = []\n\n    # Function which assigns the fe_cell for each cell\n    self.set_finite_elements()\n\n    # generate the plot of the mesh\n    if self.generate_mesh_plot:\n        self.generate_plot(self.output_path)\n    # self.generate_plot(self.output_path)\n\n    # Obtain boundary Data\n    self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n    title = [\n        \"Number of Cells\",\n        \"Number of Quadrature Points\",\n        \"Number of Dirichlet Boundary Points\",\n        \"Quadrature Order\",\n        \"fe Order\",\n        \"fe Type\",\n        \"fe Transformation Type\",\n    ]\n    values = [\n        self.n_cells,\n        self.total_dofs,\n        self.total_dirichlet_dofs,\n        self.quad_order,\n        self.fe_order,\n        self.fe_type,\n        self.fe_transformation_type,\n    ]\n    # print the table\n    print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>","text":"<p>Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n            ).reshape(-1, 1)\n            y.append(val)\n\n    print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n    self.total_dirichlet_dofs = len(x)\n    print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n    print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.generate_dirichlet_boundary_data_vector","title":"<code>generate_dirichlet_boundary_data_vector(component)</code>","text":"<p>Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>int</code> <p>The component of the boundary data vector.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n    \"\"\"\n    Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n    Args:\n        component (int): The component of the boundary data vector.\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                dtype=np.float64,\n            ).reshape(-1, 1)\n            y.append(val)\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.generate_plot","title":"<code>generate_plot(output_path)</code>","text":"<p>Generate a plot of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_plot(self, output_path) -&gt; None:\n    \"\"\"\n    Generate a plot of the mesh.\n\n    Args:\n        output_path (str): The path to save the output files.\n\n    Returns:\n        None\n    \"\"\"\n    total_quad = 0\n    marker_list = [\n        \"o\",\n        \".\",\n        \",\",\n        \"x\",\n        \"+\",\n        \"P\",\n        \"s\",\n        \"D\",\n        \"d\",\n        \"^\",\n        \"v\",\n        \"&lt;\",\n        \"&gt;\",\n        \"p\",\n        \"h\",\n        \"H\",\n    ]\n\n    print(f\"[INFO] : Generating the plot of the mesh\")\n    # Plot the mesh\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # label flag ( to add the label only once)\n    label_set = False\n\n    # plot every cell as a quadrilateral\n    # loop over all the cells\n    for i in range(self.n_cells):\n        # get the coordinates of the cell\n        x = self.fe_cell[i].cell_coordinates[:, 0]\n        y = self.fe_cell[i].cell_coordinates[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        plt.plot(x, y, \"k-\", linewidth=0.5)\n\n        # plot the quadrature points\n        x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n        y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n        total_quad += x_quad.shape[0]\n\n        if not label_set:\n            plt.scatter(\n                x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n            )\n            label_set = True\n        else:\n            plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n    self.total_dofs = total_quad\n\n    bound_dof = 0\n    # plot the boundary points\n    # loop over all the boundary tags\n    for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n        # get the coordinates of the boundary points\n        x = bound_pts[:, 0]\n        y = bound_pts[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        bound_dof += x.shape[0]\n\n        plt.scatter(\n            x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n        )\n\n    self.total_boundary_dofs = bound_dof\n\n    plt.legend(bbox_to_anchor=(0.85, 1.02))\n    plt.axis(\"equal\")\n    plt.axis(\"off\")\n    plt.tight_layout()\n\n    plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n    plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n    # print the total number of quadrature points\n    print(f\"Plots generated\")\n    print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n    print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n    print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n    # so that it can be used to handle multiple dimensions on a vector valud problem\n\n    # get number of shape functions\n    n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    for i in range(n_shape_functions):\n        val = 0\n        for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n            x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n            y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n            # print(\"f_values[q] = \",f_values[q])\n\n            # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n            val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                cell_index\n            ].forcing_function(x, y)\n            # print(\"val = \", val)\n\n        f_integral[i] = val\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_forcing_function_values_vector","title":"<code>get_forcing_function_values_vector(cell_index, component)</code>","text":"<p>This function will return the forcing function values at the quadrature points based on the Component of the RHS Needed, for vector valued problems</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <code>component</code> <code>int</code> <p>The component of the forcing function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values_vector(\n    self, cell_index: int, component: int\n) -&gt; np.ndarray:\n    \"\"\"\n    This function will return the forcing function values at the quadrature points\n    based on the Component of the RHS Needed, for vector valued problems\n\n    Args:\n        cell_index (int): The index of the cell.\n        component (int): The component of the forcing function.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # get the coordinates\n    x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n    y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n    # compute the forcing function values\n    f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n    # compute the integral\n    f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_quadrature_weights","title":"<code>get_quadrature_weights(cell_index)</code>","text":"<p>Return the quadrature weights for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell for which the quadrature weights are needed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Return the quadrature weights for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n    Returns:\n        np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n    Raises:\n        ValueError: If cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].mult.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data(self, exact_solution, num_points: int):\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n    Currently, it only works for problems with an analytical solution.\n    Methodologies to obtain sensor data for problems from a file are not implemented yet.\n    It is also not implemented for external or complex meshes.\n\n    Args:\n        exact_solution (function): The exact solution function.\n        num_points (int): The number of points to sample.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n    \"\"\"\n    # generate random points within the bounds of the domain\n    # get the bounds of the domain\n    x_min = np.min(self.mesh.points[:, 0])\n    x_max = np.max(self.mesh.points[:, 0])\n    y_min = np.min(self.mesh.points[:, 1])\n    y_max = np.max(self.mesh.points[:, 1])\n    # sample n random points within the bounds of the domain\n    # Generate points in the unit square\n\n    num_internal_points = int(num_points * 0.9)\n\n    points = lhs(2, samples=num_internal_points)\n    points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n    points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n    # get the exact solution at the points\n    exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n    # print the shape of the points and the exact solution\n    print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n    print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n    # plot the points\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n    plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n    plt.axis(\"equal\")\n    plt.title(\"Sensor Points\")\n    plt.tight_layout()\n    plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>","text":"<p>This method is used to obtain the sensor data from an external file.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Note <p>This method reads the sensor data from a file and samples <code>num_points</code> from the data. The sensor data is then returned as a tuple containing the sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n    \"\"\"\n    This method is used to obtain the sensor data from an external file.\n\n    Args:\n        exact_sol (function): The exact solution function.\n        num_points (int): The number of points to sample.\n        file_name (str): The name of the file containing the sensor data.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n    Note:\n        This method reads the sensor data from a file and samples `num_points` from the data.\n        The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n    \"\"\"\n    # use pandas to read the file\n    df = pd.read_csv(file_name)\n\n    x = df.iloc[:, 0].values\n    y = df.iloc[:, 1].values\n    exact_sol = df.iloc[:, 2].values\n\n    # now sample num_points from the data\n    indices = np.random.randint(0, x.shape[0], num_points)\n\n    x = x[indices]\n    y = y[indices]\n    exact_sol = exact_sol[indices]\n\n    # stack them together\n    points = np.stack((x, y), axis=1)\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.set_finite_elements","title":"<code>set_finite_elements()</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    :return: None\n    \"\"\"\n    progress_bar = tqdm(\n        total=self.n_cells,\n        desc=\"Fe2D_cell Setup\",\n        unit=\"cells_assembled\",\n        bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n        colour=\"blue\",\n        ncols=100,\n    )\n\n    dof = 0\n    for i in range(self.n_cells):\n        self.fe_cell.append(\n            FE2D_Cell(\n                self.cells[i],\n                self.cell_type,\n                self.fe_order,\n                self.fe_type,\n                self.quad_order,\n                self.quad_type,\n                self.fe_transformation_type,\n                self.forcing_function,\n            )\n        )\n\n        # obtain the shape of the basis function (n_test, N_quad)\n        dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n        progress_bar.update(1)\n    # print the Shape details of all the matrices from cell 0 using print_table function\n    title = [\n        \"Shape function Matrix Shape\",\n        \"Shape function Gradient Matrix Shape\",\n        \"Jacobian Matrix Shape\",\n        \"Quadrature Points Shape\",\n        \"Quadrature Weights Shape\",\n        \"Quadrature Actual Coordinates Shape\",\n        \"Forcing Function Shape\",\n    ]\n    values = [\n        self.fe_cell[0].basis_at_quad.shape,\n        self.fe_cell[0].basis_gradx_at_quad.shape,\n        self.fe_cell[0].jacobian.shape,\n        self.fe_cell[0].quad_xi.shape,\n        self.fe_cell[0].quad_weight.shape,\n        self.fe_cell[0].quad_actual_coordinates.shape,\n        self.fe_cell[0].forcing_at_quad.shape,\n    ]\n    print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n    # update the total number of dofs\n    self.total_dofs = dof\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/","title":"quad_affine","text":"<p>Implementation of Affine Transformation for Quadrilateral Elements.</p> <p>This module provides functionality for affine transformations of quadrilateral elements in finite element analysis. It implements mapping between reference and physical elements based on the ParMooN project's methodology.</p> Key functionalities <ul> <li>Reference to physical coordinate mapping</li> <li>Jacobian computation</li> <li>First-order derivatives transformation</li> <li>Second-order derivatives transformation</li> </ul> <p>The implementation follows standard finite element mapping techniques with focus on quadrilateral elements. The transformations maintain geometric consistency and numerical accuracy required for FEM computations.</p> Key classes <ul> <li>QuadAffin: Main class implementing affine transformation for quads</li> </ul> Note <p>This implementation is specifically referenced from ParMooN project's QuadAffine.C file with adaptations for Python and SciREX framework.</p> References <p>[1] ParMooN Project: ParMooN/FiniteElement/QuadAffine.C</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/","title":"quad_bilinear","text":"<p>Implementation of Bilinear Transformation for Quadrilateral Elements.</p> <p>This module provides functionality for bilinear transformations of quadrilateral  elements in finite element analysis. It implements mapping between reference and  physical elements based on the ParMooN project's methodology.</p> Key functionalities <ul> <li>Reference to physical coordinate mapping using bilinear transformation</li> <li>Jacobian computation for bilinear elements</li> <li>First-order derivatives transformation</li> <li>Limited second-order derivatives transformation</li> </ul> <p>The implementation allows for more general quadrilateral elements compared to affine transformations, by using bilinear mapping functions. This enables handling of non-parallelogram quadrilateral elements while maintaining  geometric consistency.</p> Key classes <ul> <li>QuadBilinear: Main class implementing bilinear transformation for quads</li> </ul> Note <p>Second derivative calculations are currently not fully implemented. This implementation is specifically referenced from ParMooN project's QuadBilineare.C file with adaptations for Python and SciREX framework.</p> References <p>[1] ParMooN Project: ParMooN/FiniteElement/QuadBilinear.C</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/","title":"quadratureformulas","text":"<p>Abstract Base Class for Numerical Quadrature Formulas.</p> <p>This module provides the base interface for implementing various numerical  quadrature schemes. It defines the common structure and required methods  that all quadrature implementations must follow.</p> Key functionalities <ul> <li>Abstract interface for quadrature rule implementations</li> <li>Standard methods for accessing quadrature points and weights</li> <li>Flexible framework for different element types and dimensions</li> </ul> The module serves as a foundation for <ul> <li>Multiple quadrature rule implementations</li> <li>Different element type integrations</li> <li>Various quadrature orders and types</li> <li>Custom quadrature scheme implementations</li> </ul> Key classes <ul> <li>Quadratureformulas: Abstract base class for all quadrature implementations</li> </ul> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas","title":"<code>Quadratureformulas</code>","text":"<p>Abstract base class for numerical quadrature formulas.</p> <p>This class defines the interface that all quadrature implementations must follow. It provides the basic structure for implementing various quadrature rules while ensuring consistent access to quadrature data.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of the quadrature rule</p> <code>quad_type</code> <p>Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points</p> Example <p>class MyQuadrature(Quadratureformulas): ...     def init(self): ...         super().init(quad_order=3, ...                         quad_type='custom', ...                         num_quad_points=9) ...     def get_quad_values(self): ...         # Implementation ...         pass ...     def get_num_quad_points(self): ...         return self.num_quad_points</p> Note <p>This is an abstract base class. Concrete implementations must override: - get_quad_values() - get_num_quad_points()</p> <p>The implementation should ensure proper initialization of: - Quadrature points - Quadrature weights - Number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>class Quadratureformulas:\n    \"\"\"Abstract base class for numerical quadrature formulas.\n\n    This class defines the interface that all quadrature implementations must\n    follow. It provides the basic structure for implementing various quadrature\n    rules while ensuring consistent access to quadrature data.\n\n    Attributes:\n        quad_order: Order of the quadrature rule\n        quad_type: Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Example:\n        &gt;&gt;&gt; class MyQuadrature(Quadratureformulas):\n        ...     def __init__(self):\n        ...         super().__init__(quad_order=3,\n        ...                         quad_type='custom',\n        ...                         num_quad_points=9)\n        ...     def get_quad_values(self):\n        ...         # Implementation\n        ...         pass\n        ...     def get_num_quad_points(self):\n        ...         return self.num_quad_points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - get_quad_values()\n        - get_num_quad_points()\n\n        The implementation should ensure proper initialization of:\n        - Quadrature points\n        - Quadrature weights\n        - Number of quadrature points\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n            num_quad_points: Total number of quadrature points\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.num_quad_points = num_quad_points\n\n    @abstractmethod\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            weights: Weights for each quadrature point\n            xi: x-coordinates of quadrature points in reference element\n            eta: y-coordinates of quadrature points in reference element\n        \"\"\"\n\n    @abstractmethod\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            num_quad_points: Total number of quadrature points\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas.__init__","title":"<code>__init__(quad_order, quad_type, num_quad_points)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <code>num_quad_points</code> <code>int</code> <p>Total number of quadrature points</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.num_quad_points = num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas.get_num_quad_points","title":"<code>get_num_quad_points()</code>  <code>abstractmethod</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>num_quad_points</code> <p>Total number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        num_quad_points: Total number of quadrature points\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas.get_quad_values","title":"<code>get_quad_values()</code>  <code>abstractmethod</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>weights</code> <p>Weights for each quadrature point</p> <code>xi</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta</code> <p>y-coordinates of quadrature points in reference element</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        weights: Weights for each quadrature point\n        xi: x-coordinates of quadrature points in reference element\n        eta: y-coordinates of quadrature points in reference element\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/","title":"quadratureformulas_quad2d","text":"<p>Quadrature Formula Implementation for 2D Quadrilateral Elements.</p> <p>This module implements numerical integration formulas for 2D quadrilateral elements, providing both Gauss-Legendre and Gauss-Jacobi quadrature schemes. The implementation focuses on accurate numerical integration required for finite element computations.</p> Key functionalities <ul> <li>Gauss-Legendre quadrature for quadrilateral elements</li> <li>Gauss-Jacobi quadrature with Lobatto points</li> <li>Tensor product based 2D quadrature point generation</li> <li>Weight computation for various quadrature orders</li> </ul> The implementation provides <ul> <li>Flexible quadrature order selection</li> <li>Multiple quadrature schemes</li> <li>Efficient tensor product based computations</li> <li>Automated weight and point generation</li> </ul> Key classes <ul> <li>Quadratureformulas_Quad2D: Main class for 2D quadrature computations</li> </ul> Dependencies <ul> <li>numpy: For numerical computations</li> <li>scipy.special: For special function evaluations (roots, weights)</li> <li>scipy.special.orthogonal: For orthogonal polynomial computations</li> </ul> Note <p>The implementation assumes tensor-product based quadrature rules for 2D elements. Specialized non-tensor product rules are not included.</p> References <p>[1] Karniadakis, G., &amp; Sherwin, S. (2013). Spectral/hp Element      Methods for Computational Fluid Dynamics. Oxford University Press.</p> <p>[2] Kharazmi - hp-VPINNs github repository</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D","title":"<code>Quadratureformulas_Quad2D</code>","text":"<p>               Bases: <code>Quadratureformulas</code></p> <p>Implements quadrature formulas for 2D quadrilateral elements.</p> <p>This class provides methods to compute quadrature points and weights for 2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi quadrature schemes. The implementation uses tensor products of 1D rules.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of quadrature rule</p> <code>quad_type</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points (quad_order^2)</p> <code>xi_quad</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta_quad</code> <p>y-coordinates of quadrature points in reference element</p> <code>quad_weights</code> <p>Weights for each quadrature point</p> Example <p>quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre') weights, xi, eta = quad.get_quad_values() n_points = quad.get_num_quad_points()</p> Note <ul> <li>Gauss-Legendre points are optimal for polynomial integrands</li> <li>Gauss-Jacobi points include element vertices (useful for certain FEM applications)</li> <li>All computations are performed in the reference element [-1,1]\u00d7[-1,1]</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>class Quadratureformulas_Quad2D(Quadratureformulas):\n    \"\"\"Implements quadrature formulas for 2D quadrilateral elements.\n\n    This class provides methods to compute quadrature points and weights for\n    2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi\n    quadrature schemes. The implementation uses tensor products of 1D rules.\n\n    Attributes:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points (quad_order^2)\n        xi_quad: x-coordinates of quadrature points in reference element\n        eta_quad: y-coordinates of quadrature points in reference element\n        quad_weights: Weights for each quadrature point\n\n    Example:\n        &gt;&gt;&gt; quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre')\n        &gt;&gt;&gt; weights, xi, eta = quad.get_quad_values()\n        &gt;&gt;&gt; n_points = quad.get_num_quad_points()\n\n    Note:\n        - Gauss-Legendre points are optimal for polynomial integrands\n        - Gauss-Jacobi points include element vertices (useful for certain FEM applications)\n        - All computations are performed in the reference element [-1,1]\u00d7[-1,1]\n\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the quadrature type is not supported.\n        \"\"\"\n        # initialize the super class\n        super().__init__(\n            quad_order=quad_order,\n            quad_type=quad_type,\n            num_quad_points=quad_order * quad_order,\n        )\n\n        # Calculate the Gauss-Legendre quadrature points and weights for 1D\n        # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n        quad_type = self.quad_type\n\n        if quad_type == \"gauss-legendre\":\n            # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n            # if quad_order == 2:\n            #     nodes_1d = np.array([-1, 1])\n            #     weights_1d = np.array([1, 1])\n            # else:\n            nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n                quad_order\n            )  # Interior points\n            # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n            # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        elif quad_type == \"gauss-jacobi\":\n\n            def GaussJacobiWeights(Q: int, a, b):\n                [X, W] = roots_jacobi(Q, a, b)\n                return [X, W]\n\n            def jacobi_wrapper(n, a, b, x):\n\n                x = np.array(x, dtype=np.float64)\n\n                return jacobi(n, a, b)(x)\n\n            # Weight coefficients\n            def GaussLobattoJacobiWeights(Q: int, a, b):\n                W = []\n                X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n                if a == 0 and b == 0:\n                    W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                    Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                    Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n                else:\n                    W = (\n                        2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                        )\n                    )\n                    Wl = (\n                        (b + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                        )\n                    )\n                    Wr = (\n                        (a + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                        )\n                    )\n                W = np.append(W, Wr)\n                W = np.append(Wl, W)\n                X = np.append(X, 1)\n                X = np.append(-1, X)\n                return [X, W]\n\n            # get quadrature points and weights in 1D\n            x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(x, x)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (w[:, np.newaxis] * w).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        else:\n            print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n            print(\n                f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quadrature type not supported.\")\n\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format\n        \"\"\"\n        return self.quad_weights, self.xi_quad, self.eta_quad\n\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            int: The number of quadrature points\n        \"\"\"\n        return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D.__init__","title":"<code>__init__(quad_order, quad_type)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quadrature type is not supported.</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the quadrature type is not supported.\n    \"\"\"\n    # initialize the super class\n    super().__init__(\n        quad_order=quad_order,\n        quad_type=quad_type,\n        num_quad_points=quad_order * quad_order,\n    )\n\n    # Calculate the Gauss-Legendre quadrature points and weights for 1D\n    # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n    quad_type = self.quad_type\n\n    if quad_type == \"gauss-legendre\":\n        # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n        # if quad_order == 2:\n        #     nodes_1d = np.array([-1, 1])\n        #     weights_1d = np.array([1, 1])\n        # else:\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n            quad_order\n        )  # Interior points\n        # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n        # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    elif quad_type == \"gauss-jacobi\":\n\n        def GaussJacobiWeights(Q: int, a, b):\n            [X, W] = roots_jacobi(Q, a, b)\n            return [X, W]\n\n        def jacobi_wrapper(n, a, b, x):\n\n            x = np.array(x, dtype=np.float64)\n\n            return jacobi(n, a, b)(x)\n\n        # Weight coefficients\n        def GaussLobattoJacobiWeights(Q: int, a, b):\n            W = []\n            X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n            if a == 0 and b == 0:\n                W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n            else:\n                W = (\n                    2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                    )\n                )\n                Wl = (\n                    (b + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                    )\n                )\n                Wr = (\n                    (a + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                    )\n                )\n            W = np.append(W, Wr)\n            W = np.append(Wl, W)\n            X = np.append(X, 1)\n            X = np.append(-1, X)\n            return [X, W]\n\n        # get quadrature points and weights in 1D\n        x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(x, x)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (w[:, np.newaxis] * w).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    else:\n        print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n        print(\n            f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Quadrature type not supported.\")\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D.get_num_quad_points","title":"<code>get_num_quad_points()</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of quadrature points\n    \"\"\"\n    return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D.get_quad_values","title":"<code>get_quad_values()</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format\n    \"\"\"\n    return self.quad_weights, self.xi_quad, self.eta_quad\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/","title":"geometry","text":"<p>Abstract Base Interface for Geometry and Mesh Operations.</p> <p>This module provides the base interface for implementing geometry and mesh handling capabilities in both 2D and 3D. It defines the essential structure for mesh operations including reading, generation, and manipulation.</p> Key functionalities <ul> <li>Abstract interface for mesh reading operations</li> <li>Common mesh generation method definitions</li> <li>VTK file generation specifications</li> <li>Test point extraction framework</li> <li>Mesh type and generation method standardization</li> </ul> The module serves as a foundation for <ul> <li>Both 2D and 3D mesh implementations</li> <li>Various element type support</li> <li>Multiple mesh generation approaches</li> <li>Consistent mesh handling interface</li> </ul> Key classes <ul> <li>Geometry: Abstract base class for all geometry implementations</li> </ul> Dependencies <ul> <li>numpy: For numerical operations</li> <li>meshio: For mesh input/output operations</li> <li>gmsh: For mesh generation capabilities</li> <li>matplotlib: For visualization</li> <li>pyDOE: For sampling methods</li> <li>abc: For abstract base class functionality</li> </ul> Note <p>This module provides only the interface definitions. Concrete implementations must be provided by derived classes for specific dimensional and element type requirements.</p>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry","title":"<code>Geometry</code>","text":"<p>Abstract base class for geometry and mesh operations.</p> <p>This class defines the interface that all geometry implementations must follow, providing the basic structure for mesh handling operations in both 2D and 3D contexts.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> <code>mesh_generation_method</code> <p>Method for mesh generation ('internal'/'external')</p> Example <p>class Geometry2D(Geometry): ...     def init(self, mesh_type='quadrilateral', ...                  method='internal'): ...         super().init(mesh_type, method) ... ...     def read_mesh(self, mesh_file, boundary_level, ...                   sampling_method, refine_level): ...         # Implementation ...         pass ... ...     def generate_vtk_for_test(self): ...         # Implementation ...         pass ... ...     def get_test_points(self): ...         # Implementation ...         return points</p> Note <p>This is an abstract base class. Concrete implementations must override: - read_mesh() - generate_vtk_for_test() - get_test_points()</p> <p>Each implementation should provide appropriate mesh handling for its specific dimensional and element type requirements.</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>class Geometry:\n    \"\"\"Abstract base class for geometry and mesh operations.\n\n    This class defines the interface that all geometry implementations must\n    follow, providing the basic structure for mesh handling operations in\n    both 2D and 3D contexts.\n\n    Attributes:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Example:\n        &gt;&gt;&gt; class Geometry2D(Geometry):\n        ...     def __init__(self, mesh_type='quadrilateral',\n        ...                  method='internal'):\n        ...         super().__init__(mesh_type, method)\n        ...\n        ...     def read_mesh(self, mesh_file, boundary_level,\n        ...                   sampling_method, refine_level):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def generate_vtk_for_test(self):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def get_test_points(self):\n        ...         # Implementation\n        ...         return points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - read_mesh()\n        - generate_vtk_for_test()\n        - get_test_points()\n\n        Each implementation should provide appropriate mesh handling for its\n        specific dimensional and element type requirements.\n    \"\"\"\n\n    def __init__(self, mesh_type: str, mesh_generation_method: str):\n        \"\"\"\n        Constructor for the Geometry class.\n\n        Args:\n            mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n            mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n\n    @abstractmethod\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n        Args:\n            mesh_file (str): Path to the mesh file\n            boundary_point_refinement_level (int): Level of refinement for boundary points\n            bd_sampling_method (str): Sampling method for boundary points\n            refinement_level (int): Level of mesh refinement\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n        None\n\n        Returns:\n        None\n        \"\"\"\n\n    @abstractmethod\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            points (np.ndarray): Test points extracted from the mesh\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.__init__","title":"<code>__init__(mesh_type, mesh_generation_method)</code>","text":"<p>Constructor for the Geometry class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method for mesh generation ('internal'/'external')</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>def __init__(self, mesh_type: str, mesh_generation_method: str):\n    \"\"\"\n    Constructor for the Geometry class.\n\n    Args:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>  <code>abstractmethod</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Args: None</p> <p>Returns: None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n    None\n\n    Returns:\n    None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.get_test_points","title":"<code>get_test_points()</code>  <code>abstractmethod</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Test points extracted from the mesh</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        points (np.ndarray): Test points extracted from the mesh\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of refinement for boundary points</p> required <code>bd_sampling_method</code> <code>str</code> <p>Sampling method for boundary points</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n    Args:\n        mesh_file (str): Path to the mesh file\n        boundary_point_refinement_level (int): Level of refinement for boundary points\n        bd_sampling_method (str): Sampling method for boundary points\n        refinement_level (int): Level of mesh refinement\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/","title":"geometry_2d","text":"<p>Two-Dimensional Geometry and Mesh Management Implementation.</p> <p>This module provides functionality for handling 2D geometries and meshes, including both internal mesh generation and external mesh reading capabilities. It supports quadrilateral elements and various mesh manipulation operations.</p> Key functionalities <ul> <li>Internal mesh generation for rectangular domains</li> <li>External mesh reading from Gmsh format</li> <li>Boundary point generation and refinement</li> <li>VTK file generation and manipulation</li> <li>Mesh visualization and plotting</li> <li>Adaptive mesh refinement support</li> </ul> The module provides <ul> <li>Flexible mesh generation options</li> <li>Boundary point sampling methods (uniform/LHS)</li> <li>Test point generation</li> <li>Solution visualization tools</li> <li>Mesh quality assessment</li> </ul> Key classes <ul> <li>Geometry_2D: Main class for 2D geometry and mesh operations</li> </ul> Dependencies <ul> <li>numpy: For numerical computations</li> <li>meshio: For mesh I/O operations</li> <li>gmsh: For mesh generation</li> <li>matplotlib: For visualization</li> <li>pyDOE: For Latin Hypercube Sampling</li> </ul> Note <p>Currently supports quadrilateral elements only. The implementation focuses on both structured and unstructured mesh handling with emphasis on finite element applications.</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D","title":"<code>Geometry_2D</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>Implements 2D geometry and mesh handling capabilities.</p> <p>This class provides comprehensive functionality for managing 2D meshes, including both internal generation and external mesh reading. It supports various mesh operations, boundary handling, and visualization capabilities.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements ('quadrilateral')</p> <code>mesh_generation_method</code> <p>Method of mesh generation ('internal'/'external')</p> <code>n_test_points_x</code> <p>Number of test points in x-direction</p> <code>n_test_points_y</code> <p>Number of test points in y-direction</p> <code>output_folder</code> <p>Path for output files</p> <code>is_optimized</code> <p>Flag for mesh optimization</p> <code>n_cells_x</code> <p>Number of cells in x-direction (internal mesh)</p> <code>n_cells_y</code> <p>Number of cells in y-direction (internal mesh)</p> <code>x_limits</code> <p>Domain limits in x-direction</p> <code>y_limits</code> <p>Domain limits in y-direction</p> <code>mesh_file_name</code> <p>Name of external mesh file</p> <code>mesh</code> <p>MeshIO mesh object</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <code>cell_points</code> <p>Array of cell vertices</p> <code>test_points</code> <p>Array of test points</p> Example <p>geometry = Geometry_2D( ...     mesh_type='quadrilateral', ...     mesh_generation_method='internal', ...     n_test_points_x=10, ...     n_test_points_y=10, ...     output_folder='./output' ... ) cells, bounds = geometry.generate_quad_mesh_internal( ...     x_limits=(0,1), ...     y_limits=(0,1), ...     n_cells_x=5, ...     n_cells_y=5, ...     num_boundary_points=40 ... )</p> Note <ul> <li>Only supports quadrilateral elements</li> <li>Internal mesh generation is limited to rectangular domains</li> <li>External mesh reading requires Gmsh format</li> <li>Boundary points can be sampled uniformly or using LHS</li> </ul> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>class Geometry_2D(Geometry):\n    \"\"\"Implements 2D geometry and mesh handling capabilities.\n\n    This class provides comprehensive functionality for managing 2D meshes,\n    including both internal generation and external mesh reading. It supports\n    various mesh operations, boundary handling, and visualization capabilities.\n\n    Attributes:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n        n_cells_x: Number of cells in x-direction (internal mesh)\n        n_cells_y: Number of cells in y-direction (internal mesh)\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        mesh_file_name: Name of external mesh file\n        mesh: MeshIO mesh object\n        bd_dict: Dictionary of boundary points\n        cell_points: Array of cell vertices\n        test_points: Array of test points\n\n    Example:\n        &gt;&gt;&gt; geometry = Geometry_2D(\n        ...     mesh_type='quadrilateral',\n        ...     mesh_generation_method='internal',\n        ...     n_test_points_x=10,\n        ...     n_test_points_y=10,\n        ...     output_folder='./output'\n        ... )\n        &gt;&gt;&gt; cells, bounds = geometry.generate_quad_mesh_internal(\n        ...     x_limits=(0,1),\n        ...     y_limits=(0,1),\n        ...     n_cells_x=5,\n        ...     n_cells_y=5,\n        ...     num_boundary_points=40\n        ... )\n\n    Note:\n        - Only supports quadrilateral elements\n        - Internal mesh generation is limited to rectangular domains\n        - External mesh reading requires Gmsh format\n        - Boundary points can be sampled uniformly or using LHS\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh_type: str,\n        mesh_generation_method: str,\n        n_test_points_x: int,\n        n_test_points_y: int,\n        output_folder: str,\n        is_optimized: bool = False,\n    ):\n        \"\"\"\n        Constructor for Geometry_2D class.\n\n        Args:\n            mesh_type: Type of mesh elements ('quadrilateral')\n            mesh_generation_method: Method of mesh generation ('internal'/'external')\n            n_test_points_x: Number of test points in x-direction\n            n_test_points_y: Number of test points in y-direction\n            output_folder: Path for output files\n            is_optimized: Flag for mesh optimization\n\n        Raises:\n            ValueError: If mesh type or generation method is invalid\n\n        Returns:\n            None\n        \"\"\"\n        # Call the super class constructor\n        super().__init__(mesh_type, mesh_generation_method)\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n        self.n_test_points_x = n_test_points_x\n        self.n_test_points_y = n_test_points_y\n        self.output_folder = output_folder\n        self.is_optimized = is_optimized\n\n        if self.mesh_generation_method not in [\"internal\", \"external\"]:\n            print(\n                f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                \"Mesh generation method should be either internal or external.\"\n            )\n\n        if self.mesh_type not in [\"quadrilateral\"]:\n            print(\n                f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n        # To be filled - only when mesh is internal\n        self.n_cells_x = None\n        self.n_cells_y = None\n        self.x_limits = None\n        self.y_limits = None\n\n        # to be filled by external\n        self.mesh_file_name = None\n        self.mesh = None\n        self.bd_dict = None\n        self.cell_points = None\n        self.test_points = None\n\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Reads mesh from a Gmsh .msh file and extracts cell information.\n\n        Args:\n            mesh_file: Path to the mesh file\n            boundary_point_refinement_level: Level of boundary point refinement\n            bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n            refinement_level: Level of mesh refinement\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n\n        Raises:\n            ValueError: If mesh file format is invalid\n        \"\"\"\n\n        self.mesh_file_name = mesh_file\n\n        # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n        file_extension = Path(mesh_file).suffix\n\n        if file_extension != \".mesh\":\n            raise ValueError(\"Mesh file should be in .mesh format.\")\n\n        # Read mesh using meshio\n        self.mesh = meshio.read(mesh_file)\n\n        if self.mesh_type == \"quadrilateral\":\n            # Extract cell information\n            cells = self.mesh.cells_dict[\"quad\"]\n\n        num_cells = cells.shape[0]\n        print(f\"[INFO] : Number of cells = {num_cells}\")\n        cell_points = self.mesh.points[cells][\n            :, :, 0:2\n        ]  # remove the z coordinate, which is 0 for all points\n\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(num_cells):\n            cell = cell_points[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cell_points[i] = cell[np.argsort(angles)]\n\n        # Extract number of points within each cell\n        print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n        # Collect the Boundary point id's within the domain\n        boundary_edges = self.mesh.cells_dict[\"line\"]\n\n        # Using the point id, collect the coordinates of the boundary points\n        boundary_coordinates = self.mesh.points[boundary_edges]\n\n        # Number of Existing Boundary points\n        print(\n            f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n        )\n\n        # now Get the physical tag of the boundary edges\n        boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n        # Generate a Dictionary of boundary tags and boundary coordinates\n        # Keys will be the boundary tags and values will be the list of coordinates\n        boundary_dict = {}\n\n        # refine the boundary points based on the number of boundary points needed\n        for i in range(boundary_coordinates.shape[0]):\n            p1 = boundary_coordinates[i, 0, :]\n            p2 = boundary_coordinates[i, 1, :]\n\n            if bd_sampling_method == \"uniform\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = np.linspace(\n                    p1, p2, pow(2, boundary_point_refinement_level) + 1\n                )\n            elif bd_sampling_method == \"lhs\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n                new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n                new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n            else:\n                print(\n                    f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n            # get the boundary tag\n            tag = boundary_tags[i]\n\n            if tag not in boundary_dict:\n                boundary_dict[tag] = new_points\n            else:\n                current_val = new_points\n                prev_val = boundary_dict[tag]\n                final = np.vstack([prev_val, current_val])\n                boundary_dict[tag] = final\n\n        # get unique\n        for tag in boundary_dict.keys():\n            val = boundary_dict[tag]\n            val = np.unique(val, axis=0)\n            boundary_dict[tag] = val\n\n        self.bd_dict = boundary_dict\n        # print the new boundary points  on each boundary tag (key) in a tabular format\n\n        total_bound_points = 0\n        print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n        print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n        for k, v in self.bd_dict.items():\n            print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n            total_bound_points += v.shape[0]\n\n        print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n        # Assign to class values\n        self.cell_points = cell_points\n\n        # generate testvtk\n        self.generate_vtk_for_test()\n\n        return cell_points, self.bd_dict\n\n    def generate_quad_mesh_internal(\n        self,\n        x_limits: tuple,\n        y_limits: tuple,\n        n_cells_x: int,\n        n_cells_y: int,\n        num_boundary_points: int,\n    ):\n        \"\"\"\n        Generate and save a quadrilateral mesh with physical curves.\n\n        Args:\n            x_limits: Domain limits in x-direction\n            y_limits: Domain limits in y-direction\n            n_cells_x: Number of cells in x-direction\n            n_cells_y: Number of cells in y-direction\n            num_boundary_points: Number of boundary points\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n        \"\"\"\n\n        self.n_cells_x = n_cells_x\n        self.n_cells_y = n_cells_y\n        self.x_limits = x_limits\n        self.y_limits = y_limits\n\n        # generate linspace of points in x and y direction\n        x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n        y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n        # Generate quad cells from the points\n        # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n        cells = []\n\n        for i in range(n_cells_x):\n            for j in range(n_cells_y):\n                # get the four points of the cell\n                p1 = [x[i], y[j]]\n                p2 = [x[i + 1], y[j]]\n                p3 = [x[i + 1], y[j + 1]]\n                p4 = [x[i], y[j + 1]]\n\n                # append the points to the cells\n                cells.append([p1, p2, p3, p4])\n\n        # convert to numpy array\n        cells = np.array(cells, dtype=np.float64)\n\n        # use arctan2 to sort the points in anticlockwise direction\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(cells.shape[0]):\n            cell = cells[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cells[i] = cell[np.argsort(angles)]\n\n        # generate a meshio mesh object using the cells\n        self.mesh = meshio.Mesh(\n            points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n        )\n\n        # lets generate the boundary points, this function will return a dictionary of boundary points\n        # the keys will be the boundary tags and values will be the list of boundary points\n        bd_points = {}\n\n        num_bound_per_side = int(num_boundary_points / 4)\n\n        def _temp_bd_func(start, end, num_pts):\n            \"\"\"\n            This function returns the boundary points between the start and end points\n            using lhs sampling.\n\n            Args:\n                start: Start point of the boundary\n                end: End point of the boundary\n                num_pts: Number of boundary points to be generated\n\n            Returns:\n                bd_pts: Array of boundary points\n            \"\"\"\n            # generate the boundary points using lhs as a np.float64 array\n            bd_pts = lhs(1, num_pts).astype(np.float64)\n            # scale the points\n            bd_pts = bd_pts * (end - start) + start\n\n            return bd_pts.reshape(-1)\n\n        # bottom boundary\n        y_bottom = (\n            np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n        ).reshape(-1)\n        x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n        # right boundary\n        x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n            -1\n        )\n        y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1001] = np.vstack([x_right, y_right]).T\n\n        # top boundary\n        y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n            -1\n        )\n        x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1002] = np.vstack([x_top, y_top]).T\n\n        # left boundary\n        x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n            -1\n        )\n        y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1003] = np.vstack([x_left, y_left]).T\n\n        self.cell_points = cells\n        self.bd_dict = bd_points\n\n        # generate vtk\n        if not self.is_optimized:\n            self.generate_vtk_for_test()\n\n        return self.cell_points, self.bd_dict\n\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # initialise the mesh\n            gmsh.initialize()\n\n            # Now, lets generate the mesh with the points.\n            x_range = self.x_limits[1] - self.x_limits[0]\n            y_range = self.y_limits[1] - self.y_limits[0]\n\n            mesh_size_x = x_range / self.n_test_points_x\n            mesh_size_y = y_range / self.n_test_points_y\n\n            # generate a gmsh with the given parameters\n            Xmin = self.x_limits[0]\n            Xmax = self.x_limits[1]\n            Ymin = self.y_limits[0]\n            Ymax = self.y_limits[1]\n\n            point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n            point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n            point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n            point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n            line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n            line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n            line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n            line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n            face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n            gmsh.model.geo.add_plane_surface([face1])\n\n            # Create the relevant Gmsh data structures\n            # from Gmsh model.\n            gmsh.model.geo.synchronize()\n\n            # Generate mesh:\n            gmsh.model.mesh.generate()\n\n            mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n            gmsh.write(str(mesh_file_name))\n            print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n            # close the gmsh\n            gmsh.finalize()\n\n            # read the mesh using meshio\n            mesh = meshio.gmsh.read(str(mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for internal mesh file generated at \",\n                str(mesh_file_name),\n            )\n\n        elif self.mesh_generation_method == \"external\":\n\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n            # Use the internal mesh to generate the vtk file\n            mesh = meshio.read(str(self.mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for external mesh file generated at \",\n                str(vtk_file_name),\n            )\n\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            test_points (np.ndarray): Array of test points\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n            # code over written to plot from np.linspace instead of vtk file\n            # generate linspace of points in x and y direction based on x and y limits\n            x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n            y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n            # generate meshgrid\n            x_grid, y_grid = np.meshgrid(x, y)\n            # stack the points\n            self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n            return self.test_points\n\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        mesh = meshio.read(str(vtk_file_name))\n        points = mesh.points\n        return points[:, 0:2]  # return only first two columns\n\n    def write_vtk(\n        self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n    ):\n        \"\"\"\n        Writes the data to a VTK file.\n\n        Args:\n            solution: The solution data to be written\n            output_path: The output path for the VTK file\n            filename: The name of the output file\n            data_names: List of data names\n\n        Returns:\n            None\n        \"\"\"\n        # read the existing vtk into file\n        if self.mesh_generation_method == \"internal\":\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        data = []\n        with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n            for line in File:\n                data.append(line)\n\n        # get the output file name\n        output_file_name = Path(output_path) / filename\n\n        if solution.shape[1] != len(data_names):\n            print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n            print(\n                \"Num Columns in solution = \",\n                solution.shape[1],\n                \" Num of data names = \",\n                len(data_names),\n            )\n            raise ValueError(\"Number of data names and solution columns are not equal\")\n\n        # write the data to the output file\n        with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n            for line in data:\n                FN.write(line)\n                if \"POINT_DATA\" in line.strip():\n                    break\n\n            for i in range(solution.shape[1]):\n                FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n                FN.write(\"LOOKUP_TABLE default\\n\")\n                np.savetxt(FN, solution[:, i])\n                FN.write(\"\\n\")\n\n        # save the vtk file as image\n        # self.save_vtk_as_image(str(output_file_name), data_names)\n\n    def plot_adaptive_mesh(\n        self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n    ):\n        \"\"\"\n        Plots the residuals in each cell of the mesh.\n\n        Args:\n            cells_list: List of cell vertices\n            area_averaged_cell_loss_list: List of area averaged cell loss\n            epoch: The epoch number\n            filename: The output filename\n\n        Returns:\n            None\n        \"\"\"\n\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # normalise colors\n        norm = mcolors.Normalize(\n            vmin=np.min(area_averaged_cell_loss_list),\n            vmax=np.max(area_averaged_cell_loss_list),\n        )\n\n        # Create a colormap\n        colormap = plt.cm.jet\n\n        for index, cell in enumerate(cells_list):\n            x = cell[:, 0]\n            y = cell[:, 1]\n\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n            color = colormap(norm(curr_cell_loss))\n\n            plt.fill(x, y, color=color, alpha=0.9)\n\n            plt.plot(x, y, \"k\")\n\n            # # compute x_min, x_max, y_min, y_max\n            # x_min = np.min(x)\n            # x_max = np.max(x)\n            # y_min = np.min(y)\n            # y_max = np.max(y)\n\n            # # compute centroid of the cells\n            # centroid = np.array([np.mean(x), np.mean(y)])\n\n            # plot the loss text within the cell\n            # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n        sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n        sm.set_array([])\n        plt.colorbar(sm)\n\n        # output filename\n        output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n        plt.title(f\"Cell Residual\")\n        plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.__init__","title":"<code>__init__(mesh_type, mesh_generation_method, n_test_points_x, n_test_points_y, output_folder, is_optimized=False)</code>","text":"<p>Constructor for Geometry_2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements ('quadrilateral')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method of mesh generation ('internal'/'external')</p> required <code>n_test_points_x</code> <code>int</code> <p>Number of test points in x-direction</p> required <code>n_test_points_y</code> <code>int</code> <p>Number of test points in y-direction</p> required <code>output_folder</code> <code>str</code> <p>Path for output files</p> required <code>is_optimized</code> <code>bool</code> <p>Flag for mesh optimization</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh type or generation method is invalid</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def __init__(\n    self,\n    mesh_type: str,\n    mesh_generation_method: str,\n    n_test_points_x: int,\n    n_test_points_y: int,\n    output_folder: str,\n    is_optimized: bool = False,\n):\n    \"\"\"\n    Constructor for Geometry_2D class.\n\n    Args:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n\n    Raises:\n        ValueError: If mesh type or generation method is invalid\n\n    Returns:\n        None\n    \"\"\"\n    # Call the super class constructor\n    super().__init__(mesh_type, mesh_generation_method)\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n    self.n_test_points_x = n_test_points_x\n    self.n_test_points_y = n_test_points_y\n    self.output_folder = output_folder\n    self.is_optimized = is_optimized\n\n    if self.mesh_generation_method not in [\"internal\", \"external\"]:\n        print(\n            f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\n            \"Mesh generation method should be either internal or external.\"\n        )\n\n    if self.mesh_type not in [\"quadrilateral\"]:\n        print(\n            f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n    # To be filled - only when mesh is internal\n    self.n_cells_x = None\n    self.n_cells_y = None\n    self.x_limits = None\n    self.y_limits = None\n\n    # to be filled by external\n    self.mesh_file_name = None\n    self.mesh = None\n    self.bd_dict = None\n    self.cell_points = None\n    self.test_points = None\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.generate_quad_mesh_internal","title":"<code>generate_quad_mesh_internal(x_limits, y_limits, n_cells_x, n_cells_y, num_boundary_points)</code>","text":"<p>Generate and save a quadrilateral mesh with physical curves.</p> <p>Parameters:</p> Name Type Description Default <code>x_limits</code> <code>tuple</code> <p>Domain limits in x-direction</p> required <code>y_limits</code> <code>tuple</code> <p>Domain limits in y-direction</p> required <code>n_cells_x</code> <code>int</code> <p>Number of cells in x-direction</p> required <code>n_cells_y</code> <code>int</code> <p>Number of cells in y-direction</p> required <code>num_boundary_points</code> <code>int</code> <p>Number of boundary points</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_quad_mesh_internal(\n    self,\n    x_limits: tuple,\n    y_limits: tuple,\n    n_cells_x: int,\n    n_cells_y: int,\n    num_boundary_points: int,\n):\n    \"\"\"\n    Generate and save a quadrilateral mesh with physical curves.\n\n    Args:\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        n_cells_x: Number of cells in x-direction\n        n_cells_y: Number of cells in y-direction\n        num_boundary_points: Number of boundary points\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n    \"\"\"\n\n    self.n_cells_x = n_cells_x\n    self.n_cells_y = n_cells_y\n    self.x_limits = x_limits\n    self.y_limits = y_limits\n\n    # generate linspace of points in x and y direction\n    x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n    y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n    # Generate quad cells from the points\n    # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n    cells = []\n\n    for i in range(n_cells_x):\n        for j in range(n_cells_y):\n            # get the four points of the cell\n            p1 = [x[i], y[j]]\n            p2 = [x[i + 1], y[j]]\n            p3 = [x[i + 1], y[j + 1]]\n            p4 = [x[i], y[j + 1]]\n\n            # append the points to the cells\n            cells.append([p1, p2, p3, p4])\n\n    # convert to numpy array\n    cells = np.array(cells, dtype=np.float64)\n\n    # use arctan2 to sort the points in anticlockwise direction\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(cells.shape[0]):\n        cell = cells[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cells[i] = cell[np.argsort(angles)]\n\n    # generate a meshio mesh object using the cells\n    self.mesh = meshio.Mesh(\n        points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n    )\n\n    # lets generate the boundary points, this function will return a dictionary of boundary points\n    # the keys will be the boundary tags and values will be the list of boundary points\n    bd_points = {}\n\n    num_bound_per_side = int(num_boundary_points / 4)\n\n    def _temp_bd_func(start, end, num_pts):\n        \"\"\"\n        This function returns the boundary points between the start and end points\n        using lhs sampling.\n\n        Args:\n            start: Start point of the boundary\n            end: End point of the boundary\n            num_pts: Number of boundary points to be generated\n\n        Returns:\n            bd_pts: Array of boundary points\n        \"\"\"\n        # generate the boundary points using lhs as a np.float64 array\n        bd_pts = lhs(1, num_pts).astype(np.float64)\n        # scale the points\n        bd_pts = bd_pts * (end - start) + start\n\n        return bd_pts.reshape(-1)\n\n    # bottom boundary\n    y_bottom = (\n        np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n    ).reshape(-1)\n    x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n    # right boundary\n    x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n        -1\n    )\n    y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1001] = np.vstack([x_right, y_right]).T\n\n    # top boundary\n    y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n        -1\n    )\n    x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1002] = np.vstack([x_top, y_top]).T\n\n    # left boundary\n    x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n        -1\n    )\n    y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1003] = np.vstack([x_left, y_left]).T\n\n    self.cell_points = cells\n    self.bd_dict = bd_points\n\n    # generate vtk\n    if not self.is_optimized:\n        self.generate_vtk_for_test()\n\n    return self.cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # initialise the mesh\n        gmsh.initialize()\n\n        # Now, lets generate the mesh with the points.\n        x_range = self.x_limits[1] - self.x_limits[0]\n        y_range = self.y_limits[1] - self.y_limits[0]\n\n        mesh_size_x = x_range / self.n_test_points_x\n        mesh_size_y = y_range / self.n_test_points_y\n\n        # generate a gmsh with the given parameters\n        Xmin = self.x_limits[0]\n        Xmax = self.x_limits[1]\n        Ymin = self.y_limits[0]\n        Ymax = self.y_limits[1]\n\n        point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n        point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n        point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n        point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n        line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n        line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n        line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n        line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n        face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n        gmsh.model.geo.add_plane_surface([face1])\n\n        # Create the relevant Gmsh data structures\n        # from Gmsh model.\n        gmsh.model.geo.synchronize()\n\n        # Generate mesh:\n        gmsh.model.mesh.generate()\n\n        mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n        gmsh.write(str(mesh_file_name))\n        print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n        # close the gmsh\n        gmsh.finalize()\n\n        # read the mesh using meshio\n        mesh = meshio.gmsh.read(str(mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for internal mesh file generated at \",\n            str(mesh_file_name),\n        )\n\n    elif self.mesh_generation_method == \"external\":\n\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        # Use the internal mesh to generate the vtk file\n        mesh = meshio.read(str(self.mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for external mesh file generated at \",\n            str(vtk_file_name),\n        )\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.get_test_points","title":"<code>get_test_points()</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>test_points</code> <code>ndarray</code> <p>Array of test points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        test_points (np.ndarray): Array of test points\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n        # code over written to plot from np.linspace instead of vtk file\n        # generate linspace of points in x and y direction based on x and y limits\n        x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n        y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n        # generate meshgrid\n        x_grid, y_grid = np.meshgrid(x, y)\n        # stack the points\n        self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n        return self.test_points\n\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    mesh = meshio.read(str(vtk_file_name))\n    points = mesh.points\n    return points[:, 0:2]  # return only first two columns\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.plot_adaptive_mesh","title":"<code>plot_adaptive_mesh(cells_list, area_averaged_cell_loss_list, epoch, filename='cell_residual')</code>","text":"<p>Plots the residuals in each cell of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>cells_list</code> <p>List of cell vertices</p> required <code>area_averaged_cell_loss_list</code> <p>List of area averaged cell loss</p> required <code>epoch</code> <p>The epoch number</p> required <code>filename</code> <p>The output filename</p> <code>'cell_residual'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def plot_adaptive_mesh(\n    self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n):\n    \"\"\"\n    Plots the residuals in each cell of the mesh.\n\n    Args:\n        cells_list: List of cell vertices\n        area_averaged_cell_loss_list: List of area averaged cell loss\n        epoch: The epoch number\n        filename: The output filename\n\n    Returns:\n        None\n    \"\"\"\n\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # normalise colors\n    norm = mcolors.Normalize(\n        vmin=np.min(area_averaged_cell_loss_list),\n        vmax=np.max(area_averaged_cell_loss_list),\n    )\n\n    # Create a colormap\n    colormap = plt.cm.jet\n\n    for index, cell in enumerate(cells_list):\n        x = cell[:, 0]\n        y = cell[:, 1]\n\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n        color = colormap(norm(curr_cell_loss))\n\n        plt.fill(x, y, color=color, alpha=0.9)\n\n        plt.plot(x, y, \"k\")\n\n        # # compute x_min, x_max, y_min, y_max\n        # x_min = np.min(x)\n        # x_max = np.max(x)\n        # y_min = np.min(y)\n        # y_max = np.max(y)\n\n        # # compute centroid of the cells\n        # centroid = np.array([np.mean(x), np.mean(y)])\n\n        # plot the loss text within the cell\n        # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n    sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n    sm.set_array([])\n    plt.colorbar(sm)\n\n    # output filename\n    output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n    plt.title(f\"Cell Residual\")\n    plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>","text":"<p>Reads mesh from a Gmsh .msh file and extracts cell information.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of boundary point refinement</p> required <code>bd_sampling_method</code> <code>str</code> <p>Method for boundary point sampling ('uniform'/'lhs')</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh file format is invalid</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Reads mesh from a Gmsh .msh file and extracts cell information.\n\n    Args:\n        mesh_file: Path to the mesh file\n        boundary_point_refinement_level: Level of boundary point refinement\n        bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n        refinement_level: Level of mesh refinement\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n\n    Raises:\n        ValueError: If mesh file format is invalid\n    \"\"\"\n\n    self.mesh_file_name = mesh_file\n\n    # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n    file_extension = Path(mesh_file).suffix\n\n    if file_extension != \".mesh\":\n        raise ValueError(\"Mesh file should be in .mesh format.\")\n\n    # Read mesh using meshio\n    self.mesh = meshio.read(mesh_file)\n\n    if self.mesh_type == \"quadrilateral\":\n        # Extract cell information\n        cells = self.mesh.cells_dict[\"quad\"]\n\n    num_cells = cells.shape[0]\n    print(f\"[INFO] : Number of cells = {num_cells}\")\n    cell_points = self.mesh.points[cells][\n        :, :, 0:2\n    ]  # remove the z coordinate, which is 0 for all points\n\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(num_cells):\n        cell = cell_points[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cell_points[i] = cell[np.argsort(angles)]\n\n    # Extract number of points within each cell\n    print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n    # Collect the Boundary point id's within the domain\n    boundary_edges = self.mesh.cells_dict[\"line\"]\n\n    # Using the point id, collect the coordinates of the boundary points\n    boundary_coordinates = self.mesh.points[boundary_edges]\n\n    # Number of Existing Boundary points\n    print(\n        f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n    )\n\n    # now Get the physical tag of the boundary edges\n    boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n    # Generate a Dictionary of boundary tags and boundary coordinates\n    # Keys will be the boundary tags and values will be the list of coordinates\n    boundary_dict = {}\n\n    # refine the boundary points based on the number of boundary points needed\n    for i in range(boundary_coordinates.shape[0]):\n        p1 = boundary_coordinates[i, 0, :]\n        p2 = boundary_coordinates[i, 1, :]\n\n        if bd_sampling_method == \"uniform\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = np.linspace(\n                p1, p2, pow(2, boundary_point_refinement_level) + 1\n            )\n        elif bd_sampling_method == \"lhs\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n            new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n            new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n        else:\n            print(\n                f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n        # get the boundary tag\n        tag = boundary_tags[i]\n\n        if tag not in boundary_dict:\n            boundary_dict[tag] = new_points\n        else:\n            current_val = new_points\n            prev_val = boundary_dict[tag]\n            final = np.vstack([prev_val, current_val])\n            boundary_dict[tag] = final\n\n    # get unique\n    for tag in boundary_dict.keys():\n        val = boundary_dict[tag]\n        val = np.unique(val, axis=0)\n        boundary_dict[tag] = val\n\n    self.bd_dict = boundary_dict\n    # print the new boundary points  on each boundary tag (key) in a tabular format\n\n    total_bound_points = 0\n    print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n    print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n    for k, v in self.bd_dict.items():\n        print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n        total_bound_points += v.shape[0]\n\n    print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n    # Assign to class values\n    self.cell_points = cell_points\n\n    # generate testvtk\n    self.generate_vtk_for_test()\n\n    return cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.write_vtk","title":"<code>write_vtk(solution, output_path, filename, data_names)</code>","text":"<p>Writes the data to a VTK file.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>ndarray</code> <p>The solution data to be written</p> required <code>output_path</code> <code>str</code> <p>The output path for the VTK file</p> required <code>filename</code> <code>str</code> <p>The name of the output file</p> required <code>data_names</code> <code>list</code> <p>List of data names</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def write_vtk(\n    self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n):\n    \"\"\"\n    Writes the data to a VTK file.\n\n    Args:\n        solution: The solution data to be written\n        output_path: The output path for the VTK file\n        filename: The name of the output file\n        data_names: List of data names\n\n    Returns:\n        None\n    \"\"\"\n    # read the existing vtk into file\n    if self.mesh_generation_method == \"internal\":\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    data = []\n    with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n        for line in File:\n            data.append(line)\n\n    # get the output file name\n    output_file_name = Path(output_path) / filename\n\n    if solution.shape[1] != len(data_names):\n        print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n        print(\n            \"Num Columns in solution = \",\n            solution.shape[1],\n            \" Num of data names = \",\n            len(data_names),\n        )\n        raise ValueError(\"Number of data names and solution columns are not equal\")\n\n    # write the data to the output file\n    with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n        for line in data:\n            FN.write(line)\n            if \"POINT_DATA\" in line.strip():\n                break\n\n        for i in range(solution.shape[1]):\n            FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n            FN.write(\"LOOKUP_TABLE default\\n\")\n            np.savetxt(FN, solution[:, i])\n            FN.write(\"\\n\")\n</code></pre>"},{"location":"api/core/tutorial/classification_tutorial/","title":"Classification Tutorial","text":"<p>In this file have to write how to run the respective file</p> bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"api/core/tutorial/classification_tutorial/#bubble-sortpy","title":"bubble sort.py","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"api/core/tutorial/classification_tutorial/#highlighting-lines","title":"Highlighting lines","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"}]}