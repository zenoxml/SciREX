{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SciREX: Scientific Research and Engineering eXcellence","text":"<p>SciREX is an open-source scientific AI and machine learning framework designed for researchers and engineers. Jointly developed by Zenteiq Aitech Innovations Private Limited and the AiREX (AI for Research and Engineering eXcellence) Lab at Indian Institute of Science, Bangalore, SciREX bridges the gap between theoretical research and practical implementation while maintaining mathematical rigor and computational efficiency.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Research-First Design: Built specifically for scientific computing and research workflows</li> <li>Mathematical Foundations: Strong emphasis on mathematical correctness and theoretical foundations</li> <li>Hardware Optimization: Efficient implementation with GPU acceleration support</li> <li>Reproducible Research: Built-in experiment tracking and result reproduction capabilities</li> <li>Scientific Visualization: Publication-ready plotting and visualization tools</li> <li>Industrial Integration: Enterprise-ready solutions backed by Zenteiq's industrial expertise</li> </ul>"},{"location":"#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Scientific Computing</li> <li>Physics-Informed Neural Networks (PINNs)</li> <li>Differential Equation Solvers</li> <li> <p>Scientific Data Analysis</p> </li> <li> <p>Machine Learning</p> </li> <li>Classical ML Algorithms</li> <li>Deep Learning Models</li> <li>Custom Loss Functions</li> <li> <p>Advanced Optimizers</p> </li> <li> <p>Research Tools</p> </li> <li>Experiment Management</li> <li>Result Visualization</li> <li>Benchmark Datasets</li> <li>Performance Metrics</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Clone the SciREX repo <pre><code>mkdir scirex\ncd scirex\ngit clone https://github.com/zenoxml/SciREX.git \n</code></pre></li> <li>Create a virtual environment <pre><code>python3 -m venv .\nsource bin/activate\n</code></pre></li> <li>Install dependencies using: <pre><code>pip install -e .\n</code></pre></li> <li>This completes the installation. Check out the examples for usage </li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Visit our documentation  for:</p> <ul> <li> <p>Getting Started Guide</p> </li> <li> <p>API Reference</p> </li> <li> <p>Mathematical Background</p> </li> <li> <p>Tutorials and Examples</p> </li> <li> <p>Contribution Guidelines</p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>Copyright (c) 2024 Zenteiq Aitech Innovations Private Limited and AiREX Lab, Indian Institute of Science, Bangalore. All rights reserved.</p>"},{"location":"#software-license","title":"Software License","text":"<p>SciREX is licensed under the Apache License, Version 2.0 (the \"License\"). You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"#intellectual-property","title":"Intellectual Property","text":""},{"location":"#copyright-holders","title":"Copyright Holders","text":"<ul> <li>Zenteiq Aitech Innovations Private Limited</li> <li>The AiREX Lab at IISc Bangalore</li> </ul>"},{"location":"#components-and-libraries","title":"Components and Libraries","text":"<ul> <li>The core SciREX framework and its original components are copyright of the above holders</li> <li>Third-party libraries and dependencies are subject to their respective licenses</li> <li>Mathematical algorithms and scientific methods implemented may be subject to their own patents or licenses</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from both the research and industrial communities! Please see our Contributing Guidelinesfor details.</p>"},{"location":"#community","title":"Community","text":"<ul> <li>Discord</li> </ul>"},{"location":"#official-partners","title":"Official Partners","text":"<ul> <li>ARTPARK (AI &amp; Robotics Technology Park) at IISc</li> <li>In discussion with NVIDIA and other technology companies</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>SciREX is developed and maintained through the collaborative efforts of Zenteiq Aitech Innovations and the AiREX Lab at IISc Bangalore. We thank all contributors from both industry and academia for their valuable input and support in advancing scientific computing.</p> Powered by  Zenteiq Aitech Innovations Private Limited and Airex Lab (IISc) - Aritifical Intelligence Research Engineering Exellence Lab"},{"location":"api/core/Contribution/contribution/","title":"Contributing to SciREX","text":"<p>First off, thank you for considering contributing to SciREX! We value contributions from both the academic and industrial communities.</p> <p>All types of contributions are encouraged and valued. This document outlines various ways to help and details about how this project handles them. Please read the relevant sections before making your contribution.</p> <p>If you like the project but don't have time to contribute, there are other ways to support it: - Star the project on GitHub - Share it in academic and professional networks - Cite it in your research papers - Mention it at conferences and workshops - Use it in your research or industrial projects</p>"},{"location":"api/core/Contribution/contribution/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Questions and Support</li> <li>Ways to Contribute</li> <li>Reporting Bugs</li> <li>Suggesting Enhancements</li> <li>Code Contributions</li> <li>Documentation</li> <li>Research Contributions</li> <li>Development Guidelines</li> <li>Setting Up Development Environment</li> <li>Code Style</li> <li>Testing</li> <li>Documentation Standards</li> <li>Legal Notices</li> </ul>"},{"location":"api/core/Contribution/contribution/#questions-and-support","title":"Questions and Support","text":"<p>Before asking a question: - Read the Documentation - Search existing Issues - Check our Discord community</p> <p>For new questions: 1. Open an Issue 2. Provide context about your use case 3. Include relevant details (Python version, OS, etc.) 4. Specify if it's a research or industrial application</p>"},{"location":"api/core/Contribution/contribution/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"api/core/Contribution/contribution/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"api/core/Contribution/contribution/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<ul> <li>Verify you're using the latest version</li> <li>Check if it's a known issue in our bug tracker</li> <li>Search academic literature if it's a known scientific computing issue</li> <li>Collect information:</li> <li>Full error traceback</li> <li>OS and hardware details</li> <li>Minimal reproducible example</li> <li>Scientific context if applicable</li> </ul>"},{"location":"api/core/Contribution/contribution/#submitting-a-bug-report","title":"Submitting a Bug Report","text":"<p>Security Issues: Never report security vulnerabilities through public GitHub issues. Email security@zenteiq.ai instead.</p> <p>Submit bugs through GitHub issues: 1. Use the bug report template 2. Describe expected vs actual behavior 3. Provide reproduction steps 4. Include relevant scientific context 5. Attach minimal test data if needed</p>"},{"location":"api/core/Contribution/contribution/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>For enhancement suggestions: 1. Verify the functionality doesn't exist 2. Explain the scientific/technical motivation 3. Provide mathematical foundations if applicable 4. Describe implementation approach 5. Reference relevant research papers</p>"},{"location":"api/core/Contribution/contribution/#code-contributions","title":"Code Contributions","text":""},{"location":"api/core/Contribution/contribution/#first-time-contributors","title":"First-time Contributors","text":"<ol> <li>Fork the repository</li> <li>Clone your fork: <pre><code>git clone https://github.com/&lt;YOUR_USERNAME&gt;/SciREX.git\ncd SciREX\n</code></pre></li> <li>Create a branch: <pre><code>git checkout -b feature/&lt;descriptive-name&gt;\n</code></pre></li> <li>Install dependencies: <pre><code>pip install -e \".[dev,test]\"\n</code></pre></li> </ol>"},{"location":"api/core/Contribution/contribution/#development-workflow","title":"Development Workflow","text":"<ol> <li>Write tests first</li> <li>Implement your changes</li> <li>Add documentation</li> <li>Run test suite: <pre><code>pytest tests/\n</code></pre></li> <li>Submit a pull request</li> </ol>"},{"location":"api/core/Contribution/contribution/#documentation","title":"Documentation","text":"<p>Documentation contributions should: - Follow scientific writing standards - Include mathematical notation where appropriate - Provide practical examples - Reference relevant literature - Follow our documentation style guide</p>"},{"location":"api/core/Contribution/contribution/#research-contributions","title":"Research Contributions","text":"<p>For research-related contributions: - Provide theoretical foundations - Include mathematical proofs if applicable - Add benchmark results - Reference related work - Follow scientific reproducibility guidelines</p>"},{"location":"api/core/Contribution/contribution/#development-guidelines","title":"Development Guidelines","text":""},{"location":"api/core/Contribution/contribution/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8</li> <li>Use meaningful scientific variable names</li> <li>Document mathematical equations</li> <li>Include algorithm complexity analysis</li> <li>Add references to papers/methods</li> </ul>"},{"location":"api/core/Contribution/contribution/#testing","title":"Testing","text":"<ul> <li>Write unit tests for new features</li> <li>Include numerical accuracy tests</li> <li>Add performance benchmarks</li> <li>Test edge cases</li> <li>Verify mathematical correctness</li> </ul>"},{"location":"api/core/Contribution/contribution/#styleguides","title":"Styleguides","text":""},{"location":"api/core/Contribution/contribution/#code-style-and-documentation","title":"Code Style and Documentation","text":""},{"location":"api/core/Contribution/contribution/#google-style-guide-adaptation-for-scientific-computing","title":"Google Style Guide Adaptation for Scientific Computing","text":"<p>We follow the Google Python Style Guide with specific adaptations for scientific computing:</p>"},{"location":"api/core/Contribution/contribution/#function-and-variable-names","title":"Function and Variable Names","text":"<pre><code># Good\ndef solve_navier_stokes(reynolds_number, initial_conditions):\n    velocity_field = initialize_flow_field()\n    pressure_gradient = compute_pressure_gradient()\n\n# Bad\ndef solveNS(re, ic):\n    v = init_flow()\n    dp = comp_press()\n</code></pre>"},{"location":"api/core/Contribution/contribution/#docstring-format","title":"Docstring Format","text":"<pre><code>def compute_finite_difference(\n    function_values: np.ndarray, \n    dx: float, \n    order: int = 2\n) -&gt; np.ndarray:\n    \"\"\"Computes finite difference approximation of derivatives.\n\n    Implements centered finite difference scheme of specified order for\n    approximating derivatives of discrete data.\n\n    Args:\n        function_values: Array of function values at discrete points.\n            Shape: (n_points,) or (n_points, n_dimensions)\n        dx: Grid spacing (assumed uniform)\n        order: Order of accuracy for finite difference scheme.\n            Must be 2 or 4. Defaults to 2.\n\n    Returns:\n        np.ndarray: Approximated derivatives at each point.\n            Same shape as input function_values.\n\n    Raises:\n        ValueError: If order is not 2 or 4\n        ValueError: If function_values has less than order + 1 points\n\n    Notes:\n        Uses the following stencils:\n        2nd order: f'(x) \u2248 (f(x+h) - f(x-h))/(2h)\n        4th order: f'(x) \u2248 (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h))/(12h)\n\n    References:\n        [1] LeVeque, R. J. (2007). Finite Difference Methods for Ordinary \n            and Partial Differential Equations.\n    \"\"\"\n</code></pre>"},{"location":"api/core/Contribution/contribution/#module-level-docstrings","title":"Module-Level Docstrings","text":"<pre><code>\"\"\"Solvers for partial differential equations using finite element methods.\n\nThis module implements various finite element solvers for elliptic, parabolic,\nand hyperbolic PDEs. The implementation follows the formulation in Hughes (2000)\nwith extensions for stabilized methods.\n\nKey classes:\n    - FEMSolver: Base solver class\n    - EllipticSolver: For elliptic PDEs\n    - ParabolicSolver: For parabolic PDEs\n\nKey functions:\n    - assemble_stiffness_matrix: Assembles global stiffness matrix\n    - solve_linear_system: Solves resulting linear system\n\nNote that all solvers assume a well-posed problem with appropriate boundary\nconditions.\n\nReferences:\n    [1] Hughes, T. J. R. (2000). The Finite Element Method: Linear Static and \n        Dynamic Finite Element Analysis.\n\"\"\"\n</code></pre>"},{"location":"api/core/Contribution/contribution/#class-docstrings","title":"Class Docstrings","text":"<pre><code>class AdaptiveMesh:\n    \"\"\"A mesh that adapts based on solution features.\n\n    This class implements adaptive mesh refinement/coarsening based on\n    error estimates. The refinement strategy follows the procedure outlined\n    in Bank et al. (1983).\n\n    Attributes:\n        nodes: Array of node coordinates, shape (n_nodes, dimension)\n        elements: Array of element connectivity, shape (n_elements, nodes_per_element)\n        error_estimator: Callable that computes error estimates\n        refinement_threshold: Float, threshold for mesh refinement\n\n    Example:\n        &gt;&gt;&gt; mesh = AdaptiveMesh(domain=[0, 1], initial_elements=10)\n        &gt;&gt;&gt; mesh.refine(error_threshold=1e-3)\n        &gt;&gt;&gt; solution = solve_pde(mesh)\n\n    References:\n        [1] Bank, R. E., Sherman, A. H., &amp; Weiser, A. (1983). \"Refinement \n            Algorithms and Data Structures for Regular Local Mesh Refinement\"\n    \"\"\"\n</code></pre>"},{"location":"api/core/Contribution/contribution/#exception-handling","title":"Exception Handling","text":"<pre><code>def integrate_numerically(function, bounds, method='gauss'):\n    \"\"\"Performs numerical integration using specified method.\n\n    Args:\n        function: Callable to integrate\n        bounds: Tuple of (lower, upper) bounds\n        method: Integration method ('gauss' or 'simpson')\n\n    Raises:\n        ValueError: If bounds are invalid or method is unsupported\n        IntegrationError: If integration fails to converge\n\n    Note:\n        For singular integrands, consider using adaptive methods\n    \"\"\"\n    if bounds[0] &gt;= bounds[1]:\n        raise ValueError(\n            f\"Lower bound {bounds[0]} must be less than upper bound {bounds[1]}\"\n        )\n\n    try:\n        result = _perform_integration(function, bounds, method)\n    except ConvergenceError as e:\n        raise IntegrationError(f\"Integration failed to converge: {e}\")\n</code></pre>"},{"location":"api/core/Contribution/contribution/#type-hints-and-comments","title":"Type Hints and Comments","text":"<pre><code>from typing import Union, Callable, Optional\nimport numpy as np\nimport scipy.sparse as sp\n\ndef solve_sparse_system(\n    matrix: Union[np.ndarray, sp.spmatrix],  # System matrix\n    rhs: np.ndarray,  # Right-hand side vector\n    solver: Optional[str] = 'gmres',  # Iterative solver type\n    preconditioner: Optional[Callable] = None,  # Custom preconditioner\n    tolerance: float = 1e-6\n) -&gt; np.ndarray:\n    \"\"\"Solves sparse linear system Ax = b.\"\"\"\n\nExample docstring:\n```python\ndef solve_pde(mesh, boundary_conditions, tolerance=1e-6):\n    \"\"\"Solves partial differential equations using the finite element method.\n\n    Implements the algorithm described in [Smith et al., 2023] using an adaptive\n    mesh refinement strategy.\n\n    The method solves the equation:\n\n    \u2202u/\u2202t = \u03b1\u2207\u00b2u + f(x,t)\n\n    Args:\n        mesh (FEMesh): Finite element mesh object\n        boundary_conditions (dict): Dictionary of boundary conditions\n        tolerance (float, optional): Convergence tolerance. Defaults to 1e-6\n\n    Returns:\n        np.ndarray: Solution vector on mesh nodes\n\n    References:\n        [1] Smith et al. (2023). Advanced PDE Solvers. J. Comp. Physics\n    \"\"\"\n</code></pre>"},{"location":"api/core/Contribution/contribution/#commit-messages","title":"Commit Messages","text":"<ul> <li>Use clear, descriptive commit messages</li> <li>Follow the format: <code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;</code></li> <li>Types: feat, fix, docs, style, refactor, perf, test</li> <li>Include issue numbers if applicable</li> </ul> <p>Example: <pre><code>feat(pinns): implement physics-informed loss function\n\n- Add custom loss terms for PDE constraints\n- Implement automatic differentiation for physics terms\n- Add tests for conservation laws\n- Update documentation with mathematical formulation\n\nFixes #123\n</code></pre></p>"},{"location":"api/core/Contribution/contribution/#improving-the-documentation","title":"Improving The Documentation","text":"<p>Documentation improvements are highly valued. Please follow these guidelines:</p>"},{"location":"api/core/Contribution/contribution/#types-of-documentation","title":"Types of Documentation","text":"<ol> <li>API Documentation</li> <li>Clear function/class descriptions</li> <li>Mathematical foundations</li> <li>Parameter explanations</li> <li>Example usage</li> <li> <p>References to papers</p> </li> <li> <p>Tutorials</p> </li> <li>Step-by-step guides</li> <li>Practical examples</li> <li>Clear explanations</li> <li> <p>Reproducible code</p> </li> <li> <p>Theoretical Documentation</p> </li> <li>Mathematical background</li> <li>Algorithm descriptions</li> <li>Derivations</li> <li> <p>Limitations and assumptions</p> </li> <li> <p>Benchmark Documentation</p> </li> <li>Performance metrics</li> <li>Comparison with other methods</li> <li>Hardware specifications</li> <li>Test conditions</li> </ol>"},{"location":"api/core/Contribution/contribution/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use clear, scientific language</li> <li>Include mathematical notation where appropriate</li> <li>Provide practical examples</li> <li>Reference relevant literature</li> <li>Follow consistent formatting</li> </ul>"},{"location":"api/core/Contribution/contribution/#contributing-workflow","title":"Contributing Workflow","text":"<ol> <li> <p>Fork and Clone <pre><code>git clone https://github.com/&lt;YOUR_USERNAME&gt;/SciREX.git\ncd SciREX\n</code></pre></p> </li> <li> <p>Set Up Environment <pre><code>python -m venv venv\nsource venv/bin/activate  # or `venv\\Scripts\\activate` on Windows\npip install -e \".[dev,test,docs]\"\npre-commit install\n</code></pre></p> </li> <li> <p>Create Feature Branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Development Process</p> </li> <li>Write tests first</li> <li>Implement changes</li> <li>Add documentation</li> <li>Run test suite</li> <li>Check code style</li> <li> <p>Update benchmarks if needed</p> </li> <li> <p>Review Checklist</p> </li> <li>[ ] Tests pass</li> <li>[ ] Documentation updated</li> <li>[ ] Code style guidelines followed</li> <li>[ ] Benchmarks updated (if applicable)</li> <li>[ ] Mathematical correctness verified</li> <li> <p>[ ] Examples added</p> </li> <li> <p>Submit Pull Request</p> </li> <li>Use PR template</li> <li>Link related issues</li> <li>Describe changes</li> <li>Add benchmark results</li> <li> <p>Request review</p> </li> <li> <p>Review Process</p> </li> <li>Address reviewer comments</li> <li>Update documentation</li> <li>Maintain mathematical rigor</li> <li>Ensure reproducibility</li> </ol>"},{"location":"api/core/Contribution/contribution/#legal-notices","title":"Legal Notices","text":"<ul> <li>All contributions must be licensed under the Apache License 2.0</li> <li>Contributors must sign our Contributor License Agreement</li> <li>Maintain all copyright notices</li> <li>Include appropriate citations</li> </ul> <p>For detailed documentation and guidelines, visit https://scirex.org/docs/contributing</p> <p>This document is maintained by the SciREX team at Zenteiq Aitech Innovations and AiREX Lab.</p>"},{"location":"api/core/dl/fcnn/","title":"fcnn","text":"<p>Module: fcnn.py</p> <p>This module implements Fully Connected Neural Networks</p> It provides functionality to <ul> <li>Train Fully Connected Neural Networks on a batched dataset</li> <li>Evaluate model performance using classification metrics</li> </ul> <p>Classes:</p> Name Description <code>Model</code> <p>Implements a Fully Connected Neural Network using Jax.</p> Dependencies <ul> <li>jax (for automatic differentiation and jit compilation)</li> <li>equinox (for neural network modules)</li> <li>jaxtyping (for type annotations)</li> <li>optax (for optimization)</li> </ul> Key Features <ul> <li>Support for binary and multi-class classification using neural networks</li> <li>Optimized training using autograd and jit compilation from jax</li> <li>Efficient neural networks implementation using equinox modules</li> </ul> Authors <ul> <li>Lokesh Mohanty (lokeshm@iisc.ac.in)</li> </ul> Version Info <ul> <li>30/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Module</code></p> <p>A simple neural network model</p> Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>class Model(eqx.Module):\n    \"\"\"A simple neural network model\"\"\"\n\n    layers: list\n\n    def __init__(self, layers):\n        self.layers = layers\n\n    def __call__(self, x: Array) -&gt; Array:\n        \"\"\"Forward pass of the model\"\"\"\n        for layer in self.layers:\n            x = layer(x)\n        return x\n</code></pre>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.Model.__call__","title":"<code>__call__(x)</code>","text":"<p>Forward pass of the model</p> Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>def __call__(self, x: Array) -&gt; Array:\n    \"\"\"Forward pass of the model\"\"\"\n    for layer in self.layers:\n        x = layer(x)\n    return x\n</code></pre>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.compute_accuracy","title":"<code>compute_accuracy(model, x, y)</code>","text":"<p>Compute accuracy</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Neural network model</p> required <code>x</code> <code>Array</code> <p>Batch of input data</p> required <code>y</code> <code>Array</code> <p>Batch of target labels</p> required Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>@eqx.filter_jit\ndef compute_accuracy(model: Model, x: Array, y: Array) -&gt; Float[Array, \"\"]:\n    \"\"\"\n    Compute accuracy\n\n    Args:\n        model: Neural network model\n        x: Batch of input data\n        y: Batch of target labels\n    \"\"\"\n    pred_y = jax.vmap(model)(x)\n    pred_class = jnp.argmax(pred_y, axis=1)\n    return jnp.mean(pred_class == y)\n</code></pre>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.cross_entropy_loss","title":"<code>cross_entropy_loss(model, x, y)</code>","text":"<p>Compute the cross-entropy loss</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Neural network model</p> required <code>x</code> <code>Array</code> <p>Batched input data</p> required <code>y</code> <code>Array</code> <p>Batched target labels</p> required Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>def cross_entropy_loss(model: Model, x: Array, y: Array) -&gt; Float[Array, \"\"]:\n    \"\"\"\n    Compute the cross-entropy loss\n\n    Args:\n        model: Neural network model\n        x: Batched input data\n        y: Batched target labels\n    \"\"\"\n    logits = jax.vmap(model)(x)\n    log_probs = jax.nn.log_softmax(logits, axis=-1)\n    nll = -jnp.take_along_axis(log_probs, jnp.expand_dims(y, 1), axis=1)\n    return jnp.mean(nll)\n</code></pre>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.evaluate","title":"<code>evaluate(model, x, y)</code>","text":"<p>Evaluate model on data</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Neural network model</p> required <code>x</code> <code>Array</code> <p>Batched input data</p> required <code>y</code> <code>Array</code> <p>Batched target labels</p> required <p>Returns:</p> Type Description <code>Tuple[Float[Array, ''], Float[Array, '']]</code> <p>Tuple of (average loss, average accuracy)</p> Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>def evaluate(\n    model: Model, x: Array, y: Array\n) -&gt; Tuple[Float[Array, \"\"], Float[Array, \"\"]]:\n    \"\"\"\n    Evaluate model on data\n\n    Args:\n        model: Neural network model\n        x: Batched input data\n        y: Batched target labels\n\n    Returns:\n        Tuple of (average loss, average accuracy)\n    \"\"\"\n    total_loss = 0.0\n    total_acc = 0.0\n    n_batches = len(x)\n\n    for batch_x, batch_y in zip(x, y):\n        loss = cross_entropy_loss(model, batch_x, batch_y)\n        acc = compute_accuracy(model, batch_x, batch_y)\n        total_loss += loss\n        total_acc += acc\n\n    return total_loss / n_batches, total_acc / n_batches\n</code></pre>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.make_step","title":"<code>make_step(model, opt_state, x, y, optimizer)</code>","text":"<p>Perform a single training step</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Neural network model</p> required <code>opt_state</code> <code>PyTree</code> <p>Optimizer state</p> required <code>x</code> <code>Array</code> <p>Batch of input data</p> required <code>y</code> <code>Array</code> <p>Batch of target labels</p> required <code>optimizer</code> <code>GradientTransformation</code> <p>Optax optimizer</p> required <p>Returns:</p> Type Description <code>Tuple[Model, PyTree, Float[Array, '']]</code> <p>Tuple of (updated model, updated optimizer state, loss value)</p> Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>@eqx.filter_jit\ndef make_step(\n    model: Model,\n    opt_state: PyTree,\n    x: Array,\n    y: Array,\n    optimizer: optax.GradientTransformation,\n) -&gt; Tuple[Model, PyTree, Float[Array, \"\"]]:\n    \"\"\"\n    Perform a single training step\n\n    Args:\n        model: Neural network model\n        opt_state: Optimizer state\n        x: Batch of input data\n        y: Batch of target labels\n        optimizer: Optax optimizer\n\n    Returns:\n        Tuple of (updated model, updated optimizer state, loss value)\n    \"\"\"\n    loss_val, grads = eqx.filter_value_and_grad(cross_entropy_loss)(model, x, y)\n    updates, opt_state = optimizer.update(\n        grads, opt_state, eqx.filter(model, eqx.is_array)\n    )\n    model = eqx.apply_updates(model, updates)\n    return model, opt_state, loss_val\n</code></pre>"},{"location":"api/core/dl/fcnn/#scirex.core.dl.fcnn.train","title":"<code>train(model, x_train, y_train, x_test, y_test, optim, num_epochs, print_every)</code>","text":"<p>Train the model</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Neural network model</p> required <code>x_train</code> <code>Array</code> <p>Training data batches (shape: [num_batches, batch_size, ...])</p> required <code>y_train</code> <code>Array</code> <p>Training labels batches (shape: [num_batches, batch_size])</p> required <code>x_test</code> <code>Array</code> <p>Test data batches</p> required <code>y_test</code> <code>Array</code> <p>Test labels batches</p> required <code>optim</code> <code>GradientTransformation</code> <p>Optax optimizer</p> required <code>num_epochs</code> <code>int</code> <p>Number of training epochs</p> required <code>print_every</code> <code>int</code> <p>Print progress every N batches</p> required <p>Returns:</p> Type Description <code>Tuple[Model, Dict[str, list[Any]]]</code> <p>Trained model and history</p> Source code in <code>scirex\\core\\dl\\fcnn.py</code> <pre><code>def train(\n    model: Model,\n    x_train: Array,\n    y_train: Array,\n    x_test: Array,\n    y_test: Array,\n    optim: optax.GradientTransformation,\n    num_epochs: int,\n    print_every: int,\n) -&gt; Tuple[Model, Dict[str, list[Any]]]:\n    \"\"\"\n    Train the model\n\n    Args:\n        model: Neural network model\n        x_train: Training data batches (shape: [num_batches, batch_size, ...])\n        y_train: Training labels batches (shape: [num_batches, batch_size])\n        x_test: Test data batches\n        y_test: Test labels batches\n        optim: Optax optimizer\n        num_epochs: Number of training epochs\n        print_every: Print progress every N batches\n\n    Returns:\n        Trained model and history\n    \"\"\"\n    opt_state = optim.init(eqx.filter(model, eqx.is_array))\n    num_batches = len(x_train)\n\n    history = {\n        \"train_loss\": [],\n        \"train_accuracy\": [],\n        \"test_loss\": [],\n        \"test_accuracy\": [],\n        \"epoch_times\": [],\n    }\n\n    for epoch in range(num_epochs):\n        total_loss = 0.0\n        start_time = time.time()\n\n        # Training loop\n        for batch_idx, (batch_x, batch_y) in enumerate(zip(x_train, y_train)):\n            # Perform optimization step\n            model, opt_state, loss_val = make_step(\n                model, opt_state, batch_x, batch_y, optim\n            )\n            total_loss += loss_val\n\n            # Print progress\n            if (batch_idx + 1) % print_every == 0:\n                avg_loss = total_loss / print_every\n                test_loss, test_acc = evaluate(model, x_test, y_test)\n                print(\n                    f\"Epoch {epoch+1}/{num_epochs}, Batch {batch_idx+1}/{num_batches}\"\n                )\n                print(\n                    f\"Train Loss: {loss_val:.4f}, Test Loss: {test_loss:.4f}, Test Acc: {test_acc:.4f}\"\n                )\n                total_loss = 0.0\n\n        # End of epoch evaluation\n        end_time = time.time()\n        time_taken = end_time - start_time\n        test_loss, test_acc = evaluate(model, x_test, y_test)\n        train_loss, train_acc = evaluate(model, x_train, y_train)\n        print(f\"\\nEpoch {epoch+1}/{num_epochs} completed\")\n        print(f\"Test Loss: {test_loss:.4f}, Test Accuracy: {test_acc:.4f}\\n\")\n        history[\"train_loss\"].append(train_loss)\n        history[\"train_accuracy\"].append(train_acc)\n        history[\"test_loss\"].append(test_loss)\n        history[\"test_accuracy\"].append(test_acc)\n        history[\"epoch_times\"].append(time_taken)\n\n    return model, history\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/","title":"tensorflow_wrapper","text":"<p>TensorFlow layer factory implementations.</p> <p>This module provides factory methods for creating TensorFlow/Keras layers with consistent configuration options. Currently supports Dense and Conv2D layers.</p> Key classes <ul> <li>TensorflowDense:  for Dense layers</li> <li>TensorflowConv2D:  for Conv2D layers</li> </ul> Example <p>dense_layer = TensorflowDense.create_layer(units=64, activation='relu') conv_layer = TensorflowConv2D.create_layer(filters=32, kernel_size=3)</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D","title":"<code>TensorflowConv2D</code>","text":"<p>Factory class for creating Keras Conv2D layers.</p> <p>Provides a static method for creating and configuring Keras Conv2D layers with consistent parameters.</p> Example Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>class TensorflowConv2D:\n    \"\"\"Factory class for creating Keras Conv2D layers.\n\n    Provides a static method for creating and configuring Keras Conv2D layers\n    with consistent parameters.\n\n    Example:\n        &gt;&gt;&gt; # Create a conv layer with 64 filters and 3x3 kernel\n        &gt;&gt;&gt; conv1 = TensorflowConv2D.create_layer(\n        ...     filters=64,\n        ...     kernel_size=3,\n        ...     activation='relu'\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a conv layer with 32 filters and 5x5 kernel\n        &gt;&gt;&gt; conv2 = TensorflowConv2D.create_layer(\n        ...     filters=32,\n        ...     kernel_size=(5, 5),\n        ...     activation='relu'\n        ... )\n    \"\"\"\n\n    @staticmethod\n    def create_layer(\n        filters: int,\n        kernel_size: Union[int, Tuple[int, int]],\n        activation: Optional[Union[str, callable]] = None,\n        kernel_initializer: str = \"glorot_uniform\",\n        bias_initializer: str = \"zeros\",\n        dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n    ) -&gt; tf.keras.layers.Conv2D:\n        \"\"\"Create and return a Keras Conv2D layer.\n\n        Args:\n            filters: Number of output filters\n            kernel_size: Size of convolution kernel\n            activation: Activation function to use\n            kernel_initializer: Initializer for kernel weights\n            bias_initializer: Initializer for bias vector\n            dtype: Data type for layer computations\n\n        Returns:\n            tf.keras.layers.Conv2D: The configured Conv2D layer\n        \"\"\"\n        return layers.Conv2D(\n            filters=filters,\n            kernel_size=kernel_size,\n            activation=activation,\n            kernel_initializer=kernel_initializer,\n            bias_initializer=bias_initializer,\n            dtype=dtype,\n        )\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D--create-a-conv-layer-with-64-filters-and-3x3-kernel","title":"Create a conv layer with 64 filters and 3x3 kernel","text":"<p>conv1 = TensorflowConv2D.create_layer( ...     filters=64, ...     kernel_size=3, ...     activation='relu' ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D--create-a-conv-layer-with-32-filters-and-5x5-kernel","title":"Create a conv layer with 32 filters and 5x5 kernel","text":"<p>conv2 = TensorflowConv2D.create_layer( ...     filters=32, ...     kernel_size=(5, 5), ...     activation='relu' ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowConv2D.create_layer","title":"<code>create_layer(filters, kernel_size, activation=None, kernel_initializer='glorot_uniform', bias_initializer='zeros', dtype=None)</code>  <code>staticmethod</code>","text":"<p>Create and return a Keras Conv2D layer.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>int</code> <p>Number of output filters</p> required <code>kernel_size</code> <code>Union[int, Tuple[int, int]]</code> <p>Size of convolution kernel</p> required <code>activation</code> <code>Optional[Union[str, callable]]</code> <p>Activation function to use</p> <code>None</code> <code>kernel_initializer</code> <code>str</code> <p>Initializer for kernel weights</p> <code>'glorot_uniform'</code> <code>bias_initializer</code> <code>str</code> <p>Initializer for bias vector</p> <code>'zeros'</code> <code>dtype</code> <code>Optional[Union[str, DType]]</code> <p>Data type for layer computations</p> <code>None</code> <p>Returns:</p> Type Description <code>Conv2D</code> <p>tf.keras.layers.Conv2D: The configured Conv2D layer</p> Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>@staticmethod\ndef create_layer(\n    filters: int,\n    kernel_size: Union[int, Tuple[int, int]],\n    activation: Optional[Union[str, callable]] = None,\n    kernel_initializer: str = \"glorot_uniform\",\n    bias_initializer: str = \"zeros\",\n    dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n) -&gt; tf.keras.layers.Conv2D:\n    \"\"\"Create and return a Keras Conv2D layer.\n\n    Args:\n        filters: Number of output filters\n        kernel_size: Size of convolution kernel\n        activation: Activation function to use\n        kernel_initializer: Initializer for kernel weights\n        bias_initializer: Initializer for bias vector\n        dtype: Data type for layer computations\n\n    Returns:\n        tf.keras.layers.Conv2D: The configured Conv2D layer\n    \"\"\"\n    return layers.Conv2D(\n        filters=filters,\n        kernel_size=kernel_size,\n        activation=activation,\n        kernel_initializer=kernel_initializer,\n        bias_initializer=bias_initializer,\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense","title":"<code>TensorflowDense</code>","text":"<p>Factory class for creating Keras Dense layers.</p> <p>Provides a static method for creating and configuring Keras Dense layers with consistent parameters.</p> Example Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>class TensorflowDense:\n    \"\"\"Factory class for creating Keras Dense layers.\n\n    Provides a static method for creating and configuring Keras Dense layers\n    with consistent parameters.\n\n    Example:\n        &gt;&gt;&gt; # Create a dense layer with 32 units and ReLU activation\n        &gt;&gt;&gt; dense1 = TensorflowDense.create_layer(\n        ...     units=32,\n        ...     activation='relu'\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create an output layer with 1 unit and no activation\n        &gt;&gt;&gt; dense2 = TensorflowDense.create_layer(\n        ...     units=1,\n        ...     activation=None\n        ... )\n    \"\"\"\n\n    @staticmethod\n    def create_layer(\n        units: int,\n        activation: Optional[Union[str, callable]] = None,\n        kernel_initializer: str = \"glorot_uniform\",\n        bias_initializer: str = \"zeros\",\n        dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n    ) -&gt; tf.keras.layers.Dense:\n        \"\"\"Create and return a Keras Dense layer.\n\n        Args:\n            units: Number of output units\n            activation: Activation function to use\n            kernel_initializer: Initializer for kernel weights\n            bias_initializer: Initializer for bias vector\n            dtype: Data type for layer computations\n\n        Returns:\n            tf.keras.layers.Dense: The configured Dense layer\n        \"\"\"\n        return layers.Dense(\n            units=units,\n            activation=activation,\n            kernel_initializer=kernel_initializer,\n            bias_initializer=bias_initializer,\n            dtype=dtype,\n        )\n</code></pre>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense--create-a-dense-layer-with-32-units-and-relu-activation","title":"Create a dense layer with 32 units and ReLU activation","text":"<p>dense1 = TensorflowDense.create_layer( ...     units=32, ...     activation='relu' ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense--create-an-output-layer-with-1-unit-and-no-activation","title":"Create an output layer with 1 unit and no activation","text":"<p>dense2 = TensorflowDense.create_layer( ...     units=1, ...     activation=None ... )</p>"},{"location":"api/core/dl/tensorflow_wrapper/#scirex.core.dl.tensorflow_wrapper.TensorflowDense.create_layer","title":"<code>create_layer(units, activation=None, kernel_initializer='glorot_uniform', bias_initializer='zeros', dtype=None)</code>  <code>staticmethod</code>","text":"<p>Create and return a Keras Dense layer.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>int</code> <p>Number of output units</p> required <code>activation</code> <code>Optional[Union[str, callable]]</code> <p>Activation function to use</p> <code>None</code> <code>kernel_initializer</code> <code>str</code> <p>Initializer for kernel weights</p> <code>'glorot_uniform'</code> <code>bias_initializer</code> <code>str</code> <p>Initializer for bias vector</p> <code>'zeros'</code> <code>dtype</code> <code>Optional[Union[str, DType]]</code> <p>Data type for layer computations</p> <code>None</code> <p>Returns:</p> Type Description <code>Dense</code> <p>tf.keras.layers.Dense: The configured Dense layer</p> Source code in <code>scirex\\core\\dl\\tensorflow_wrapper.py</code> <pre><code>@staticmethod\ndef create_layer(\n    units: int,\n    activation: Optional[Union[str, callable]] = None,\n    kernel_initializer: str = \"glorot_uniform\",\n    bias_initializer: str = \"zeros\",\n    dtype: Optional[Union[str, tf.dtypes.DType]] = None,\n) -&gt; tf.keras.layers.Dense:\n    \"\"\"Create and return a Keras Dense layer.\n\n    Args:\n        units: Number of output units\n        activation: Activation function to use\n        kernel_initializer: Initializer for kernel weights\n        bias_initializer: Initializer for bias vector\n        dtype: Data type for layer computations\n\n    Returns:\n        tf.keras.layers.Dense: The configured Dense layer\n    \"\"\"\n    return layers.Dense(\n        units=units,\n        activation=activation,\n        kernel_initializer=kernel_initializer,\n        bias_initializer=bias_initializer,\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/","title":"FastVPINNs - Training Tutorial - Helmholtz Problem","text":"<p>In this notebook, we will explore how to use FastVPINNs to solve the Helmholtz equation using custom loss functions and neural networks.</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#hp-variational-physics-informed-neural-networks-hp-vpinns","title":"hp-Variational Physics-Informed Neural Networks (hp-VPINNs)","text":"<p>Variational Physics-Informed Neural Networks (VPINNs) are a specialized class of Physics-Informed Neural Networks (PINNs) that are trained using the variational formulation of governing equations. The hp-VPINNs extend this concept by incorporating hp-FEM principles such as h- and p-refinement to enhance solution accuracy.</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>The 2D Helmholtz equation is given by:</p> \\[ -\\Delta u + ku = f \\] <p>where: - \\(u\\) is the solution - \\(k\\) is the Helmholtz coefficient - \\(f\\) is the source term - \\(\\Delta\\) is the Laplacian operator</p> <p>To obtain the weak form, we multiply by a test function \\(v\\) and integrate over the domain \\(\\Omega\\):</p> \\[ \\int_{\\Omega} (-\\Delta u + ku)v \\, dx = \\int_{\\Omega} f v \\, dx \\] <p>Applying integration by parts to the Laplacian term:</p> \\[ \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx + \\int_{\\Omega} kuv \\, dx - \\int_{\\partial \\Omega} \\nabla u \\cdot \\mathbf{n} v \\, ds = \\int_{\\Omega} f v \\, dx \\] <p>With \\(v = 0\\) on \\(\\partial \\Omega\\), the boundary integral vanishes, giving us the weak form:</p> \\[ \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx + \\int_{\\Omega} kuv \\, dx = \\int_{\\Omega} f v \\, dx \\]"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#problem-setup","title":"Problem Setup","text":"<p>In this example, we solve the Helmholtz equation with the following exact solution:</p> \\[ u(x,y) = (x + y)\\sin(\\pi x)\\sin(\\pi y) \\]"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#key-parameters","title":"Key Parameters","text":""},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#geometry-parameters","title":"Geometry Parameters:","text":"<ul> <li>Mesh type: Quadrilateral</li> <li>Domain: \\([0,1] \\times [0,1]\\)</li> <li>Cells: \\(2\\times2\\) grid</li> <li>Boundary points: 400</li> <li>Test points: \\(100\\times100\\) grid</li> </ul>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#finite-element-parameters","title":"Finite Element Parameters:","text":"<ul> <li>Order: 6 (Legendre)</li> <li>Quadrature: Gauss-Jacobi (order 10)</li> <li>Transformation: Bilinear</li> </ul>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#neural-network-parameters","title":"Neural Network Parameters:","text":"<ul> <li>Architecture: \\([2, 30, 30, 30, 1]\\)</li> <li>Activation: \\(\\tanh\\)</li> <li>Learning rate: 0.002</li> <li>Boundary loss penalty (\\(\\beta\\)): 10</li> <li>Training epochs: 20,000</li> </ul>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#boundary-conditions","title":"Boundary Conditions","text":"<p>The boundary conditions are implemented through four functions defining values on each boundary:</p> <pre><code>def left_boundary(x, y):\n    return (x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef right_boundary(x, y):\n    return (x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef top_boundary(x, y):\n    return (x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef bottom_boundary(x, y):\n    return (x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n### Source Term\n\nThe source term f(x,y) is derived through the method of manufactured solutions:\n\n```python\ndef rhs(x, y):\n    term1 = 2 * np.pi * np.cos(np.pi * y) * np.sin(np.pi * x)\n    term2 = 2 * np.pi * np.cos(np.pi * x) * np.sin(np.pi * y)\n    term3 = (x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n    term4 = -2 * (np.pi**2) * (x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n    return term1 + term2 + term3 + term4\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Mesh Generation:</li> <li>Create a 2\u00d72 quadrilateral mesh</li> <li>Generate boundary points</li> <li> <p>Set up test points for solution evaluation</p> </li> <li> <p>Finite Element Space:</p> </li> <li>Define Legendre basis functions</li> <li>Set up quadrature rules</li> <li> <p>Configure boundary conditions</p> </li> <li> <p>Neural Network Model:</p> </li> <li>Create a dense neural network with 3 hidden layers</li> <li>Configure the Helmholtz loss function</li> <li> <p>Set up the training parameters</p> </li> <li> <p>Training Process:</p> </li> <li>Train for 20,000 epochs</li> <li>Track loss and timing metrics</li> <li> <p>Evaluate solution accuracy</p> </li> <li> <p>Visualization and Analysis:</p> </li> <li>Plot training loss</li> <li>Compare exact and predicted solutions</li> <li>Generate error plots</li> <li>Calculate error metrics (L2, L1, L\u221e norms)</li> </ol>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#key-differences-from-poisson-problem","title":"Key Differences from Poisson Problem","text":"<ol> <li>PDE Structure:</li> <li>Addition of the ku term</li> <li>Modified variational form</li> <li> <p>Different source term computation</p> </li> <li> <p>Loss Function:</p> </li> <li>Uses <code>pde_loss_helmholtz</code> instead of <code>pde_loss_poisson</code></li> <li> <p>Includes Helmholtz coefficient in bilinear parameters</p> </li> <li> <p>Boundary Conditions:</p> </li> <li>Non-zero Dirichlet conditions</li> <li>More complex boundary value functions</li> </ol>"},{"location":"api/core/examples/sciml/fastvpinns/example_helmholtz2d/#results-analysis","title":"Results Analysis","text":"<p>The implementation generates four key visualizations: 1. Training loss convergence 2. Exact solution contour 3. Predicted solution contour 4. Absolute error distribution</p> <p>Error metrics are computed in various norms: - L2 norm (global accuracy) - L1 norm (average absolute error) - L\u221e norm (maximum error) - Relative versions of each norm</p> <p>These metrics help assess the solution quality and convergence characteristics of the method.</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/","title":"example poisson2d","text":""},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#fastvpinns-training-tutorial-poisson-problem","title":"FastVPINNs - Training Tutorial - Poisson Problem","text":"<p>In this notebook, we will try to understand, how to write FastVPINNs using Custom loss functions and custom neural networks.</p> <p>Author : Thivin Anandh Linkedin GitHub Portfolio</p> <p>Paper: FastVPINNs: Tensor-driven acceleration of VPINNs for complex geometries</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-hp-variational-physics-informed-neural-networks-hp-vpinns","title":"hp-Variational Physics-Informed Neural Networks (hp-VPINNs)","text":"<p>Variational Physics-Informed Neural Networks (VPINNs) are a special class of Physics-Informed Neural Networks (PINNs) that are trained using the variational formulation of the governing equations. Variational formulation us used in conventional numerical methods like Finite Element Method (FEM) to solve Partial Differential Equations (PDEs). hp-VPINNs are a special class of VPINNs that uses the concepts of hp-FEM such as h- and p-refinement to improve the accuracy of the solution. h-refinement is the process of refining the mesh size, whereas p-refinement is the process of increasing the order of the basis functions. For more information, please refer the paper by Kharazmi et al. (2021) here.</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-mathematical-formulation","title":"Mathematical Formulation","text":"<p>Lets consider the 2D Poisson equation as an example. The Poisson equation is given by</p> \\[ \\nabla^2 u = f \\] <p>where \\(u\\) is the solution, \\(f\\) is the source term and \\(\\nabla^2\\) is the Laplacian operator. Now, in order to get the weak form of the Poisson equation, we multiply the equation by a test function \\(v\\) and integrate over the domain \\(\\Omega\\).</p> \\[ \\int_{\\Omega} \\nabla^2 u v \\, dx = \\int_{\\Omega} f v \\, dx \\] <p>Now, lets apply integration by parts to the left hand side of the equation to get the weak form of the Poisson equation.</p> \\[ \\int_{\\Omega} \\nabla^2 u v \\, dx = -\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx + \\int_{\\partial \\Omega} \\nabla u \\cdot n v \\, ds \\] <p>where \\(n\\) is the normal vector to the boundary \\(\\partial \\Omega\\). The function \\(v\\) is choosen such that \\(v = 0\\) on the boundary \\(\\partial \\Omega\\). Therefore, the boundary integral term becomes zero. Hence, the weak form of the Poisson equation is given by</p> <p>$$</p> <p>\\int_{\\Omega} \\nabla u \\cdot \\nabla v , dx = \\int_{\\Omega} f v , dx $$</p> <p>Now, we can write the above equation in the variational form as</p> \\[ \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx - \\int_{\\Omega} f v \\, dx = 0 \\] <p>with the dirichlet boundary condition \\(u = g\\) on the boundary \\(\\partial \\Omega\\).</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-imports","title":"## Imports","text":"<p>Lets import the necessary functions for this tutorial from the FastVPINNs library.</p> <pre><code># Common library imports \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nimport tensorflow as tf\nimport time\nfrom tqdm import tqdm\n\n# Fastvpinns Modules\nfrom fastvpinns.geometry.geometry_2d import Geometry_2D\nfrom fastvpinns.fe.fespace2d import Fespace2D\nfrom fastvpinns.data.datahandler2d import DataHandler2D\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-setting-up-problem-parameters","title":"## Setting up Problem Parameters","text":"<p>In this section, we will setup all the parameters related to the Poisson problem such as Geometries, Test Function spaces, Neural Network Architectures, Learning Rates Etc</p> <p>For Additional information on all Parameters , please refer the documentation here</p>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#geometry-parameters","title":"Geometry Parameters","text":"<ul> <li>i_mesh_type : Type of mesh elements</li> <li>i_mesh_generation_method: Internal mesh generation or external mesh</li> <li>i_n_test_points_x: Number of test points in x direction</li> <li>i_n_test_points_y: Number of test points in y direction</li> <li>i_output_path: Output path for the results</li> <li>i_x_min: Minimum value of x</li> <li>i_x_max: Maximum value of x</li> <li>i_y_min: Minimum value of y</li> <li>i_y_max: Maximum value of y</li> <li>i_n_cells_x: Number of cells in x direction</li> <li>i_n_cells_y: Number of cells in y direction</li> <li>i_n_boundary_points: Number of boundary points</li> </ul>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#finite-element-parameters","title":"Finite Element Parameters","text":"<ul> <li>i_fe_order: Order of the finite element basis functions</li> <li>i_fe_type: Type of the finite element basis functions</li> <li>i_quad_order: Order of the quadrature rule</li> <li>i_quad_type: Name of the quadrature rule</li> <li>i_fe_transform: Bilinear or Affine transformation</li> </ul>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#neural-network-parameters","title":"Neural Network Parameters","text":"<ul> <li>i_learning_rate_dict: Dictionary containing the learning rates for     the neural networks</li> <li>i_data_type: Data type float32 or float64</li> <li>i_activation: Activation function for the neural networks</li> </ul> <pre><code>i_mesh_type = \"quadrilateral\" # \"quadrilateral\"\ni_mesh_generation_method = \"internal\" # \"internal\" or \"external\"\ni_x_min = 0 # minimum x value\ni_x_max = 1 # maximum x value\ni_y_min = 0 # minimum y value\ni_y_max = 1 # maximum y value\ni_n_cells_x = 2 # Number of cells in the x direction\ni_n_cells_y = 2 # Number of cells in the y direction\ni_n_boundary_points = 400 # Number of points on the boundary\ni_output_path = \"output/poisson_2d\" # Output path\n\ni_n_test_points_x = 100 # Number of test points in the x direction\ni_n_test_points_y = 100 # Number of test points in the y direction\n\n# fe Variables\ni_fe_order = 6 # Order of the finite element space\ni_fe_type = \"legendre\"\ni_quad_order = 10 # 10 points in 1D, so 100 points in 2D for one cell\ni_quad_type = \"gauss-jacobi\"\n\n# Neural Network Variables\ni_learning_rate_dict = {\n    \"initial_learning_rate\" : 0.001, # Initial learning rate\n    \"use_lr_scheduler\" : False, # Use learning rate scheduler\n    \"decay_steps\": 1000, # Decay steps\n    \"decay_rate\": 0.96, # Decay rate\n    \"staircase\": True, # Staircase Decay\n}\n\ni_dtype = tf.float32\ni_activation = \"tanh\"\ni_beta = 10 # Boundary Loss Penalty ( Adds more weight to the boundary loss)\n\n# Epochs\ni_num_epochs = 20000\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-setting-up-boundary-conditions-and-boundary-values","title":"## Setting up Boundary Conditions and Boundary Values","text":"<p>In this section, we will setup the boundary conditions and boundary values for the Poisson problem. lets take an example, where the exact solution of the problem is given by</p> \\[ u(x,y) =-1.0 \\sin(2.0  \\pi x) \\sin(2.0 \\pi y) \\] <p>The values of \\(u\\) will be \\(0\\) on the boundary \\(\\partial \\Omega\\). The source term \\(f\\) ( from method of manufactured solutions) is given by</p> \\[ f(x,y) = -2(2.0\\pi)^2 \\sin(2.0\\pi x) \\sin(2.0\\pi y) \\] <p>As per internal mesh generation, the boundary points are generated automatically.Further, the bottom boundary is assigned a tag of 1000, right boundary is assigned a tag of 1001, top boundary is assigned a tag of 1002 and left boundary is assigned a tag of 1003. The boundary conditions are given as follows</p> <p>Currently, this library supports only Dirichlet Boundary Conditions. the Development branches of these versions have Neumann Boundary Conditions.</p> <pre><code>def left_boundary(x, y):\n    \"\"\"\n    This function will return the boundary value for given component of a boundary\n    \"\"\"\n    val = 0.0\n    return np.ones_like(x) * val\n\n\ndef right_boundary(x, y):\n    \"\"\"\n    This function will return the boundary value for given component of a boundary\n    \"\"\"\n    val = 0.0\n    return np.ones_like(x) * val\n\n\ndef top_boundary(x, y):\n    \"\"\"\n    This function will return the boundary value for given component of a boundary\n    \"\"\"\n    val = 0.0\n    return np.ones_like(x) * val\n\n\ndef bottom_boundary(x, y):\n    \"\"\"\n    This function will return the boundary value for given component of a boundary\n    \"\"\"\n    val = 0.0\n    return np.ones_like(x) * val\n\n\ndef rhs(x, y):\n    \"\"\"\n    This function will return the value of the rhs at a given point\n    \"\"\"\n    omegaX = 2.0 * np.pi\n    omegaY = 2.0 * np.pi\n    f_temp = -2.0 * (omegaX**2) * (np.sin(omegaX * x) * np.sin(omegaY * y))\n\n    return f_temp\n\n\ndef exact_solution(x, y):\n    \"\"\"\n    This function will return the exact solution at a given point\n    \"\"\"\n    # If the exact Solution does not have an analytical expression, leave the value as 0(zero)\n    # it can be set using `np.ones_like(x) * 0.0` and then ignore the errors and the error plots generated.\n\n    omegaX = 2.0 * np.pi\n    omegaY = 2.0 * np.pi\n    val = -1.0 * np.sin(omegaX * x) * np.sin(omegaY * y)\n\n    return val\n\n\ndef get_boundary_function_dict():\n    \"\"\"\n    This function will return a dictionary of boundary functions\n    \"\"\"\n    return {1000: bottom_boundary, 1001: right_boundary, 1002: top_boundary, 1003: left_boundary}\n\n\ndef get_bound_cond_dict():\n    \"\"\"\n    This function will return a dictionary of boundary conditions\n    \"\"\"\n    return {1000: \"dirichlet\", 1001: \"dirichlet\", 1002: \"dirichlet\", 1003: \"dirichlet\"}\n\n\ndef get_bilinear_params_dict():\n    \"\"\"\n    This function will return a dictionary of bilinear parameters\n    \"\"\"\n    eps = 1.0\n\n    return {\"eps\": eps}\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-create-an-output-folder","title":"Create an Output Folder","text":"<pre><code>## CREATE OUTPUT FOLDER\n# use pathlib to create the folder,if it does not exist\nfolder = Path(i_output_path)\n# create the folder if it does not exist\nif not folder.exists():\n    folder.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#obtain-the-boundary-conditions-and-boundary-values","title":"Obtain the Boundary conditions and Boundary values","text":"<pre><code># get the boundary function dictionary from example file\nbound_function_dict, bound_condition_dict = get_boundary_function_dict(), get_bound_cond_dict()\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#generate-internal-mesh","title":"Generate internal mesh","text":"<p>This calls the geometry module to generate the internal mesh and set up all cell and boundary information.</p> <pre><code># Initiate a Geometry_2D object\ndomain = Geometry_2D(\n    i_mesh_type, i_mesh_generation_method, i_n_test_points_x, i_n_test_points_y, i_output_path\n)\n\n# load the mesh\ncells, boundary_points = domain.generate_quad_mesh_internal(\n    x_limits=[i_x_min, i_x_max],\n    y_limits=[i_y_min, i_y_max],\n    n_cells_x=i_n_cells_x,\n    n_cells_y=i_n_cells_y,\n    num_boundary_points=i_n_boundary_points,\n)\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#generate-fe-space","title":"Generate fe Space","text":"<p>This module is the core module of the library. It generates the finite element space and sets up the basis functions and quadrature rules. It preassembles the test function matrices for each cell and assigns boundary values to the boundary points.</p> <pre><code>fespace = Fespace2D(\n        mesh=domain.mesh,\n        cells=cells,\n        boundary_points=boundary_points,\n        cell_type=domain.mesh_type,\n        fe_order=i_fe_order,\n        fe_type=i_fe_type,\n        quad_order=i_quad_order,\n        quad_type=i_quad_type,\n        fe_transformation_type=\"bilinear\",\n        bound_function_dict=bound_function_dict,\n        bound_condition_dict=bound_condition_dict,\n        forcing_function=rhs,\n        output_path=i_output_path,\n        generate_mesh_plot=True,\n    )\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#datahandler","title":"Datahandler","text":"<p>This module is used to convert the data into tensorflow datasets. It also contains functions which assemble the test function and other values into tensor format, which will be used for training</p> <pre><code># instantiate data handler\ndatahandler = DataHandler2D(fespace, domain, dtype=i_dtype)\n\nparams_dict = {}\nparams_dict['n_cells'] = fespace.n_cells\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-model","title":"Model","text":"<p>In this section, we will use the neural Network module available within the FastVPINNs library to create and train the neural networks. They can be imported from the \\\"model\\\" module of fastvpinns.</p> <pre><code>fastvpinns.model.model import DenseModel\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-loss-function","title":"Loss Function","text":"<p>The tensor based variational loss formulation for most of scalar problems can be imported from \\\"physics\\\" modules.</p> <pre><code>from fastvpinns.physics.poisson2d import pde_loss_poisson\n</code></pre> <pre><code>from fastvpinns.model.model import DenseModel\nfrom fastvpinns.physics.poisson2d import pde_loss_poisson\n\nparams_dict = {}\nparams_dict['n_cells'] = fespace.n_cells\n\n# get the input data for the PDE\ntrain_dirichlet_input, train_dirichlet_output = datahandler.get_dirichlet_input()\n\n# get bilinear parameters\n# this function will obtain the values of the bilinear parameters from the model\n# and convert them into tensors of desired dtype\nbilinear_params_dict = datahandler.get_bilinear_params_dict_as_tensors(get_bilinear_params_dict)\n\nmodel = DenseModel(\n    layer_dims=[2, 30, 30, 30, 1],\n    learning_rate_dict=i_learning_rate_dict,\n    params_dict=params_dict,\n    loss_function=pde_loss_poisson,\n    input_tensors_list=[datahandler.x_pde_list, train_dirichlet_input, train_dirichlet_output],\n    orig_factor_matrices=[\n        datahandler.shape_val_mat_list,\n        datahandler.grad_x_mat_list,\n        datahandler.grad_y_mat_list,\n    ],\n    force_function_list=datahandler.forcing_function_list,\n    tensor_dtype=i_dtype,\n    activation=i_activation,\n)\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-train-the-model","title":"Train the model","text":"<p>Now, we will train the model to solve the Poisson problem using the custom loss function and custom neural network model.</p> <pre><code>loss_array = []  # total loss\ntime_array = []  # time taken for each epoch\n\n\nfor epoch in tqdm(range(i_num_epochs)):\n        # Train the model\n        batch_start_time = time.time()\n        loss = model.train_step(beta=i_beta, bilinear_params_dict=bilinear_params_dict)\n        elapsed = time.time() - batch_start_time\n\n        # print(elapsed)\n        time_array.append(elapsed)\n\n        loss_array.append(loss['loss'])\n</code></pre>"},{"location":"api/core/examples/sciml/fastvpinns/example_poisson2d/#-visualise-loss-and-results","title":"Visualise loss and Results","text":"<pre><code># predict the values for the test points\ntest_points = domain.get_test_points()\nprint(f\"[bold]Number of Test Points = [/bold] {test_points.shape[0]}\")\ny_exact = exact_solution(test_points[:, 0], test_points[:, 1])\n\n# Get predicted values from the model\ny_pred = model(test_points).numpy()\ny_pred = y_pred.reshape(-1)\n\n# compute the error\nerror = np.abs(y_exact - y_pred)\n\n# plot a 2x2 Grid, loss plot, exact solution, predicted solution and error\nfig, axs = plt.subplots(2, 2, figsize=(10, 8))\n\n# loss plot\naxs[0, 0].plot(loss_array)\naxs[0, 0].set_title(\"Loss Plot\")\naxs[0, 0].set_xlabel(\"Epochs\")\naxs[0, 0].set_ylabel(\"Loss\")\naxs[0, 0].set_yscale(\"log\")\n\n# exact solution\n# contour plot of the exact solution\naxs[0, 1].tricontourf(test_points[:, 0], test_points[:, 1], y_exact, 100)\naxs[0, 1].set_title(\"Exact Solution\")\naxs[0, 1].set_xlabel(\"x\")\naxs[0, 1].set_ylabel(\"y\")\n# add colorbar\ncbar = plt.colorbar(axs[0, 1].collections[0], ax=axs[0, 1])\n\n\n# predicted solution\n# contour plot of the predicted solution\naxs[1, 0].tricontourf(test_points[:, 0], test_points[:, 1], y_pred, 100)\naxs[1, 0].set_title(\"Predicted Solution\")\naxs[1, 0].set_xlabel(\"x\")\naxs[1, 0].set_ylabel(\"y\")\n# add colorbar\ncbar = plt.colorbar(axs[1, 0].collections[0], ax=axs[1, 0])\n\n# error plot\n# contour plot of the error\naxs[1, 1].tricontourf(test_points[:, 0], test_points[:, 1], error, 100)\naxs[1, 1].set_title(\"Error\")\naxs[1, 1].set_xlabel(\"x\")\naxs[1, 1].set_ylabel(\"y\")\n# add colorbar\ncbar = plt.colorbar(axs[1, 1].collections[0], ax=axs[1, 1])\n\n\nplt.tight_layout()\n\n\n# print error statistics\nl2_error = np.sqrt(np.mean(error ** 2))\nl1_error = np.mean(np.abs(error))\nl_inf_error = np.max(np.abs(error))\nrel_l2_error = l2_error / np.sqrt(np.mean(y_exact ** 2))\nrel_l1_error = l1_error / np.mean(np.abs(y_exact))\nrel_l_inf_error = l_inf_error / np.max(np.abs(y_exact))\n\n# print the error statistics in a formatted table\nerror_df = pd.DataFrame(\n    {\n        \"L2 Error\": [l2_error],\n        \"L1 Error\": [l1_error],\n        \"L_inf Error\": [l_inf_error],\n        \"Relative L2 Error\": [rel_l2_error],\n        \"Relative L1 Error\": [rel_l1_error],\n        \"Relative L_inf Error\": [rel_l_inf_error],\n    }\n)\nprint(error_df)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/","title":"Fourier Neural Operator (FNO) - Training Tutorial - 1D Advection Problem","text":""},{"location":"api/core/examples/sciml/fno/example_advection/#overview","title":"Overview","text":"<p>This tutorial demonstrates implementing a Fourier Neural Operator (FNO) to solve the 1D advection equation using JAX and Equinox.</p>"},{"location":"api/core/examples/sciml/fno/example_advection/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>The 1D advection equation:</p> \\[ \\frac{\\partial u}{\\partial t} + v\\frac{\\partial u}{\\partial x} = 0 \\] <p>where: - \\(u(x,t)\\): solution (wave amplitude) - \\(v\\): wave velocity - \\(x\\): spatial coordinate - \\(t\\): time</p>"},{"location":"api/core/examples/sciml/fno/example_advection/#initial-and-boundary-conditions","title":"Initial and Boundary Conditions","text":"<ul> <li>Initial condition: \\(u(x,0) = u_0(x)\\)</li> <li>Periodic boundary conditions: \\(u(0,t) = u(2\\pi,t)\\)</li> </ul>"},{"location":"api/core/examples/sciml/fno/example_advection/#implementation-parameters","title":"Implementation Parameters","text":""},{"location":"api/core/examples/sciml/fno/example_advection/#domain-parameters","title":"Domain Parameters","text":"<pre><code>nx = 64  # Spatial resolution\nnt = 100  # Temporal resolution\nL = 2 * \u03c0  # Domain length\nT = 2.0  # Final time\nv = 1.0  # Wave velocity\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#dataset-parameters","title":"Dataset Parameters","text":"<pre><code>n_samples = 1200  # Total samples\ntrain_samples = 1000\ntest_samples = 200\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#fno-architecture","title":"FNO Architecture","text":"<pre><code>model = FNO1d(\n    in_channels=2,\n    out_channels=1,\n    modes=16,\n    width=64,\n    activation=jax.nn.gelu,\n    n_blocks=4\n)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#code-components","title":"Code Components","text":""},{"location":"api/core/examples/sciml/fno/example_advection/#data-generation","title":"Data Generation","text":"<pre><code>def generate_advection_data(n_samples=1200, nx=64, nt=100, v=1.0):\n    \"\"\"Generate data for the 1D advection equation\"\"\"\n    # Domain setup\n    L = 2 * jnp.pi\n    dx = L / nx\n    x = jnp.linspace(0, L, nx)\n\n    # Time domain\n    T = 2.0\n    dt = T / nt\n    t = jnp.linspace(0, T, nt)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#initial-condition-generator","title":"Initial Condition Generator","text":"<pre><code>def generate_initial_condition(key):\n    \"\"\"Generate random sinusoidal initial conditions\"\"\"\n    k1, k2 = jax.random.split(key)\n    n_waves = 3\n    amplitudes = jax.random.uniform(k1, (n_waves,), minval=0.1, maxval=1.0)\n    frequencies = jax.random.randint(k2, (n_waves,), minval=1, maxval=4)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#advection-solver","title":"Advection Solver","text":"<pre><code>def solve_advection(u0):\n    \"\"\"Solve using upwind scheme\"\"\"\n    u = jnp.zeros((nt, nx))\n    u = u.at[0].set(u0)\n\n    for n in range(1, nt):\n        if v &gt; 0:\n            u = u.at[n].set(\n                u[n-1] - v * dt/dx * (u[n-1] - jnp.roll(u[n-1], 1))\n            )\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#training-loop","title":"Training Loop","text":"<pre><code>@eqx.filter_jit\ndef make_step(model, opt_state, batch):\n    \"\"\"Single training step\"\"\"\n    def loss_fn(model):\n        pred = jax.vmap(model)(batch[0])\n        return jnp.mean((pred - batch[1])**2)\n\n    loss, grads = eqx.filter_value_and_grad(loss_fn)(model)\n    updates, opt_state = optimizer.update(grads, opt_state, model)\n    model = eqx.apply_updates(model, updates)\n    return loss, model, opt_state\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#results-visualization","title":"Results Visualization","text":"<pre><code># Example prediction\nplt.figure()\nplt.plot(spatial_grid, test_x[0, 0], label='Initial condition')\nplt.plot(spatial_grid, test_y[0, 0], label='True solution')\nplt.plot(spatial_grid, test_pred[0, 0], '--', label='FNO prediction')\n\n# Training loss\nplt.figure()\nplt.semilogy(losses)\n\n# Error analysis\nplt.figure()\nplt.plot(spatial_grid, jnp.abs(test_pred[0, 0] - test_y[0, 0]))\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_advection/#output-structure","title":"Output Structure","text":"<pre><code>outputs/fno/advection/\n\u251c\u2500\u2500 advection_example.png\n\u251c\u2500\u2500 advection_loss.png\n\u2514\u2500\u2500 advection_error.png\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/","title":"Fourier Neural Operator (FNO) - Training Tutorial - Burgers Equation","text":""},{"location":"api/core/examples/sciml/fno/example_burgers/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>The 1D Burgers equation:</p> \\[ \\frac{\\partial u}{\\partial t} + u\\frac{\\partial u}{\\partial x} = \\nu\\frac{\\partial^2 u}{\\partial x^2} \\] <p>where: - \\(u(x,t)\\): velocity field - \\(\\nu\\): viscosity coefficient - \\(x\\): spatial coordinate - \\(t\\): time</p>"},{"location":"api/core/examples/sciml/fno/example_burgers/#implementation-parameters","title":"Implementation Parameters","text":""},{"location":"api/core/examples/sciml/fno/example_burgers/#domain-parameters","title":"Domain Parameters","text":"<pre><code>x_domain = [0, 2\u03c0]\nspatial_resolution = 8192  # Full resolution\ntraining_resolution = 256  # Subsampled for training\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#dataset-parameters","title":"Dataset Parameters","text":"<pre><code>train_samples = 1000\ntest_samples = 200\nbatch_size = 100\nepochs = 200\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#fno-architecture","title":"FNO Architecture","text":"<pre><code>fno = FNO1d(\n    in_channels=2,    # Initial condition + spatial coordinate\n    out_channels=1,   # Solution at t=1\n    modes=16,         # Number of Fourier modes\n    width=64,         # Channel width\n    activation=jax.nn.relu,\n    n_blocks=4\n)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#implementation-steps","title":"Implementation Steps","text":""},{"location":"api/core/examples/sciml/fno/example_burgers/#1-data-loading","title":"1. Data Loading","text":"<pre><code>data = scipy.io.loadmat(\"burgers_data_R10.mat\")\na, u = data[\"a\"], data[\"u\"]  # Initial conditions and solutions\n\n# Add channel dimension and mesh\na = a[:, jnp.newaxis, :]\nu = u[:, jnp.newaxis, :]\nmesh = jnp.linspace(0, 2 * jnp.pi, u.shape[-1])\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#2-data-preprocessing","title":"2. Data Preprocessing","text":"<pre><code># Combine initial condition with mesh information\nmesh_shape_corrected = jnp.repeat(mesh[jnp.newaxis, jnp.newaxis, :], u.shape[0], axis=0)\na_with_mesh = jnp.concatenate((a, mesh_shape_corrected), axis=1)\n\n# Train-test split\ntrain_x, test_x = a_with_mesh[:1000], a_with_mesh[1000:1200]\ntrain_y, test_y = u[:1000], u[1000:1200]\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#3-training-loop","title":"3. Training Loop","text":"<pre><code>@eqx.filter_jit\ndef make_step(model, state, x, y):\n    loss, grad = eqx.filter_value_and_grad(loss_fn)(model, x, y)\n    val_loss = loss_fn(model, test_x[..., ::32], test_y[..., ::32])\n    updates, new_state = optimizer.update(grad, state, model)\n    new_model = eqx.apply_updates(model, updates)\n    return new_model, new_state, loss, val_loss\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#4-evaluation-metrics","title":"4. Evaluation Metrics","text":"<pre><code>def relative_l2_norm(pred, ref):\n    diff_norm = jnp.linalg.norm(pred - ref)\n    ref_norm = jnp.linalg.norm(ref)\n    return diff_norm / ref_norm\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_burgers/#results-analysis","title":"Results Analysis","text":"<p>The implementation generates five visualizations:</p> <ol> <li><code>initial_vs_after.png</code>: Initial condition vs solution at t=1</li> <li><code>loss.png</code>: Training and validation loss curves</li> <li><code>prediction.png</code>: Model prediction vs ground truth</li> <li><code>difference.png</code>: Error analysis</li> <li><code>superresolution.png</code>: Zero-shot superresolution capability</li> </ol>"},{"location":"api/core/examples/sciml/fno/example_burgers/#key-performance-metrics","title":"Key Performance Metrics","text":"<ul> <li>Relative L2 error: ~1e-2</li> <li>Training time: 200 epochs</li> <li>Resolution invariance demonstrated through superresolution</li> </ul>"},{"location":"api/core/examples/sciml/fno/example_burgers/#output-directory-structure","title":"Output Directory Structure","text":"<pre><code>outputs/fno/burgers/\n\u251c\u2500\u2500 initial_vs_after.png\n\u251c\u2500\u2500 loss.png\n\u251c\u2500\u2500 prediction.png\n\u251c\u2500\u2500 difference.png\n\u2514\u2500\u2500 superresolution.png\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/","title":"Fourier Neural Operator (FNO) - Training Tutorial - Heat Equation","text":""},{"location":"api/core/examples/sciml/fno/example_heat/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>The heat equation:</p> \\[ \\frac{\\partial u}{\\partial t} = D\\frac{\\partial^2 u}{\\partial x^2} \\] <p>where: - \\(u(x,t)\\): temperature field - \\(D\\): thermal diffusivity - \\(x\\): spatial coordinate - \\(t\\): time</p>"},{"location":"api/core/examples/sciml/fno/example_heat/#implementation-parameters","title":"Implementation Parameters","text":""},{"location":"api/core/examples/sciml/fno/example_heat/#domain-parameters","title":"Domain Parameters","text":"<pre><code>nx = 64  # Spatial points\nnt = 100  # Time steps\nL = 2\u03c0  # Domain length\nT = 1.0  # Final time\nD = 0.1  # Diffusion coefficient\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/#dataset-parameters","title":"Dataset Parameters","text":"<pre><code>n_samples = 1200\ntrain_samples = 1000\ntest_samples = 200\nbatch_size = 50\nepochs = 50\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/#fno-architecture","title":"FNO Architecture","text":"<pre><code>model = FNO1d(\n    in_channels=2,  # Initial temperature + spatial coordinate\n    out_channels=1,  # Final temperature\n    modes=16,\n    width=64,\n    activation=jax.nn.gelu,\n    n_blocks=4\n)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/#code-components","title":"Code Components","text":""},{"location":"api/core/examples/sciml/fno/example_heat/#initial-condition-generator","title":"Initial Condition Generator","text":"<pre><code>def generate_initial_condition(key):\n    \"\"\"Generate random Gaussian pulses\"\"\"\n    max_pulses = 3\n    positions = jax.random.uniform(k1, (max_pulses,)) * L\n    widths = jax.random.uniform(k2, (max_pulses,)) * 0.2 + 0.1\n    amplitudes = jax.random.uniform(k3, (max_pulses,)) * 0.8 + 0.2\n\n    u0 = jnp.zeros(nx)\n    for pos, width, amp in zip(positions, widths, amplitudes):\n        u0 += amp * jnp.exp(-(x - pos)**2 / (2 * width**2))\n    return u0\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/#heat-equation-solver","title":"Heat Equation Solver","text":"<pre><code>def solve_heat_equation(u0):\n    \"\"\"Solve using explicit finite differences\"\"\"\n    u = jnp.zeros((nt, nx))\n    u = u.at[0].set(u0)\n\n    for n in range(1, nt):\n        u = u.at[n].set(\n            u[n-1] + D * dt/dx**2 * (\n                jnp.roll(u[n-1], 1) - 2*u[n-1] + jnp.roll(u[n-1], -1)\n            )\n        )\n    return u\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/#training-loop","title":"Training Loop","text":"<pre><code>@eqx.filter_jit\ndef make_step(model, opt_state, batch):\n    def loss_fn(model):\n        pred = jax.vmap(model)(batch[0])\n        return jnp.mean((pred - batch[1])**2)\n\n    loss, grads = eqx.filter_value_and_grad(loss_fn)(model)\n    updates, opt_state = optimizer.update(grads, opt_state, model)\n    model = eqx.apply_updates(model, updates)\n    return loss, model, opt_state\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_heat/#results-analysis","title":"Results Analysis","text":"<p>The implementation generates three visualizations:</p> <ol> <li><code>example_prediction.png</code>:</li> <li>Initial temperature profile</li> <li>True solution at final time</li> <li> <p>FNO prediction</p> </li> <li> <p><code>training_loss.png</code>:</p> </li> <li>MSE loss over training steps</li> <li> <p>Log-scale visualization</p> </li> <li> <p><code>absolute_error.png</code>:</p> </li> <li>Point-wise absolute error</li> <li>Error distribution analysis</li> </ol>"},{"location":"api/core/examples/sciml/fno/example_heat/#output-structure","title":"Output Structure","text":"<pre><code>outputs/fno/heat/\n\u251c\u2500\u2500 example_prediction.png\n\u251c\u2500\u2500 training_loss.png\n\u2514\u2500\u2500 absolute_error.png\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/","title":"Fourier Neural Operator (FNO) - Wave Equation Tutorial","text":""},{"location":"api/core/examples/sciml/fno/example_wave/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>The wave equation:</p> \\[ \\frac{\\partial^2 u}{\\partial t^2} = c^2\\frac{\\partial^2 u}{\\partial x^2} \\] <p>where: - \\(u(x,t)\\): displacement field - \\(c\\): wave speed - \\(x\\): spatial coordinate - \\(t\\): time</p>"},{"location":"api/core/examples/sciml/fno/example_wave/#parameters","title":"Parameters","text":""},{"location":"api/core/examples/sciml/fno/example_wave/#domain-parameters","title":"Domain Parameters","text":"<pre><code>nx = 64  # Spatial points\nnt = 100  # Time steps\nL = 2\u03c0  # Domain length\nT = 2.0  # Final time\nc = 1.0  # Wave speed\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/#architecture-parameters","title":"Architecture Parameters","text":"<pre><code>model = FNO1d(\n    in_channels=3,  # Initial displacement + velocity + coordinate\n    out_channels=1,  # Final displacement\n    modes=16,\n    width=64,\n    activation=jax.nn.gelu,\n    n_blocks=4\n)\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/#implementation","title":"Implementation","text":""},{"location":"api/core/examples/sciml/fno/example_wave/#initial-conditions-generator","title":"Initial Conditions Generator","text":"<pre><code>def generate_initial_conditions(key):\n    # Initial displacement (Gaussian pulses)\n    max_pulses = 2\n    positions = jax.random.uniform(k1, (max_pulses,)) * L\n    widths = jax.random.uniform(k2, (max_pulses,)) * 0.2 + 0.1\n    amplitudes = jax.random.uniform(k3, (max_pulses,)) * 0.8 + 0.2\n\n    # Initial velocity (smoothed random)\n    v0 = jax.random.normal(k4, (nx,)) * 0.1\n    v0 = jnp.convolve(v0, jnp.ones(10)/10, mode='same')\n\n    return u0, v0\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/#wave-equation-solver","title":"Wave Equation Solver","text":"<pre><code>def solve_wave_equation(init_conditions):\n    \"\"\"Central differences scheme\"\"\"\n    u0, v0 = init_conditions\n    u = jnp.zeros((nt, nx))\n    u = u.at[0].set(u0)\n    u = u.at[1].set(u0 + dt * v0)\n\n    for n in range(2, nt):\n        u = u.at[n].set(\n            2 * u[n-1] - u[n-2] + \n            (c * dt/dx)**2 * (\n                jnp.roll(u[n-1], 1) - 2*u[n-1] + jnp.roll(u[n-1], -1)\n            )\n        )\n    return u\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/#training-loop","title":"Training Loop","text":"<pre><code>@eqx.filter_jit\ndef make_step(model, opt_state, batch):\n    def loss_fn(model):\n        pred = jax.vmap(model)(batch[0])\n        return jnp.mean((pred - batch[1])**2)\n\n    loss, grads = eqx.filter_value_and_grad(loss_fn)(model)\n    updates, opt_state = optimizer.update(grads, opt_state, model)\n    model = eqx.apply_updates(model, updates)\n    return loss, model, opt_state\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/#output-visualization","title":"Output Visualization","text":"<pre><code>outputs/fno/wave/\n\u251c\u2500\u2500 example_prediction.png  # Initial conditions, true solution, prediction\n\u251c\u2500\u2500 training_loss.png      # MSE loss evolution\n\u2514\u2500\u2500 absolute_error.png     # Point-wise absolute error\n</code></pre>"},{"location":"api/core/examples/sciml/fno/example_wave/#key-metrics","title":"Key Metrics","text":"<ul> <li>MSE Loss tracking</li> <li>Test set error evaluation</li> <li>Point-wise error analysis</li> </ul>"},{"location":"api/core/examples/sciml/fno/example_wave/#features","title":"Features","text":"<ul> <li>Handles coupled initial conditions (displacement and velocity)</li> <li>Multi-component input processing</li> <li>Periodic boundary conditions</li> <li>Second-order accuracy in time and space</li> </ul>"},{"location":"api/core/ml/supervised/classification/base/","title":"base","text":"<p>Module: base.py</p> <p>This module provides the abstract base class for all classification algorithms in SciREX. It defines shared functionality for:     - Data preparation (loading from CSV and standard scaling)     - Classification performance metric computation (accuracy, precision, recall, f1-score)</p> <p>Classes:</p> Name Description <code>Classification</code> <p>Abstract base class that outlines common behavior for classification algorithms.</p> Dependencies <ul> <li>numpy, pandas, sklearn</li> <li>abc, pathlib, time, typing (for structural and type support)</li> </ul> Key Features <ul> <li>Consistent interface for loading and preparing data</li> <li>Standard approach to computing and returning classification metrics</li> <li>Enforces subclasses to implement <code>fit</code>, <code>predict</code>, and <code>get_model_params</code></li> </ul> Authors <ul> <li>Protyush P. Chowdhury (protyushc@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification","title":"<code>Classification</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for classification algorithms in the SciREX library.</p> This class provides <ul> <li>A consistent interface for loading and preparing data</li> <li>A standard approach to computing and returning classification metrics (accuracy, precision, recall, F1-score)</li> <li>A method for plotting confusion matrix for classification results</li> </ul> Subclasses must <ol> <li>Implement the <code>fit(X: np.ndarray, y: np.ndarray) -&gt; None</code> method, which should populate <code>self.model</code>.</li> <li>Implement the <code>get_model_params() -&gt; Dict[str, Any]</code> method, which returns a dict of model parameters for logging/debugging.</li> </ol> <p>Attributes:</p> Name Type Description <code>model_type</code> <code>str</code> <p>The name or identifier of the classification model (e.g., \"logistic_regression\", \"decision_tree\").</p> <code>random_state</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>model</code> <code>Optional</code> <p>The trained classification model.</p> <code>plots_dir</code> <code>Path</code> <p>Directory where confusion matrix plots will be saved.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>class Classification(ABC):\n    \"\"\"\n    Abstract base class for classification algorithms in the SciREX library.\n\n    This class provides:\n      - A consistent interface for loading and preparing data\n      - A standard approach to computing and returning classification metrics (accuracy, precision, recall, F1-score)\n      - A method for plotting confusion matrix for classification results\n\n    Subclasses must:\n      1. Implement the `fit(X: np.ndarray, y: np.ndarray) -&gt; None` method, which should populate `self.model`.\n      2. Implement the `get_model_params() -&gt; Dict[str, Any]` method, which returns a dict of model parameters for logging/debugging.\n\n    Attributes:\n        model_type (str): The name or identifier of the classification model (e.g., \"logistic_regression\", \"decision_tree\").\n        random_state (int): Random seed for reproducibility.\n        model (Optional): The trained classification model.\n        plots_dir (Path): Directory where confusion matrix plots will be saved.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_type: str,\n        random_state: int = 42,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the base classification class.\n\n        Args:\n            model_type (str): A string identifier for the classification algorithm\n                              (e.g. \"logistic_regression\", \"decision_tree\", etc.).\n            random_state (int, optional): Seed for reproducibility where applicable.\n                                          Defaults to 42.\n        \"\"\"\n        self.model_type = model_type\n        self.random_state = random_state\n\n        # Directory for saving plots\n        self.plots_dir = Path.cwd() / \"plots\"\n        self.plots_dir.mkdir(parents=True, exist_ok=True)\n\n        # Subclasses must set self.model after fitting\n        self.model: Optional[Any] = None\n\n    def prepare_data(self, path: str) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Load and preprocess data from a CSV file, returning features and labels.\n\n        This method:\n          1. Reads the CSV file into a pandas DataFrame.\n          2. Drops rows containing NaN values.\n          3. Selects only numeric columns from the DataFrame.\n          4. Scales the features using scikit-learn's StandardScaler.\n          5. Assumes the last column is the target label.\n\n        Args:\n            path (str): Filepath to the CSV data file.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]:\n                - Features dataset (X) of shape (n_samples, n_features).\n                - Labels (y) of shape (n_samples,).\n        \"\"\"\n        df = pd.read_csv(Path(path))\n        df = df.dropna()\n        numeric_columns = df.select_dtypes(include=[np.number]).columns\n        if numeric_columns.empty:\n            raise ValueError(\"No numeric columns found in the data.\")\n        X = df[numeric_columns].values\n        y = df[df.columns[-1]].values  # Assuming last column is the label\n        return StandardScaler().fit_transform(X), y\n\n    @abstractmethod\n    def fit(self, X: np.ndarray, y: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the classification model on the training dataset.\n\n        Args:\n            X (np.ndarray): A 2D array of shape (n_samples, n_features) containing the features.\n            y (np.ndarray): A 1D array of shape (n_samples,) containing the labels.\n\n        Subclasses must implement this method. After fitting the model,\n        `self.model` should be populated with the trained model.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Return model parameters for logging or debugging.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing key model parameters and\n                            potentially any learned attributes (e.g., coefficients, intercept).\n        \"\"\"\n        pass\n\n    def plot_confusion_matrix(self, y_true: np.ndarray, y_pred: np.ndarray) -&gt; Figure:\n        \"\"\"\n        Plot the confusion matrix using the true and predicted labels.\n\n        Args:\n            y_true (np.ndarray): True labels for the test data.\n            y_pred (np.ndarray): Predicted labels for the test data.\n\n        Returns:\n            Figure: A matplotlib Figure object containing the confusion matrix plot.\n        \"\"\"\n        cm = confusion_matrix(y_true, y_pred)\n        fig, ax = plt.subplots(figsize=(8, 6))\n        cax = ax.matshow(cm, cmap=plt.cm.Blues)\n        fig.colorbar(cax)\n\n        ax.set_xticklabels([\"\"] + [str(i) for i in np.unique(y_true)])\n        ax.set_yticklabels([\"\"] + [str(i) for i in np.unique(y_true)])\n\n        ax.set_xlabel(\"Predicted\", fontsize=12)\n        ax.set_ylabel(\"True\", fontsize=12)\n        ax.set_title(\"Confusion Matrix\", fontsize=14)\n\n        plt.tight_layout()\n\n        plot_path = self.plots_dir / f\"confusion_matrix_{self.model_type}.png\"\n        fig.savefig(plot_path, dpi=300, bbox_inches=\"tight\")\n        plt.close(fig)\n\n        return fig\n\n    def run(\n        self,\n        data: Optional[np.ndarray] = None,\n        path: Optional[str] = None,\n        test_size: float = 0.2,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Run the complete classification pipeline: data loading/preprocessing,\n        fitting the model, and computing classification metrics on the test set.\n\n        Args:\n            data (Optional[np.ndarray]): Preprocessed data array of shape (n_samples, n_features).\n            path (Optional[str]): Path to a CSV file from which to read data.\n                                  If `data` is not provided, this must be specified.\n            test_size (float): The proportion of the dataset to include in the test split (default 0.2).\n\n        Returns:\n            Dict[str, Any]: A dictionary with the following keys:\n                - \"params\" (Dict[str, Any]): Model parameters from `self.get_model_params()`\n                - \"accuracy\" (float): Accuracy score of the classification model.\n                - \"precision\" (float): Precision score.\n                - \"recall\" (float): Recall score.\n                - \"f1_score\" (float): F1-score.\n        \"\"\"\n        if data is None and path is None:\n            raise ValueError(\"Either 'data' or 'path' must be provided.\")\n\n        # Load/prepare data if needed\n        X, y = data if data is not None else self.prepare_data(path)\n\n        # Split the data into train and test sets\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=test_size, random_state=self.random_state\n        )\n\n        # Fit the model on the training data\n        self.fit(X_train, y_train)\n\n        # Check model and make predictions\n        if self.model is None:\n            raise ValueError(\"Model is not trained. Did you implement fit()?\")\n\n        y_pred = self.model.predict(X_test)\n\n        # Calculate classification metrics\n        accuracy = accuracy_score(y_test, y_pred)\n        precision = precision_score(y_test, y_pred, average=\"weighted\")\n        recall = recall_score(y_test, y_pred, average=\"weighted\")\n        f1 = f1_score(y_test, y_pred, average=\"weighted\")\n\n        # Plot confusion matrix\n        self.plot_confusion_matrix(y_test, y_pred)\n\n        # Return results\n        return {\n            \"params\": self.get_model_params(),\n            \"accuracy\": accuracy,\n            \"precision\": precision,\n            \"recall\": recall,\n            \"f1_score\": f1,\n        }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification.__init__","title":"<code>__init__(model_type, random_state=42)</code>","text":"<p>Initialize the base classification class.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>A string identifier for the classification algorithm               (e.g. \"logistic_regression\", \"decision_tree\", etc.).</p> required <code>random_state</code> <code>int</code> <p>Seed for reproducibility where applicable.                           Defaults to 42.</p> <code>42</code> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>def __init__(\n    self,\n    model_type: str,\n    random_state: int = 42,\n) -&gt; None:\n    \"\"\"\n    Initialize the base classification class.\n\n    Args:\n        model_type (str): A string identifier for the classification algorithm\n                          (e.g. \"logistic_regression\", \"decision_tree\", etc.).\n        random_state (int, optional): Seed for reproducibility where applicable.\n                                      Defaults to 42.\n    \"\"\"\n    self.model_type = model_type\n    self.random_state = random_state\n\n    # Directory for saving plots\n    self.plots_dir = Path.cwd() / \"plots\"\n    self.plots_dir.mkdir(parents=True, exist_ok=True)\n\n    # Subclasses must set self.model after fitting\n    self.model: Optional[Any] = None\n</code></pre>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification.fit","title":"<code>fit(X, y)</code>  <code>abstractmethod</code>","text":"<p>Fit the classification model on the training dataset.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) containing the features.</p> required <code>y</code> <code>ndarray</code> <p>A 1D array of shape (n_samples,) containing the labels.</p> required <p>Subclasses must implement this method. After fitting the model, <code>self.model</code> should be populated with the trained model.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>@abstractmethod\ndef fit(self, X: np.ndarray, y: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the classification model on the training dataset.\n\n    Args:\n        X (np.ndarray): A 2D array of shape (n_samples, n_features) containing the features.\n        y (np.ndarray): A 1D array of shape (n_samples,) containing the labels.\n\n    Subclasses must implement this method. After fitting the model,\n    `self.model` should be populated with the trained model.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification.get_model_params","title":"<code>get_model_params()</code>  <code>abstractmethod</code>","text":"<p>Return model parameters for logging or debugging.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing key model parameters and             potentially any learned attributes (e.g., coefficients, intercept).</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>@abstractmethod\ndef get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Return model parameters for logging or debugging.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing key model parameters and\n                        potentially any learned attributes (e.g., coefficients, intercept).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification.plot_confusion_matrix","title":"<code>plot_confusion_matrix(y_true, y_pred)</code>","text":"<p>Plot the confusion matrix using the true and predicted labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>True labels for the test data.</p> required <code>y_pred</code> <code>ndarray</code> <p>Predicted labels for the test data.</p> required <p>Returns:</p> Name Type Description <code>Figure</code> <code>Figure</code> <p>A matplotlib Figure object containing the confusion matrix plot.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>def plot_confusion_matrix(self, y_true: np.ndarray, y_pred: np.ndarray) -&gt; Figure:\n    \"\"\"\n    Plot the confusion matrix using the true and predicted labels.\n\n    Args:\n        y_true (np.ndarray): True labels for the test data.\n        y_pred (np.ndarray): Predicted labels for the test data.\n\n    Returns:\n        Figure: A matplotlib Figure object containing the confusion matrix plot.\n    \"\"\"\n    cm = confusion_matrix(y_true, y_pred)\n    fig, ax = plt.subplots(figsize=(8, 6))\n    cax = ax.matshow(cm, cmap=plt.cm.Blues)\n    fig.colorbar(cax)\n\n    ax.set_xticklabels([\"\"] + [str(i) for i in np.unique(y_true)])\n    ax.set_yticklabels([\"\"] + [str(i) for i in np.unique(y_true)])\n\n    ax.set_xlabel(\"Predicted\", fontsize=12)\n    ax.set_ylabel(\"True\", fontsize=12)\n    ax.set_title(\"Confusion Matrix\", fontsize=14)\n\n    plt.tight_layout()\n\n    plot_path = self.plots_dir / f\"confusion_matrix_{self.model_type}.png\"\n    fig.savefig(plot_path, dpi=300, bbox_inches=\"tight\")\n    plt.close(fig)\n\n    return fig\n</code></pre>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification.prepare_data","title":"<code>prepare_data(path)</code>","text":"<p>Load and preprocess data from a CSV file, returning features and labels.</p> This method <ol> <li>Reads the CSV file into a pandas DataFrame.</li> <li>Drops rows containing NaN values.</li> <li>Selects only numeric columns from the DataFrame.</li> <li>Scales the features using scikit-learn's StandardScaler.</li> <li>Assumes the last column is the target label.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Filepath to the CSV data file.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: - Features dataset (X) of shape (n_samples, n_features). - Labels (y) of shape (n_samples,).</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>def prepare_data(self, path: str) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Load and preprocess data from a CSV file, returning features and labels.\n\n    This method:\n      1. Reads the CSV file into a pandas DataFrame.\n      2. Drops rows containing NaN values.\n      3. Selects only numeric columns from the DataFrame.\n      4. Scales the features using scikit-learn's StandardScaler.\n      5. Assumes the last column is the target label.\n\n    Args:\n        path (str): Filepath to the CSV data file.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]:\n            - Features dataset (X) of shape (n_samples, n_features).\n            - Labels (y) of shape (n_samples,).\n    \"\"\"\n    df = pd.read_csv(Path(path))\n    df = df.dropna()\n    numeric_columns = df.select_dtypes(include=[np.number]).columns\n    if numeric_columns.empty:\n        raise ValueError(\"No numeric columns found in the data.\")\n    X = df[numeric_columns].values\n    y = df[df.columns[-1]].values  # Assuming last column is the label\n    return StandardScaler().fit_transform(X), y\n</code></pre>"},{"location":"api/core/ml/supervised/classification/base/#scirex.core.ml.supervised.classification.base.Classification.run","title":"<code>run(data=None, path=None, test_size=0.2)</code>","text":"<p>Run the complete classification pipeline: data loading/preprocessing, fitting the model, and computing classification metrics on the test set.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[ndarray]</code> <p>Preprocessed data array of shape (n_samples, n_features).</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Path to a CSV file from which to read data.                   If <code>data</code> is not provided, this must be specified.</p> <code>None</code> <code>test_size</code> <code>float</code> <p>The proportion of the dataset to include in the test split (default 0.2).</p> <code>0.2</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary with the following keys: - \"params\" (Dict[str, Any]): Model parameters from <code>self.get_model_params()</code> - \"accuracy\" (float): Accuracy score of the classification model. - \"precision\" (float): Precision score. - \"recall\" (float): Recall score. - \"f1_score\" (float): F1-score.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\base.py</code> <pre><code>def run(\n    self,\n    data: Optional[np.ndarray] = None,\n    path: Optional[str] = None,\n    test_size: float = 0.2,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run the complete classification pipeline: data loading/preprocessing,\n    fitting the model, and computing classification metrics on the test set.\n\n    Args:\n        data (Optional[np.ndarray]): Preprocessed data array of shape (n_samples, n_features).\n        path (Optional[str]): Path to a CSV file from which to read data.\n                              If `data` is not provided, this must be specified.\n        test_size (float): The proportion of the dataset to include in the test split (default 0.2).\n\n    Returns:\n        Dict[str, Any]: A dictionary with the following keys:\n            - \"params\" (Dict[str, Any]): Model parameters from `self.get_model_params()`\n            - \"accuracy\" (float): Accuracy score of the classification model.\n            - \"precision\" (float): Precision score.\n            - \"recall\" (float): Recall score.\n            - \"f1_score\" (float): F1-score.\n    \"\"\"\n    if data is None and path is None:\n        raise ValueError(\"Either 'data' or 'path' must be provided.\")\n\n    # Load/prepare data if needed\n    X, y = data if data is not None else self.prepare_data(path)\n\n    # Split the data into train and test sets\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=test_size, random_state=self.random_state\n    )\n\n    # Fit the model on the training data\n    self.fit(X_train, y_train)\n\n    # Check model and make predictions\n    if self.model is None:\n        raise ValueError(\"Model is not trained. Did you implement fit()?\")\n\n    y_pred = self.model.predict(X_test)\n\n    # Calculate classification metrics\n    accuracy = accuracy_score(y_test, y_pred)\n    precision = precision_score(y_test, y_pred, average=\"weighted\")\n    recall = recall_score(y_test, y_pred, average=\"weighted\")\n    f1 = f1_score(y_test, y_pred, average=\"weighted\")\n\n    # Plot confusion matrix\n    self.plot_confusion_matrix(y_test, y_pred)\n\n    # Return results\n    return {\n        \"params\": self.get_model_params(),\n        \"accuracy\": accuracy,\n        \"precision\": precision,\n        \"recall\": recall,\n        \"f1_score\": f1,\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/","title":"Decision tree","text":"<p>Decision Tree classification implementation for SciREX.</p> <p>This module provides a Decision Tree implementation using scikit-learn with automatic parameter tuning using grid search. The implementation focuses on both accuracy and interpretability.</p> Mathematical Background <p>Decision Trees recursively partition the feature space using:</p> <ol> <li>Splitting Criteria:</li> <li>Gini Impurity: 1 - \u2211\u1d62p\u1d62\u00b2</li> <li> <p>Entropy: -\u2211\u1d62p\u1d62log(p\u1d62)    where p\u1d62 is the proportion of class i in the node</p> </li> <li> <p>Information Gain:    IG(parent, children) = I(parent) - \u2211(n\u2c7c/n)I(child\u2c7c)    where I is impurity measure (Gini or Entropy)</p> </li> <li> <p>Tree Pruning:    Cost-Complexity: R\u03b1(T) = R(T) + \u03b1|T|    where R(T) is tree error, |T| is tree size, \u03b1 is complexity parameter</p> </li> </ol> Key Features <ul> <li>Automatic parameter optimization</li> <li>Multiple splitting criteria</li> <li>Built-in tree visualization</li> <li>Pruning capabilities</li> <li>Feature importance estimation</li> </ul> References <p>[1] Breiman, L., et al. (1984). Classification and Regression Trees [2] Quinlan, J. R. (1986). Induction of Decision Trees [3] Hastie, T., et al. (2009). Elements of Statistical Learning, Ch. 9</p>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier","title":"<code>DecisionTreeClassifier</code>","text":"<p>               Bases: <code>Classification</code></p> <p>Decision Tree with automatic parameter tuning.</p> <p>This implementation includes automatic selection of optimal parameters using grid search with cross-validation. It balances model complexity with performance through pruning and parameter optimization.</p> <p>Attributes:</p> Name Type Description <code>cv</code> <p>Number of cross-validation folds</p> <code>best_params</code> <code>Optional[Dict[str, Any]]</code> <p>Best parameters found by grid search</p> <code>model</code> <code>Optional[Dict[str, Any]]</code> <p>Fitted DecisionTreeClassifier instance</p> Example <p>classifier = DecisionTreeClassifier(cv=5) X_train = np.array([[1, 2], [2, 3], [3, 4]]) y_train = np.array([0, 0, 1]) classifier.fit(X_train, y_train) print(classifier.best_params)</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>class DecisionTreeClassifier(Classification):\n    \"\"\"Decision Tree with automatic parameter tuning.\n\n    This implementation includes automatic selection of optimal parameters\n    using grid search with cross-validation. It balances model complexity\n    with performance through pruning and parameter optimization.\n\n    Attributes:\n        cv: Number of cross-validation folds\n        best_params: Best parameters found by grid search\n        model: Fitted DecisionTreeClassifier instance\n\n    Example:\n        &gt;&gt;&gt; classifier = DecisionTreeClassifier(cv=5)\n        &gt;&gt;&gt; X_train = np.array([[1, 2], [2, 3], [3, 4]])\n        &gt;&gt;&gt; y_train = np.array([0, 0, 1])\n        &gt;&gt;&gt; classifier.fit(X_train, y_train)\n        &gt;&gt;&gt; print(classifier.best_params)\n    \"\"\"\n\n    def __init__(self, cv: int = 5, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize Decision Tree classifier.\n\n        Args:\n            cv: Number of cross-validation folds. Defaults to 5.\n            **kwargs: Additional keyword arguments passed to parent class.\n\n        Notes:\n            The classifier uses GridSearchCV for parameter optimization,\n            searching over different tree depths, splitting criteria,\n            and minimum sample thresholds.\n        \"\"\"\n        super().__init__(\"decision_tree\", **kwargs)\n        self.cv = cv\n        self.best_params: Optional[Dict[str, Any]] = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -&gt; None:\n        \"\"\"Fit Decision Tree model with parameter tuning.\n\n        Performs grid search over tree parameters to find optimal\n        model configuration using cross-validation.\n\n        Args:\n            X: Training feature matrix of shape (n_samples, n_features)\n            y: Training labels of shape (n_samples,)\n\n        Notes:\n            The grid search optimizes over:\n            - Splitting criterion (gini vs entropy)\n            - Maximum tree depth\n            - Minimum samples for splitting\n            - Minimum samples per leaf\n            - Maximum features considered per split\n        \"\"\"\n        param_grid = {\n            \"criterion\": [\"gini\", \"entropy\"],\n            \"max_depth\": [3, 5, 7, 9, None],\n            \"min_samples_split\": [2, 5, 10],\n            \"min_samples_leaf\": [1, 2, 4],\n            \"max_features\": [\"sqrt\", \"log2\", None],\n        }\n\n        base_model = DTC(random_state=self.random_state)\n\n        grid_search = GridSearchCV(\n            base_model, param_grid, cv=self.cv, scoring=\"accuracy\", n_jobs=-1\n        )\n\n        grid_search.fit(X, y)\n\n        self.best_params = grid_search.best_params_\n        self.model = grid_search.best_estimator_\n\n        print(f\"Best parameters found: {self.best_params}\")\n        print(f\"Best cross-validation score: {grid_search.best_score_:.4f}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"Get parameters of the fitted model.\n\n        Returns:\n            Dictionary containing:\n                - model_type: Type of classifier\n                - best_params: Best parameters found by grid search\n                - cv: Number of cross-validation folds used\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"best_params\": self.best_params,\n            \"cv\": self.cv,\n        }\n\n    def get_feature_importance(self) -&gt; Dict[str, float]:\n        \"\"\"Get feature importance scores.\n\n        Returns:\n            Dictionary mapping feature indices to importance scores\n\n        Raises:\n            ValueError: If model hasn't been fitted yet\n\n        Notes:\n            Feature importance is computed based on the decrease in\n            impurity (Gini or entropy) brought by each feature across\n            all tree splits.\n        \"\"\"\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before getting feature importance\")\n\n        importance_dict = {}\n        for idx, importance in enumerate(self.model.feature_importances_):\n            importance_dict[f\"feature_{idx}\"] = importance\n\n        return importance_dict\n\n    # Add these methods to decision_tree.py\n\n    def predict(self, X: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Predict class labels for samples in X.\n\n        Args:\n            X: Test samples of shape (n_samples, n_features)\n\n        Returns:\n            Array of predicted class labels\n\n        Raises:\n            ValueError: If model hasn't been fitted yet\n        \"\"\"\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before prediction\")\n        return self.model.predict(X)\n\n    def predict_proba(self, X: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Predict class probabilities for samples in X.\n\n        Args:\n            X: Test samples of shape (n_samples, n_features)\n\n        Returns:\n            Array of shape (n_samples, n_classes) with class probabilities\n\n        Raises:\n            ValueError: If model hasn't been fitted yet\n        \"\"\"\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before prediction\")\n        return self.model.predict_proba(X)\n\n    def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, float]:\n        \"\"\"Evaluate model performance on test data.\n\n        Args:\n            X_test: Test features of shape (n_samples, n_features)\n            y_test: True labels of shape (n_samples,)\n\n        Returns:\n            Dictionary containing evaluation metrics:\n                - accuracy: Overall classification accuracy\n                - precision: Precision score (micro-averaged)\n                - recall: Recall score (micro-averaged)\n                - f1_score: F1 score (micro-averaged)\n        \"\"\"\n        from sklearn.metrics import (\n            accuracy_score,\n            precision_score,\n            recall_score,\n            f1_score,\n        )\n\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before evaluation\")\n\n        y_pred = self.predict(X_test)\n\n        return {\n            \"accuracy\": accuracy_score(y_test, y_pred),\n            \"precision\": precision_score(y_test, y_pred, average=\"weighted\"),\n            \"recall\": recall_score(y_test, y_pred, average=\"weighted\"),\n            \"f1_score\": f1_score(y_test, y_pred, average=\"weighted\"),\n        }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.__init__","title":"<code>__init__(cv=5, **kwargs)</code>","text":"<p>Initialize Decision Tree classifier.</p> <p>Parameters:</p> Name Type Description Default <code>cv</code> <code>int</code> <p>Number of cross-validation folds. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to parent class.</p> <code>{}</code> Notes <p>The classifier uses GridSearchCV for parameter optimization, searching over different tree depths, splitting criteria, and minimum sample thresholds.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def __init__(self, cv: int = 5, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize Decision Tree classifier.\n\n    Args:\n        cv: Number of cross-validation folds. Defaults to 5.\n        **kwargs: Additional keyword arguments passed to parent class.\n\n    Notes:\n        The classifier uses GridSearchCV for parameter optimization,\n        searching over different tree depths, splitting criteria,\n        and minimum sample thresholds.\n    \"\"\"\n    super().__init__(\"decision_tree\", **kwargs)\n    self.cv = cv\n    self.best_params: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.evaluate","title":"<code>evaluate(X_test, y_test)</code>","text":"<p>Evaluate model performance on test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test features of shape (n_samples, n_features)</p> required <code>y_test</code> <code>ndarray</code> <p>True labels of shape (n_samples,)</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary containing evaluation metrics: - accuracy: Overall classification accuracy - precision: Precision score (micro-averaged) - recall: Recall score (micro-averaged) - f1_score: F1 score (micro-averaged)</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, float]:\n    \"\"\"Evaluate model performance on test data.\n\n    Args:\n        X_test: Test features of shape (n_samples, n_features)\n        y_test: True labels of shape (n_samples,)\n\n    Returns:\n        Dictionary containing evaluation metrics:\n            - accuracy: Overall classification accuracy\n            - precision: Precision score (micro-averaged)\n            - recall: Recall score (micro-averaged)\n            - f1_score: F1 score (micro-averaged)\n    \"\"\"\n    from sklearn.metrics import (\n        accuracy_score,\n        precision_score,\n        recall_score,\n        f1_score,\n    )\n\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before evaluation\")\n\n    y_pred = self.predict(X_test)\n\n    return {\n        \"accuracy\": accuracy_score(y_test, y_pred),\n        \"precision\": precision_score(y_test, y_pred, average=\"weighted\"),\n        \"recall\": recall_score(y_test, y_pred, average=\"weighted\"),\n        \"f1_score\": f1_score(y_test, y_pred, average=\"weighted\"),\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.fit","title":"<code>fit(X, y)</code>","text":"<p>Fit Decision Tree model with parameter tuning.</p> <p>Performs grid search over tree parameters to find optimal model configuration using cross-validation.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Training feature matrix of shape (n_samples, n_features)</p> required <code>y</code> <code>ndarray</code> <p>Training labels of shape (n_samples,)</p> required Notes <p>The grid search optimizes over: - Splitting criterion (gini vs entropy) - Maximum tree depth - Minimum samples for splitting - Minimum samples per leaf - Maximum features considered per split</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def fit(self, X: np.ndarray, y: np.ndarray) -&gt; None:\n    \"\"\"Fit Decision Tree model with parameter tuning.\n\n    Performs grid search over tree parameters to find optimal\n    model configuration using cross-validation.\n\n    Args:\n        X: Training feature matrix of shape (n_samples, n_features)\n        y: Training labels of shape (n_samples,)\n\n    Notes:\n        The grid search optimizes over:\n        - Splitting criterion (gini vs entropy)\n        - Maximum tree depth\n        - Minimum samples for splitting\n        - Minimum samples per leaf\n        - Maximum features considered per split\n    \"\"\"\n    param_grid = {\n        \"criterion\": [\"gini\", \"entropy\"],\n        \"max_depth\": [3, 5, 7, 9, None],\n        \"min_samples_split\": [2, 5, 10],\n        \"min_samples_leaf\": [1, 2, 4],\n        \"max_features\": [\"sqrt\", \"log2\", None],\n    }\n\n    base_model = DTC(random_state=self.random_state)\n\n    grid_search = GridSearchCV(\n        base_model, param_grid, cv=self.cv, scoring=\"accuracy\", n_jobs=-1\n    )\n\n    grid_search.fit(X, y)\n\n    self.best_params = grid_search.best_params_\n    self.model = grid_search.best_estimator_\n\n    print(f\"Best parameters found: {self.best_params}\")\n    print(f\"Best cross-validation score: {grid_search.best_score_:.4f}\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.get_feature_importance","title":"<code>get_feature_importance()</code>","text":"<p>Get feature importance scores.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary mapping feature indices to importance scores</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model hasn't been fitted yet</p> Notes <p>Feature importance is computed based on the decrease in impurity (Gini or entropy) brought by each feature across all tree splits.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def get_feature_importance(self) -&gt; Dict[str, float]:\n    \"\"\"Get feature importance scores.\n\n    Returns:\n        Dictionary mapping feature indices to importance scores\n\n    Raises:\n        ValueError: If model hasn't been fitted yet\n\n    Notes:\n        Feature importance is computed based on the decrease in\n        impurity (Gini or entropy) brought by each feature across\n        all tree splits.\n    \"\"\"\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before getting feature importance\")\n\n    importance_dict = {}\n    for idx, importance in enumerate(self.model.feature_importances_):\n        importance_dict[f\"feature_{idx}\"] = importance\n\n    return importance_dict\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing: - model_type: Type of classifier - best_params: Best parameters found by grid search - cv: Number of cross-validation folds used</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"Get parameters of the fitted model.\n\n    Returns:\n        Dictionary containing:\n            - model_type: Type of classifier\n            - best_params: Best parameters found by grid search\n            - cv: Number of cross-validation folds used\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"best_params\": self.best_params,\n        \"cv\": self.cv,\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.predict","title":"<code>predict(X)</code>","text":"<p>Predict class labels for samples in X.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Test samples of shape (n_samples, n_features)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of predicted class labels</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model hasn't been fitted yet</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def predict(self, X: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Predict class labels for samples in X.\n\n    Args:\n        X: Test samples of shape (n_samples, n_features)\n\n    Returns:\n        Array of predicted class labels\n\n    Raises:\n        ValueError: If model hasn't been fitted yet\n    \"\"\"\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before prediction\")\n    return self.model.predict(X)\n</code></pre>"},{"location":"api/core/ml/supervised/classification/decision_tree/#scirex.core.ml.supervised.classification.decision_tree.DecisionTreeClassifier.predict_proba","title":"<code>predict_proba(X)</code>","text":"<p>Predict class probabilities for samples in X.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Test samples of shape (n_samples, n_features)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (n_samples, n_classes) with class probabilities</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model hasn't been fitted yet</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\decision_tree.py</code> <pre><code>def predict_proba(self, X: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Predict class probabilities for samples in X.\n\n    Args:\n        X: Test samples of shape (n_samples, n_features)\n\n    Returns:\n        Array of shape (n_samples, n_classes) with class probabilities\n\n    Raises:\n        ValueError: If model hasn't been fitted yet\n    \"\"\"\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before prediction\")\n    return self.model.predict_proba(X)\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/","title":"Logistic regression","text":"<p>Module: logistic_regression.py</p> <p>This module implements Logistic Regression for binary and multi-class classification tasks.</p> It provides functionality to <ul> <li>Train Logistic Regression classifiers on a dataset</li> <li>Evaluate model performance using classification metrics</li> <li>Visualize results with a confusion matrix</li> <li>Optimize hyperparameters using grid search</li> </ul> <p>Classes:</p> Name Description <code>LogisticRegressionClassifier</code> <p>Implements Logistic Regression using scikit-learn.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.linear_model.LogisticRegression</li> <li>sklearn.metrics (classification metrics)</li> <li>sklearn.model_selection.GridSearchCV</li> <li>matplotlib, seaborn</li> <li>base.py (Classification)</li> </ul> Key Features <ul> <li>Support for binary and multi-class classification</li> <li>Regularization options (L1, L2, ElasticNet)</li> <li>Grid search for hyperparameter tuning</li> <li>Automatic data preparation and evaluation</li> </ul> Authors <ul> <li>Protyush P. Chowdhury (protyushc@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier","title":"<code>LogisticRegressionClassifier</code>","text":"<p>               Bases: <code>Classification</code></p> <p>Implements Logistic Regression for classification tasks.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>class LogisticRegressionClassifier(Classification):\n    \"\"\"\n    Implements Logistic Regression for classification tasks.\n    \"\"\"\n\n    def __init__(self, random_state: int = 42) -&gt; None:\n        \"\"\"\n        Initialize the Logistic Regression classifier.\n\n        Args:\n            random_state (int): Seed for reproducibility.\n        \"\"\"\n        super().__init__(model_type=\"logistic_regression\", random_state=random_state)\n        self.model = LogisticRegression(random_state=random_state, solver=\"lbfgs\")\n\n    def fit(self, X_train: np.ndarray, y_train: np.ndarray) -&gt; None:\n        \"\"\"\n        Train the Logistic Regression model.\n\n        Args:\n            X_train (np.ndarray): Training data features.\n            y_train (np.ndarray): Training data labels.\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, Any]:\n        \"\"\"\n        Evaluate the model on test data.\n\n        Args:\n            X_test (np.ndarray): Test data features.\n            y_test (np.ndarray): Test data labels.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing evaluation metrics (accuracy, precision, recall, F1-score).\n        \"\"\"\n        y_pred = self.model.predict(X_test)\n        report = classification_report(y_test, y_pred, output_dict=True)\n        return {\n            \"accuracy\": report[\"accuracy\"],\n            \"precision\": report[\"weighted avg\"][\"precision\"],\n            \"recall\": report[\"weighted avg\"][\"recall\"],\n            \"f1_score\": report[\"weighted avg\"][\"f1-score\"],\n        }\n\n    def predict(self, X_test: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Predict the labels for the test data.\n\n        Args:\n            X_test (np.ndarray): Test data features.\n\n        Returns:\n            np.ndarray: Array of predicted labels.\n        \"\"\"\n        # Use the model to predict the labels for the given test data\n        return self.model.predict(X_test)\n\n    def plot(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; None:\n        \"\"\"\n        Plot the confusion matrix for the test data.\n\n        Args:\n            X_test (np.ndarray): Test data features.\n            y_test (np.ndarray): Test data labels.\n        \"\"\"\n        y_pred = self.model.predict(X_test)\n        cm = confusion_matrix(y_test, y_pred)\n        plt.figure(figsize=(8, 6))\n        sns.heatmap(\n            cm,\n            annot=True,\n            fmt=\"d\",\n            cmap=\"Blues\",\n            xticklabels=np.unique(y_test),\n            yticklabels=np.unique(y_test),\n        )\n        plt.xlabel(\"Predicted\")\n        plt.ylabel(\"Actual\")\n        plt.title(\"Confusion Matrix - Logistic Regression\")\n        plt.show()\n\n    def grid_search(\n        self, X_train: np.ndarray, y_train: np.ndarray, param_grid: Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"\n        Perform hyperparameter tuning using grid search.\n\n        Args:\n            X_train (np.ndarray): Training data features.\n            y_train (np.ndarray): Training data labels.\n            param_grid (Dict[str, Any]): Dictionary of hyperparameters to search.\n        \"\"\"\n        grid = GridSearchCV(\n            estimator=self.model, param_grid=param_grid, scoring=\"accuracy\", cv=5\n        )\n        grid.fit(X_train, y_train)\n        self.model = grid.best_estimator_\n        print(f\"Best Parameters: {grid.best_params_}\")\n        print(f\"Best Cross-Validated Accuracy: {grid.best_score_}\")\n\n    def run(\n        self,\n        data: np.ndarray,\n        labels: np.ndarray,\n        split_ratio: float = 0.2,\n        param_grid: Dict[str, Any] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Execute the full classification pipeline with optional grid search.\n\n        Args:\n            data (np.ndarray): Input features.\n            labels (np.ndarray): Input labels.\n            split_ratio (float): Proportion of data to use for testing. Defaults to 0.2.\n            param_grid (Dict[str, Any], optional): Dictionary of hyperparameters to search for grid search. If None, grid search will not be performed.\n\n        Returns:\n            Dict[str, Any]: Performance metrics.\n        \"\"\"\n        # Split the data into training and test sets\n        X_train, X_test, y_train, y_test = train_test_split(\n            data, labels, test_size=split_ratio\n        )\n\n        # Perform grid search if param_grid is provided\n        if param_grid:\n            self.grid_search(X_train, y_train, param_grid)\n\n        # Train the model with the (possibly tuned) parameters\n        self.fit(X_train, y_train)\n\n        # Evaluate the model\n        metrics = self.evaluate(X_test, y_test)\n\n        # Plot the confusion matrix\n        self.plot(X_test, y_test)\n\n        return metrics\n\n    # Implementing the abstract method get_model_params\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Return the parameters of the model.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing model parameters.\n        \"\"\"\n        return {\n            \"C\": self.model.C,\n            \"max_iter\": self.model.max_iter,\n            \"solver\": self.model.solver,\n            \"penalty\": self.model.penalty,\n        }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.__init__","title":"<code>__init__(random_state=42)</code>","text":"<p>Initialize the Logistic Regression classifier.</p> <p>Parameters:</p> Name Type Description Default <code>random_state</code> <code>int</code> <p>Seed for reproducibility.</p> <code>42</code> Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def __init__(self, random_state: int = 42) -&gt; None:\n    \"\"\"\n    Initialize the Logistic Regression classifier.\n\n    Args:\n        random_state (int): Seed for reproducibility.\n    \"\"\"\n    super().__init__(model_type=\"logistic_regression\", random_state=random_state)\n    self.model = LogisticRegression(random_state=random_state, solver=\"lbfgs\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.evaluate","title":"<code>evaluate(X_test, y_test)</code>","text":"<p>Evaluate the model on test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test data features.</p> required <code>y_test</code> <code>ndarray</code> <p>Test data labels.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing evaluation metrics (accuracy, precision, recall, F1-score).</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, Any]:\n    \"\"\"\n    Evaluate the model on test data.\n\n    Args:\n        X_test (np.ndarray): Test data features.\n        y_test (np.ndarray): Test data labels.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing evaluation metrics (accuracy, precision, recall, F1-score).\n    \"\"\"\n    y_pred = self.model.predict(X_test)\n    report = classification_report(y_test, y_pred, output_dict=True)\n    return {\n        \"accuracy\": report[\"accuracy\"],\n        \"precision\": report[\"weighted avg\"][\"precision\"],\n        \"recall\": report[\"weighted avg\"][\"recall\"],\n        \"f1_score\": report[\"weighted avg\"][\"f1-score\"],\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.fit","title":"<code>fit(X_train, y_train)</code>","text":"<p>Train the Logistic Regression model.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray</code> <p>Training data features.</p> required <code>y_train</code> <code>ndarray</code> <p>Training data labels.</p> required Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def fit(self, X_train: np.ndarray, y_train: np.ndarray) -&gt; None:\n    \"\"\"\n    Train the Logistic Regression model.\n\n    Args:\n        X_train (np.ndarray): Training data features.\n        y_train (np.ndarray): Training data labels.\n    \"\"\"\n    self.model.fit(X_train, y_train)\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Return the parameters of the model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing model parameters.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Return the parameters of the model.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing model parameters.\n    \"\"\"\n    return {\n        \"C\": self.model.C,\n        \"max_iter\": self.model.max_iter,\n        \"solver\": self.model.solver,\n        \"penalty\": self.model.penalty,\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.grid_search","title":"<code>grid_search(X_train, y_train, param_grid)</code>","text":"<p>Perform hyperparameter tuning using grid search.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray</code> <p>Training data features.</p> required <code>y_train</code> <code>ndarray</code> <p>Training data labels.</p> required <code>param_grid</code> <code>Dict[str, Any]</code> <p>Dictionary of hyperparameters to search.</p> required Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def grid_search(\n    self, X_train: np.ndarray, y_train: np.ndarray, param_grid: Dict[str, Any]\n) -&gt; None:\n    \"\"\"\n    Perform hyperparameter tuning using grid search.\n\n    Args:\n        X_train (np.ndarray): Training data features.\n        y_train (np.ndarray): Training data labels.\n        param_grid (Dict[str, Any]): Dictionary of hyperparameters to search.\n    \"\"\"\n    grid = GridSearchCV(\n        estimator=self.model, param_grid=param_grid, scoring=\"accuracy\", cv=5\n    )\n    grid.fit(X_train, y_train)\n    self.model = grid.best_estimator_\n    print(f\"Best Parameters: {grid.best_params_}\")\n    print(f\"Best Cross-Validated Accuracy: {grid.best_score_}\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.plot","title":"<code>plot(X_test, y_test)</code>","text":"<p>Plot the confusion matrix for the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test data features.</p> required <code>y_test</code> <code>ndarray</code> <p>Test data labels.</p> required Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def plot(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the confusion matrix for the test data.\n\n    Args:\n        X_test (np.ndarray): Test data features.\n        y_test (np.ndarray): Test data labels.\n    \"\"\"\n    y_pred = self.model.predict(X_test)\n    cm = confusion_matrix(y_test, y_pred)\n    plt.figure(figsize=(8, 6))\n    sns.heatmap(\n        cm,\n        annot=True,\n        fmt=\"d\",\n        cmap=\"Blues\",\n        xticklabels=np.unique(y_test),\n        yticklabels=np.unique(y_test),\n    )\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"Actual\")\n    plt.title(\"Confusion Matrix - Logistic Regression\")\n    plt.show()\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.predict","title":"<code>predict(X_test)</code>","text":"<p>Predict the labels for the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test data features.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of predicted labels.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def predict(self, X_test: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Predict the labels for the test data.\n\n    Args:\n        X_test (np.ndarray): Test data features.\n\n    Returns:\n        np.ndarray: Array of predicted labels.\n    \"\"\"\n    # Use the model to predict the labels for the given test data\n    return self.model.predict(X_test)\n</code></pre>"},{"location":"api/core/ml/supervised/classification/logistic_regression/#scirex.core.ml.supervised.classification.logistic_regression.LogisticRegressionClassifier.run","title":"<code>run(data, labels, split_ratio=0.2, param_grid=None)</code>","text":"<p>Execute the full classification pipeline with optional grid search.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input features.</p> required <code>labels</code> <code>ndarray</code> <p>Input labels.</p> required <code>split_ratio</code> <code>float</code> <p>Proportion of data to use for testing. Defaults to 0.2.</p> <code>0.2</code> <code>param_grid</code> <code>Dict[str, Any]</code> <p>Dictionary of hyperparameters to search for grid search. If None, grid search will not be performed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Performance metrics.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\logistic_regression.py</code> <pre><code>def run(\n    self,\n    data: np.ndarray,\n    labels: np.ndarray,\n    split_ratio: float = 0.2,\n    param_grid: Dict[str, Any] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Execute the full classification pipeline with optional grid search.\n\n    Args:\n        data (np.ndarray): Input features.\n        labels (np.ndarray): Input labels.\n        split_ratio (float): Proportion of data to use for testing. Defaults to 0.2.\n        param_grid (Dict[str, Any], optional): Dictionary of hyperparameters to search for grid search. If None, grid search will not be performed.\n\n    Returns:\n        Dict[str, Any]: Performance metrics.\n    \"\"\"\n    # Split the data into training and test sets\n    X_train, X_test, y_train, y_test = train_test_split(\n        data, labels, test_size=split_ratio\n    )\n\n    # Perform grid search if param_grid is provided\n    if param_grid:\n        self.grid_search(X_train, y_train, param_grid)\n\n    # Train the model with the (possibly tuned) parameters\n    self.fit(X_train, y_train)\n\n    # Evaluate the model\n    metrics = self.evaluate(X_test, y_test)\n\n    # Plot the confusion matrix\n    self.plot(X_test, y_test)\n\n    return metrics\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/","title":"naive bayes","text":"<p>Module: naive_bayes.py</p> <p>This module implements Naive Bayes classification algorithms, including:   - Gaussian Naive Bayes   - Multinomial Naive Bayes   - Bernoulli Naive Bayes</p> It provides functionality to <ul> <li>Train Naive Bayes classifiers on a dataset</li> <li>Evaluate model performance using classification metrics</li> <li>Visualize results with a confusion matrix</li> <li>Optimize hyperparameters using grid search</li> </ul> <p>Classes:</p> Name Description <code>NaiveBayes</code> <p>Implements Naive Bayes classification using scikit-learn.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.naive_bayes.GaussianNB</li> <li>sklearn.naive_bayes.MultinomialNB</li> <li>sklearn.naive_bayes.BernoulliNB</li> <li>sklearn.metrics (classification metrics)</li> <li>base.py (Classification)</li> </ul> Key Features <ul> <li>Support for Gaussian, Multinomial, and Bernoulli Naive Bayes</li> <li>Grid search for hyperparameter tuning</li> <li>Automatic data preparation and evaluation</li> </ul> Authors <ul> <li>Protyush P. Chowdhury (protyushc@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes","title":"<code>NaiveBayes</code>","text":"<p>               Bases: <code>Classification</code></p> <p>Implements Naive Bayes classification for Gaussian, Multinomial, and Bernoulli distributions.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>class NaiveBayes(Classification):\n    \"\"\"\n    Implements Naive Bayes classification for Gaussian, Multinomial, and Bernoulli distributions.\n    \"\"\"\n\n    def __init__(self, model_type: str = \"gaussian\", random_state: int = 42) -&gt; None:\n        \"\"\"\n        Initialize the NaiveBayes classifier.\n\n        Args:\n            model_type (str): Type of Naive Bayes classifier. Options are:\n                              \"gaussian\", \"multinomial\", \"bernoulli\".\n            random_state (int): Seed for reproducibility where applicable.\n        \"\"\"\n        super().__init__(model_type=model_type, random_state=random_state)\n\n        if model_type == \"gaussian\":\n            self.model = GaussianNB()\n        elif model_type == \"multinomial\":\n            self.model = MultinomialNB()\n        elif model_type == \"bernoulli\":\n            self.model = BernoulliNB()\n        else:\n            raise ValueError(\n                \"Invalid model_type. Choose 'gaussian', 'multinomial', or 'bernoulli'.\"\n            )\n\n    def fit(self, X_train: np.ndarray, y_train: np.ndarray) -&gt; None:\n        \"\"\"\n        Train the Naive Bayes model.\n\n        Args:\n            X_train (np.ndarray): Training data features.\n            y_train (np.ndarray): Training data labels.\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, Any]:\n        \"\"\"\n        Evaluate the model on test data.\n\n        Args:\n            X_test (np.ndarray): Test data features.\n            y_test (np.ndarray): Test data labels.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing evaluation metrics (accuracy, precision, recall, F1-score).\n        \"\"\"\n        y_pred = self.model.predict(X_test)\n        report = classification_report(y_test, y_pred, output_dict=True)\n        return {\n            \"accuracy\": report[\"accuracy\"],\n            \"precision\": report[\"weighted avg\"][\"precision\"],\n            \"recall\": report[\"weighted avg\"][\"recall\"],\n            \"f1_score\": report[\"weighted avg\"][\"f1-score\"],\n        }\n\n    def plot(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; None:\n        \"\"\"\n        Plot the confusion matrix for the test data.\n\n        Args:\n            X_test (np.ndarray): Test data features.\n            y_test (np.ndarray): Test data labels.\n        \"\"\"\n        y_pred = self.model.predict(X_test)\n        cm = confusion_matrix(y_test, y_pred)\n        plt.figure(figsize=(8, 6))\n        sns.heatmap(\n            cm,\n            annot=True,\n            fmt=\"d\",\n            cmap=\"Blues\",\n            xticklabels=np.unique(y_test),\n            yticklabels=np.unique(y_test),\n        )\n        plt.xlabel(\"Predicted\")\n        plt.ylabel(\"Actual\")\n        plt.title(f\"Confusion Matrix - {self.model_type.capitalize()} Naive Bayes\")\n        plt.show()\n\n    def grid_search(\n        self,\n        X_train: np.ndarray,\n        y_train: np.ndarray,\n        param_grid: Dict[str, Any],\n        cv: int = 5,\n    ) -&gt; None:\n        \"\"\"\n        Perform hyperparameter tuning using grid search.\n\n        Args:\n            X_train (np.ndarray): Training data features.\n            y_train (np.ndarray): Training data labels.\n            param_grid (Dict[str, Any]): Dictionary of hyperparameters to search.\n            cv (int): Number of cross-validation folds. Default is 5.\n        \"\"\"\n        grid = GridSearchCV(\n            estimator=self.model, param_grid=param_grid, scoring=\"accuracy\", cv=cv\n        )\n        grid.fit(X_train, y_train)\n        self.model = grid.best_estimator_\n        print(f\"Best Parameters: {grid.best_params_}\")\n        print(f\"Best Cross-Validated Accuracy: {grid.best_score_}\")\n\n    def run(\n        self,\n        data: np.ndarray,\n        labels: np.ndarray,\n        test_size: float = 0.2,\n        param_grid: Dict[str, Any] = None,\n        cv: int = 5,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Execute the full classification pipeline with optional grid search.\n\n        Args:\n            data (np.ndarray): Input features.\n            labels (np.ndarray): Input labels.\n            test_size (float): Proportion of data to use for testing. Defaults to 0.2.\n            param_grid (Dict[str, Any], optional): Dictionary of hyperparameters to search for grid search. If None, grid search will not be performed.\n            cv (int): Number of cross-validation folds for grid search. Default is 5.\n\n        Returns:\n            Dict[str, Any]: Performance metrics.\n        \"\"\"\n        # Split the data into training and test sets\n        X_train, X_test, y_train, y_test = train_test_split(\n            data, labels, test_size=test_size, random_state=self.random_state\n        )\n\n        # Perform grid search if param_grid is provided\n        if param_grid:\n            self.grid_search(X_train, y_train, param_grid, cv=cv)\n\n        # Train the model with the (possibly tuned) parameters\n        self.fit(X_train, y_train)\n\n        # Evaluate the model\n        metrics = self.evaluate(X_test, y_test)\n\n        # Plot the confusion matrix\n        self.plot(X_test, y_test)\n\n        return metrics\n\n    # Implementing the abstract method get_model_params\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Return the parameters of the model.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing model parameters.\n        \"\"\"\n        return {\n            \"alpha\": self.model.alpha,\n            \"fit_prior\": self.model.fit_prior,\n            \"class_prior\": self.model.class_prior,\n        }\n\n    # Method to save the model to a file\n    def save_model(self, file_path: str) -&gt; None:\n        \"\"\"\n        Save the trained model to a file.\n\n        Args:\n            file_path (str): Path where the model will be saved.\n        \"\"\"\n        joblib.dump(self.model, file_path)\n        print(f\"Model saved to {file_path}\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.__init__","title":"<code>__init__(model_type='gaussian', random_state=42)</code>","text":"<p>Initialize the NaiveBayes classifier.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>Type of Naive Bayes classifier. Options are:               \"gaussian\", \"multinomial\", \"bernoulli\".</p> <code>'gaussian'</code> <code>random_state</code> <code>int</code> <p>Seed for reproducibility where applicable.</p> <code>42</code> Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def __init__(self, model_type: str = \"gaussian\", random_state: int = 42) -&gt; None:\n    \"\"\"\n    Initialize the NaiveBayes classifier.\n\n    Args:\n        model_type (str): Type of Naive Bayes classifier. Options are:\n                          \"gaussian\", \"multinomial\", \"bernoulli\".\n        random_state (int): Seed for reproducibility where applicable.\n    \"\"\"\n    super().__init__(model_type=model_type, random_state=random_state)\n\n    if model_type == \"gaussian\":\n        self.model = GaussianNB()\n    elif model_type == \"multinomial\":\n        self.model = MultinomialNB()\n    elif model_type == \"bernoulli\":\n        self.model = BernoulliNB()\n    else:\n        raise ValueError(\n            \"Invalid model_type. Choose 'gaussian', 'multinomial', or 'bernoulli'.\"\n        )\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.evaluate","title":"<code>evaluate(X_test, y_test)</code>","text":"<p>Evaluate the model on test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test data features.</p> required <code>y_test</code> <code>ndarray</code> <p>Test data labels.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing evaluation metrics (accuracy, precision, recall, F1-score).</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, Any]:\n    \"\"\"\n    Evaluate the model on test data.\n\n    Args:\n        X_test (np.ndarray): Test data features.\n        y_test (np.ndarray): Test data labels.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing evaluation metrics (accuracy, precision, recall, F1-score).\n    \"\"\"\n    y_pred = self.model.predict(X_test)\n    report = classification_report(y_test, y_pred, output_dict=True)\n    return {\n        \"accuracy\": report[\"accuracy\"],\n        \"precision\": report[\"weighted avg\"][\"precision\"],\n        \"recall\": report[\"weighted avg\"][\"recall\"],\n        \"f1_score\": report[\"weighted avg\"][\"f1-score\"],\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.fit","title":"<code>fit(X_train, y_train)</code>","text":"<p>Train the Naive Bayes model.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray</code> <p>Training data features.</p> required <code>y_train</code> <code>ndarray</code> <p>Training data labels.</p> required Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def fit(self, X_train: np.ndarray, y_train: np.ndarray) -&gt; None:\n    \"\"\"\n    Train the Naive Bayes model.\n\n    Args:\n        X_train (np.ndarray): Training data features.\n        y_train (np.ndarray): Training data labels.\n    \"\"\"\n    self.model.fit(X_train, y_train)\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Return the parameters of the model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing model parameters.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Return the parameters of the model.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing model parameters.\n    \"\"\"\n    return {\n        \"alpha\": self.model.alpha,\n        \"fit_prior\": self.model.fit_prior,\n        \"class_prior\": self.model.class_prior,\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.grid_search","title":"<code>grid_search(X_train, y_train, param_grid, cv=5)</code>","text":"<p>Perform hyperparameter tuning using grid search.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray</code> <p>Training data features.</p> required <code>y_train</code> <code>ndarray</code> <p>Training data labels.</p> required <code>param_grid</code> <code>Dict[str, Any]</code> <p>Dictionary of hyperparameters to search.</p> required <code>cv</code> <code>int</code> <p>Number of cross-validation folds. Default is 5.</p> <code>5</code> Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def grid_search(\n    self,\n    X_train: np.ndarray,\n    y_train: np.ndarray,\n    param_grid: Dict[str, Any],\n    cv: int = 5,\n) -&gt; None:\n    \"\"\"\n    Perform hyperparameter tuning using grid search.\n\n    Args:\n        X_train (np.ndarray): Training data features.\n        y_train (np.ndarray): Training data labels.\n        param_grid (Dict[str, Any]): Dictionary of hyperparameters to search.\n        cv (int): Number of cross-validation folds. Default is 5.\n    \"\"\"\n    grid = GridSearchCV(\n        estimator=self.model, param_grid=param_grid, scoring=\"accuracy\", cv=cv\n    )\n    grid.fit(X_train, y_train)\n    self.model = grid.best_estimator_\n    print(f\"Best Parameters: {grid.best_params_}\")\n    print(f\"Best Cross-Validated Accuracy: {grid.best_score_}\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.plot","title":"<code>plot(X_test, y_test)</code>","text":"<p>Plot the confusion matrix for the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test data features.</p> required <code>y_test</code> <code>ndarray</code> <p>Test data labels.</p> required Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def plot(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the confusion matrix for the test data.\n\n    Args:\n        X_test (np.ndarray): Test data features.\n        y_test (np.ndarray): Test data labels.\n    \"\"\"\n    y_pred = self.model.predict(X_test)\n    cm = confusion_matrix(y_test, y_pred)\n    plt.figure(figsize=(8, 6))\n    sns.heatmap(\n        cm,\n        annot=True,\n        fmt=\"d\",\n        cmap=\"Blues\",\n        xticklabels=np.unique(y_test),\n        yticklabels=np.unique(y_test),\n    )\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"Actual\")\n    plt.title(f\"Confusion Matrix - {self.model_type.capitalize()} Naive Bayes\")\n    plt.show()\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.run","title":"<code>run(data, labels, test_size=0.2, param_grid=None, cv=5)</code>","text":"<p>Execute the full classification pipeline with optional grid search.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input features.</p> required <code>labels</code> <code>ndarray</code> <p>Input labels.</p> required <code>test_size</code> <code>float</code> <p>Proportion of data to use for testing. Defaults to 0.2.</p> <code>0.2</code> <code>param_grid</code> <code>Dict[str, Any]</code> <p>Dictionary of hyperparameters to search for grid search. If None, grid search will not be performed.</p> <code>None</code> <code>cv</code> <code>int</code> <p>Number of cross-validation folds for grid search. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Performance metrics.</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def run(\n    self,\n    data: np.ndarray,\n    labels: np.ndarray,\n    test_size: float = 0.2,\n    param_grid: Dict[str, Any] = None,\n    cv: int = 5,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Execute the full classification pipeline with optional grid search.\n\n    Args:\n        data (np.ndarray): Input features.\n        labels (np.ndarray): Input labels.\n        test_size (float): Proportion of data to use for testing. Defaults to 0.2.\n        param_grid (Dict[str, Any], optional): Dictionary of hyperparameters to search for grid search. If None, grid search will not be performed.\n        cv (int): Number of cross-validation folds for grid search. Default is 5.\n\n    Returns:\n        Dict[str, Any]: Performance metrics.\n    \"\"\"\n    # Split the data into training and test sets\n    X_train, X_test, y_train, y_test = train_test_split(\n        data, labels, test_size=test_size, random_state=self.random_state\n    )\n\n    # Perform grid search if param_grid is provided\n    if param_grid:\n        self.grid_search(X_train, y_train, param_grid, cv=cv)\n\n    # Train the model with the (possibly tuned) parameters\n    self.fit(X_train, y_train)\n\n    # Evaluate the model\n    metrics = self.evaluate(X_test, y_test)\n\n    # Plot the confusion matrix\n    self.plot(X_test, y_test)\n\n    return metrics\n</code></pre>"},{"location":"api/core/ml/supervised/classification/naive_bayes/#scirex.core.ml.supervised.classification.naive_bayes.NaiveBayes.save_model","title":"<code>save_model(file_path)</code>","text":"<p>Save the trained model to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path where the model will be saved.</p> required Source code in <code>scirex\\core\\ml\\supervised\\classification\\naive_bayes.py</code> <pre><code>def save_model(self, file_path: str) -&gt; None:\n    \"\"\"\n    Save the trained model to a file.\n\n    Args:\n        file_path (str): Path where the model will be saved.\n    \"\"\"\n    joblib.dump(self.model, file_path)\n    print(f\"Model saved to {file_path}\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/","title":"SVM","text":"<p>Support Vector Machine (SVM) classification implementation for SciREX.</p> <p>This module provides a comprehensive SVM implementation using scikit-learn, supporting multiple kernel types with automatic parameter tuning.</p> Mathematical Background <p>SVM solves the optimization problem: min_{w,b} 1/2||w||\u00b2 + C\u2211max(0, 1 - y\u1d62(w\u00b7x\u1d62 + b))</p> <p>Kernel functions supported: 1. Linear: K(x,y) = x\u00b7y 2. RBF: K(x,y) = exp(-\u03b3||x-y||\u00b2) 3. Polynomial: K(x,y) = (\u03b3x\u00b7y + r)^d 4. Sigmoid: K(x,y) = tanh(\u03b3x\u00b7y + r)</p> <p>The dual formulation solves: max_\u03b1 \u2211\u03b1\u1d62 - 1/2\u2211\u2211\u03b1\u1d62\u03b1\u2c7cy\u1d62y\u2c7cK(x\u1d62,x\u2c7c) subject to: 0 \u2264 \u03b1\u1d62 \u2264 C, \u2211\u03b1\u1d62y\u1d62 = 0</p> Key Features <ul> <li>Multiple kernel functions</li> <li>Automatic parameter optimization</li> <li>Probability estimation support</li> <li>Efficient optimization for large datasets</li> </ul> References <p>[1] Vapnik, V. (1998). Statistical Learning Theory [2] Scholkopf, B., &amp; Smola, A. J. (2002). Learning with Kernels [3] Platt, J. (1999). Probabilistic Outputs for SVMs</p>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier","title":"<code>SVMClassifier</code>","text":"<p>               Bases: <code>Classification</code></p> <p>SVM classifier with automatic parameter tuning.</p> <p>This implementation supports different kernel types and includes automatic parameter optimization using grid search with cross-validation. Each kernel is optimized for its specific characteristics and use cases.</p> <p>Attributes:</p> Name Type Description <code>kernel</code> <p>Type of kernel function</p> <code>cv</code> <p>Number of cross-validation folds</p> <code>best_params</code> <code>Optional[Dict[str, Any]]</code> <p>Best parameters found by grid search</p> Example <p>classifier = SVMClassifier(kernel=\"rbf\", cv=5) X_train = np.array([[1, 2], [2, 3], [3, 4]]) y_train = np.array([0, 0, 1]) classifier.fit(X_train, y_train) print(classifier.best_params)</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>class SVMClassifier(Classification):\n    \"\"\"SVM classifier with automatic parameter tuning.\n\n    This implementation supports different kernel types and includes\n    automatic parameter optimization using grid search with cross-validation.\n    Each kernel is optimized for its specific characteristics and use cases.\n\n    Attributes:\n        kernel: Type of kernel function\n        cv: Number of cross-validation folds\n        best_params: Best parameters found by grid search\n\n    Example:\n        &gt;&gt;&gt; classifier = SVMClassifier(kernel=\"rbf\", cv=5)\n        &gt;&gt;&gt; X_train = np.array([[1, 2], [2, 3], [3, 4]])\n        &gt;&gt;&gt; y_train = np.array([0, 0, 1])\n        &gt;&gt;&gt; classifier.fit(X_train, y_train)\n        &gt;&gt;&gt; print(classifier.best_params)\n    \"\"\"\n\n    def __init__(\n        self,\n        kernel: Literal[\"linear\", \"rbf\", \"poly\", \"sigmoid\"] = \"rbf\",\n        cv: int = 5,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize SVM classifier.\n\n        Args:\n            kernel: Kernel function type. Options:\n                   \"linear\": Linear kernel for linearly separable data\n                   \"rbf\": Radial basis function for non-linear patterns\n                   \"poly\": Polynomial kernel for non-linear patterns\n                   \"sigmoid\": Sigmoid kernel for neural network-like behavior\n            cv: Number of cross-validation folds. Defaults to 5.\n            **kwargs: Additional keyword arguments passed to parent class.\n        \"\"\"\n        super().__init__(\"svm\", **kwargs)\n        self._validate_kernel(kernel)\n        self.kernel = kernel\n        self.cv = cv\n        self.best_params: Optional[Dict[str, Any]] = None\n\n    def _get_param_grid(self):\n        \"\"\"Get parameter grid for grid search based on kernel type.\n\n        Returns:\n            Dictionary of parameters to search for the chosen kernel.\n\n        Notes:\n            Parameter grids are optimized for each kernel:\n            - Linear: Only C (regularization)\n            - RBF: C and gamma (kernel coefficient)\n            - Polynomial: C, gamma, degree, and coef0\n            - Sigmoid: C, gamma, and coef0\n        \"\"\"\n        param_grid = {\n            \"C\": [0.1, 1, 10, 100],\n        }\n\n        if self.kernel == \"linear\":\n            return param_grid\n\n        elif self.kernel == \"rbf\":\n            param_grid.update(\n                {\n                    \"gamma\": [\"scale\", \"auto\", 0.001, 0.01, 0.1, 1],\n                }\n            )\n\n        elif self.kernel == \"poly\":\n            param_grid.update(\n                {\n                    \"degree\": [2, 3, 4],\n                    \"gamma\": [\"scale\", \"auto\", 0.001, 0.01, 0.1, 1],\n                    \"coef0\": [0, 1],\n                }\n            )\n\n        elif self.kernel == \"sigmoid\":\n            param_grid.update(\n                {\n                    \"gamma\": [\"scale\", \"auto\", 0.001, 0.01, 0.1, 1],\n                    \"coef0\": [0, 1],\n                }\n            )\n\n        return param_grid\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -&gt; None:\n        \"\"\"Fit SVM model with parameter tuning.\n\n        Performs grid search to find optimal parameters for the chosen\n        kernel type.\n\n        Args:\n            X: Training feature matrix of shape (n_samples, n_features)\n            y: Training labels of shape (n_samples,)\n\n        Notes:\n            - Uses probability estimation for better prediction granularity\n            - Employs parallel processing for faster grid search\n            - May take longer for larger datasets due to quadratic complexity\n        \"\"\"\n        base_model = SVC(\n            kernel=self.kernel, random_state=self.random_state, probability=True\n        )\n\n        param_grid = self._get_param_grid()\n\n        grid_search = GridSearchCV(\n            base_model, param_grid, cv=self.cv, scoring=\"accuracy\", n_jobs=-1\n        )\n\n        print(f\"Training SVM with {self.kernel} kernel...\")\n        print(\"This may take a while for larger datasets.\")\n\n        grid_search.fit(X, y)\n\n        self.best_params = grid_search.best_params_\n        self.model = grid_search.best_estimator_\n\n        print(f\"Best parameters found: {self.best_params}\")\n        print(f\"Best cross-validation score: {grid_search.best_score_:.4f}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"Get parameters of the fitted model.\n\n        Returns:\n            Dictionary containing:\n                - model_type: Type of classifier\n                - kernel: Kernel function used\n                - best_params: Best parameters found by grid search\n                - cv: Number of cross-validation folds used\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"kernel\": self.kernel,\n            \"best_params\": self.best_params,\n            \"cv\": self.cv,\n        }\n\n    # Add these methods to svm.py\n\n    def predict(self, X: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Predict class labels for samples in X.\n\n        Args:\n            X: Test samples of shape (n_samples, n_features)\n\n        Returns:\n            Array of predicted class labels\n\n        Raises:\n            ValueError: If model hasn't been fitted yet\n        \"\"\"\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before prediction\")\n        return self.model.predict(X)\n\n    def predict_proba(self, X: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Predict class probabilities for samples in X.\n\n        Args:\n            X: Test samples of shape (n_samples, n_features)\n\n        Returns:\n            Array of shape (n_samples, n_classes) with class probabilities\n\n        Raises:\n            ValueError: If model hasn't been fitted yet\n        \"\"\"\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before prediction\")\n        return self.model.predict_proba(X)\n\n    def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, float]:\n        \"\"\"Evaluate model performance on test data.\n\n        Args:\n            X_test: Test features of shape (n_samples, n_features)\n            y_test: True labels of shape (n_samples,)\n\n        Returns:\n            Dictionary containing evaluation metrics:\n                - accuracy: Overall classification accuracy\n                - precision: Precision score (micro-averaged)\n                - recall: Recall score (micro-averaged)\n                - f1_score: F1 score (micro-averaged)\n        \"\"\"\n        from sklearn.metrics import (\n            accuracy_score,\n            precision_score,\n            recall_score,\n            f1_score,\n        )\n\n        if self.model is None:\n            raise ValueError(\"Model must be fitted before evaluation\")\n\n        y_pred = self.predict(X_test)\n\n        return {\n            \"accuracy\": accuracy_score(y_test, y_pred),\n            \"precision\": precision_score(y_test, y_pred, average=\"weighted\"),\n            \"recall\": recall_score(y_test, y_pred, average=\"weighted\"),\n            \"f1_score\": f1_score(y_test, y_pred, average=\"weighted\"),\n        }\n\n    def _validate_kernel(self, kernel: str) -&gt; None:\n        \"\"\"Validate the kernel type.\n\n        Args:\n            kernel: Kernel type to validate\n\n        Raises:\n            ValueError: If kernel is not one of the supported types\n        \"\"\"\n        valid_kernels = [\"linear\", \"rbf\", \"poly\", \"sigmoid\"]\n        if kernel not in valid_kernels:\n            raise ValueError(\n                f\"Invalid kernel type '{kernel}'. \"\n                f\"Must be one of: {', '.join(valid_kernels)}\"\n            )\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier.__init__","title":"<code>__init__(kernel='rbf', cv=5, **kwargs)</code>","text":"<p>Initialize SVM classifier.</p> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>Literal['linear', 'rbf', 'poly', 'sigmoid']</code> <p>Kernel function type. Options:    \"linear\": Linear kernel for linearly separable data    \"rbf\": Radial basis function for non-linear patterns    \"poly\": Polynomial kernel for non-linear patterns    \"sigmoid\": Sigmoid kernel for neural network-like behavior</p> <code>'rbf'</code> <code>cv</code> <code>int</code> <p>Number of cross-validation folds. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to parent class.</p> <code>{}</code> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>def __init__(\n    self,\n    kernel: Literal[\"linear\", \"rbf\", \"poly\", \"sigmoid\"] = \"rbf\",\n    cv: int = 5,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize SVM classifier.\n\n    Args:\n        kernel: Kernel function type. Options:\n               \"linear\": Linear kernel for linearly separable data\n               \"rbf\": Radial basis function for non-linear patterns\n               \"poly\": Polynomial kernel for non-linear patterns\n               \"sigmoid\": Sigmoid kernel for neural network-like behavior\n        cv: Number of cross-validation folds. Defaults to 5.\n        **kwargs: Additional keyword arguments passed to parent class.\n    \"\"\"\n    super().__init__(\"svm\", **kwargs)\n    self._validate_kernel(kernel)\n    self.kernel = kernel\n    self.cv = cv\n    self.best_params: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier.evaluate","title":"<code>evaluate(X_test, y_test)</code>","text":"<p>Evaluate model performance on test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_test</code> <code>ndarray</code> <p>Test features of shape (n_samples, n_features)</p> required <code>y_test</code> <code>ndarray</code> <p>True labels of shape (n_samples,)</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary containing evaluation metrics: - accuracy: Overall classification accuracy - precision: Precision score (micro-averaged) - recall: Recall score (micro-averaged) - f1_score: F1 score (micro-averaged)</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>def evaluate(self, X_test: np.ndarray, y_test: np.ndarray) -&gt; Dict[str, float]:\n    \"\"\"Evaluate model performance on test data.\n\n    Args:\n        X_test: Test features of shape (n_samples, n_features)\n        y_test: True labels of shape (n_samples,)\n\n    Returns:\n        Dictionary containing evaluation metrics:\n            - accuracy: Overall classification accuracy\n            - precision: Precision score (micro-averaged)\n            - recall: Recall score (micro-averaged)\n            - f1_score: F1 score (micro-averaged)\n    \"\"\"\n    from sklearn.metrics import (\n        accuracy_score,\n        precision_score,\n        recall_score,\n        f1_score,\n    )\n\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before evaluation\")\n\n    y_pred = self.predict(X_test)\n\n    return {\n        \"accuracy\": accuracy_score(y_test, y_pred),\n        \"precision\": precision_score(y_test, y_pred, average=\"weighted\"),\n        \"recall\": recall_score(y_test, y_pred, average=\"weighted\"),\n        \"f1_score\": f1_score(y_test, y_pred, average=\"weighted\"),\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier.fit","title":"<code>fit(X, y)</code>","text":"<p>Fit SVM model with parameter tuning.</p> <p>Performs grid search to find optimal parameters for the chosen kernel type.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Training feature matrix of shape (n_samples, n_features)</p> required <code>y</code> <code>ndarray</code> <p>Training labels of shape (n_samples,)</p> required Notes <ul> <li>Uses probability estimation for better prediction granularity</li> <li>Employs parallel processing for faster grid search</li> <li>May take longer for larger datasets due to quadratic complexity</li> </ul> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>def fit(self, X: np.ndarray, y: np.ndarray) -&gt; None:\n    \"\"\"Fit SVM model with parameter tuning.\n\n    Performs grid search to find optimal parameters for the chosen\n    kernel type.\n\n    Args:\n        X: Training feature matrix of shape (n_samples, n_features)\n        y: Training labels of shape (n_samples,)\n\n    Notes:\n        - Uses probability estimation for better prediction granularity\n        - Employs parallel processing for faster grid search\n        - May take longer for larger datasets due to quadratic complexity\n    \"\"\"\n    base_model = SVC(\n        kernel=self.kernel, random_state=self.random_state, probability=True\n    )\n\n    param_grid = self._get_param_grid()\n\n    grid_search = GridSearchCV(\n        base_model, param_grid, cv=self.cv, scoring=\"accuracy\", n_jobs=-1\n    )\n\n    print(f\"Training SVM with {self.kernel} kernel...\")\n    print(\"This may take a while for larger datasets.\")\n\n    grid_search.fit(X, y)\n\n    self.best_params = grid_search.best_params_\n    self.model = grid_search.best_estimator_\n\n    print(f\"Best parameters found: {self.best_params}\")\n    print(f\"Best cross-validation score: {grid_search.best_score_:.4f}\")\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing: - model_type: Type of classifier - kernel: Kernel function used - best_params: Best parameters found by grid search - cv: Number of cross-validation folds used</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"Get parameters of the fitted model.\n\n    Returns:\n        Dictionary containing:\n            - model_type: Type of classifier\n            - kernel: Kernel function used\n            - best_params: Best parameters found by grid search\n            - cv: Number of cross-validation folds used\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"kernel\": self.kernel,\n        \"best_params\": self.best_params,\n        \"cv\": self.cv,\n    }\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier.predict","title":"<code>predict(X)</code>","text":"<p>Predict class labels for samples in X.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Test samples of shape (n_samples, n_features)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of predicted class labels</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model hasn't been fitted yet</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>def predict(self, X: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Predict class labels for samples in X.\n\n    Args:\n        X: Test samples of shape (n_samples, n_features)\n\n    Returns:\n        Array of predicted class labels\n\n    Raises:\n        ValueError: If model hasn't been fitted yet\n    \"\"\"\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before prediction\")\n    return self.model.predict(X)\n</code></pre>"},{"location":"api/core/ml/supervised/classification/svm/#scirex.core.ml.supervised.classification.svm.SVMClassifier.predict_proba","title":"<code>predict_proba(X)</code>","text":"<p>Predict class probabilities for samples in X.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Test samples of shape (n_samples, n_features)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (n_samples, n_classes) with class probabilities</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model hasn't been fitted yet</p> Source code in <code>scirex\\core\\ml\\supervised\\classification\\svm.py</code> <pre><code>def predict_proba(self, X: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Predict class probabilities for samples in X.\n\n    Args:\n        X: Test samples of shape (n_samples, n_features)\n\n    Returns:\n        Array of shape (n_samples, n_classes) with class probabilities\n\n    Raises:\n        ValueError: If model hasn't been fitted yet\n    \"\"\"\n    if self.model is None:\n        raise ValueError(\"Model must be fitted before prediction\")\n    return self.model.predict_proba(X)\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/","title":"Agglomerative","text":"<p>Module: agglomerative.py</p> <p>This module provides an Agglomerative Clustering implementation using scikit-learn. It includes automatic selection of the optimal number of clusters using silhouette scores.</p> <p>Classes:</p> Name Description <code>Agglomerative</code> <p>Implements an agglomerative clustering approach with auto cluster selection.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.AgglomerativeClustering</li> <li>sklearn.metrics.silhouette_score</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic scanning of possible cluster counts (2..max_k)</li> <li>Silhouette-based selection of the best cluster count</li> <li>Final model/labels accessible after <code>.fit(...)</code></li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative","title":"<code>Agglomerative</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>Agglomerative Clustering with automatic selection of the optimal cluster count via silhouette.</p> <p>Attributes:</p> Name Type Description <code>max_k</code> <code>int</code> <p>The maximum number of clusters to consider.</p> <code>optimal_k</code> <code>Optional[int]</code> <p>The chosen number of clusters after evaluating silhouette                        scores and optional user input.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>Final cluster count (same as optimal_k).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>class Agglomerative(Clustering):\n    \"\"\"\n    Agglomerative Clustering with automatic selection of the optimal cluster count via silhouette.\n\n    Attributes:\n        max_k (int): The maximum number of clusters to consider.\n        optimal_k (Optional[int]): The chosen number of clusters after evaluating silhouette\n                                   scores and optional user input.\n        n_clusters (Optional[int]): Final cluster count (same as optimal_k).\n    \"\"\"\n\n    def __init__(self, max_k: int = 10) -&gt; None:\n        \"\"\"\n        Initialize the Agglomerative clustering class.\n\n        Args:\n            max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n        \"\"\"\n        super().__init__(\"agglomerative\")\n        self.max_k = max_k\n        self.optimal_k: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the Agglomerative Clustering model with automatic cluster count selection.\n\n        Args:\n            X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples = X.shape[0]\n        k_values = range(2, self.max_k + 1)\n        silhouettes = []\n\n        # Subsample size for silhouette\n        silhouette_sample_size = min(1000, n_samples)\n\n        for k in k_values:\n            model = AgglomerativeClustering(\n                n_clusters=k,\n                linkage=\"average\",  # or 'ward', 'complete', 'single'\n            )\n            labels = model.fit_predict(X)\n            unique_labels = np.unique(labels)\n\n            # If there's only one cluster, silhouette is invalid\n            if len(unique_labels) &lt;= 1:\n                silhouettes.append(-1)\n                continue\n\n            # Subsample if data is large\n            if n_samples &gt; silhouette_sample_size:\n                indices = np.random.choice(\n                    n_samples, silhouette_sample_size, replace=False\n                )\n                silhouettes.append(silhouette_score(X[indices], labels[indices]))\n            else:\n                silhouettes.append(silhouette_score(X, labels))\n\n        # Choose best k from silhouette\n        self.optimal_k = k_values[np.argmax(silhouettes)]\n        print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n        # Final fit with optimal_k\n        self.model = AgglomerativeClustering(\n            n_clusters=self.optimal_k, linkage=\"average\"\n        )\n        self.labels = self.model.fit_predict(X)\n        self.n_clusters = len(np.unique(self.labels))\n\n        print(f\"Agglomerative Clustering fitted with k = {self.optimal_k}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted Agglomerative Clustering model.\n\n        Returns:\n            Dict[str, Any]:\n                A dictionary containing:\n                - model_type (str): \"agglomerative\"\n                - n_clusters (int): The final chosen cluster count\n        \"\"\"\n        return {\"model_type\": self.model_type, \"n_clusters\": self.optimal_k}\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative.__init__","title":"<code>__init__(max_k=10)</code>","text":"<p>Initialize the Agglomerative clustering class.</p> <p>Parameters:</p> Name Type Description Default <code>max_k</code> <code>int</code> <p>Maximum number of clusters to try. Defaults to 10.</p> <code>10</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>def __init__(self, max_k: int = 10) -&gt; None:\n    \"\"\"\n    Initialize the Agglomerative clustering class.\n\n    Args:\n        max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n    \"\"\"\n    super().__init__(\"agglomerative\")\n    self.max_k = max_k\n    self.optimal_k: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative.fit","title":"<code>fit(X)</code>","text":"<p>Fit the Agglomerative Clustering model with automatic cluster count selection.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Scaled feature matrix of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the Agglomerative Clustering model with automatic cluster count selection.\n\n    Args:\n        X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples = X.shape[0]\n    k_values = range(2, self.max_k + 1)\n    silhouettes = []\n\n    # Subsample size for silhouette\n    silhouette_sample_size = min(1000, n_samples)\n\n    for k in k_values:\n        model = AgglomerativeClustering(\n            n_clusters=k,\n            linkage=\"average\",  # or 'ward', 'complete', 'single'\n        )\n        labels = model.fit_predict(X)\n        unique_labels = np.unique(labels)\n\n        # If there's only one cluster, silhouette is invalid\n        if len(unique_labels) &lt;= 1:\n            silhouettes.append(-1)\n            continue\n\n        # Subsample if data is large\n        if n_samples &gt; silhouette_sample_size:\n            indices = np.random.choice(\n                n_samples, silhouette_sample_size, replace=False\n            )\n            silhouettes.append(silhouette_score(X[indices], labels[indices]))\n        else:\n            silhouettes.append(silhouette_score(X, labels))\n\n    # Choose best k from silhouette\n    self.optimal_k = k_values[np.argmax(silhouettes)]\n    print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n    # Final fit with optimal_k\n    self.model = AgglomerativeClustering(\n        n_clusters=self.optimal_k, linkage=\"average\"\n    )\n    self.labels = self.model.fit_predict(X)\n    self.n_clusters = len(np.unique(self.labels))\n\n    print(f\"Agglomerative Clustering fitted with k = {self.optimal_k}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/agglomerative/#scirex.core.ml.unsupervised.clustering.agglomerative.Agglomerative.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted Agglomerative Clustering model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str): \"agglomerative\" - n_clusters (int): The final chosen cluster count</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\agglomerative.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted Agglomerative Clustering model.\n\n    Returns:\n        Dict[str, Any]:\n            A dictionary containing:\n            - model_type (str): \"agglomerative\"\n            - n_clusters (int): The final chosen cluster count\n    \"\"\"\n    return {\"model_type\": self.model_type, \"n_clusters\": self.optimal_k}\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/","title":"Base","text":"<p>Module: base.py</p> <p>This module provides the abstract base class for all clustering implementations in SciREX. It defines shared functionality for:     - Data preparation (loading from CSV and standard scaling)     - Clustering metric computation (silhouette, calinski-harabasz, davies-bouldin)     - 2D plotting using PCA for visualization</p> <p>Classes:</p> Name Description <code>Clustering</code> <p>Abstract base class that outlines common behavior for clustering algorithms.</p> Dependencies <ul> <li>numpy, pandas, matplotlib, sklearn</li> <li>abc, pathlib, time, typing (for structural and type support)</li> </ul> Key Features <ul> <li>Consistent interface for loading and preparing data</li> <li>Standard approach to computing and returning clustering metrics</li> <li>PCA-based 2D plotting routine for visualizing clusters in two dimensions</li> <li>Enforces subclasses to implement <code>fit</code> and <code>get_model_params</code></li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering","title":"<code>Clustering</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for clustering algorithms in the SciREX library.</p> This class provides <ul> <li>A consistent interface for loading and preparing data</li> <li>A standard approach to computing and returning clustering metrics</li> <li>A PCA-based 2D plotting routine for visualizing clusters</li> </ul> Subclasses must <ol> <li>Implement the <code>fit(X: np.ndarray) -&gt; None</code> method, which should populate <code>self.labels</code>.</li> <li>Implement the <code>get_model_params() -&gt; Dict[str, Any]</code> method, which returns a dict    of model parameters for logging/debugging.</li> </ol> <p>Attributes:</p> Name Type Description <code>model_type</code> <code>str</code> <p>The name or identifier of the clustering model (e.g., \"kmeans\", \"dbscan\").</p> <code>random_state</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>labels</code> <code>Optional[ndarray]</code> <p>Array of cluster labels assigned to each sample after fitting.</p> <code>plots_dir</code> <code>Path</code> <p>Directory where cluster plots will be saved.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>class Clustering(ABC):\n    \"\"\"\n    Abstract base class for clustering algorithms in the SciREX library.\n\n    This class provides:\n      - A consistent interface for loading and preparing data\n      - A standard approach to computing and returning clustering metrics\n      - A PCA-based 2D plotting routine for visualizing clusters\n\n    Subclasses must:\n      1. Implement the `fit(X: np.ndarray) -&gt; None` method, which should populate `self.labels`.\n      2. Implement the `get_model_params() -&gt; Dict[str, Any]` method, which returns a dict\n         of model parameters for logging/debugging.\n\n    Attributes:\n        model_type (str): The name or identifier of the clustering model (e.g., \"kmeans\", \"dbscan\").\n        random_state (int): Random seed for reproducibility.\n        labels (Optional[np.ndarray]): Array of cluster labels assigned to each sample after fitting.\n        plots_dir (Path): Directory where cluster plots will be saved.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_type: str,\n        random_state: int = 42,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the base clustering class.\n\n        Args:\n            model_type (str): A string identifier for the clustering algorithm\n                              (e.g. \"kmeans\", \"dbscan\", etc.).\n            random_state (int, optional): Seed for reproducibility where applicable.\n                                          Defaults to 42.\n        \"\"\"\n        self.model_type = model_type\n        self.random_state = random_state\n\n        # Directory for saving plots\n        self.plots_dir = Path.cwd() / \"plots\"\n        self.plots_dir.mkdir(parents=True, exist_ok=True)\n\n        # Subclasses must set self.labels after fitting\n        self.labels: Optional[np.ndarray] = None\n\n    def prepare_data(self, path: str) -&gt; np.ndarray:\n        \"\"\"\n        Load and preprocess data from a CSV file, returning a scaled NumPy array.\n\n        This method:\n          1. Reads the CSV file into a pandas DataFrame.\n          2. Drops rows containing NaN values.\n          3. Selects only numeric columns from the DataFrame.\n          4. Scales these features using scikit-learn's StandardScaler.\n          5. Returns the scaled values as a NumPy array.\n\n        Args:\n            path (str): Filepath to the CSV data file.\n\n        Returns:\n            np.ndarray: A 2D array of shape (n_samples, n_features) containing\n                        standardized numeric data.\n\n        Raises:\n            ValueError: If no numeric columns are found in the data.\n        \"\"\"\n        df = pd.read_csv(Path(path))\n        df = df.dropna()\n        numeric_columns = df.select_dtypes(include=[np.number]).columns\n        if numeric_columns.empty:\n            raise ValueError(\"No numeric columns found in the data.\")\n        features = df[numeric_columns].values\n        return StandardScaler().fit_transform(features)\n\n    @abstractmethod\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the clustering model on a preprocessed dataset, assigning labels to `self.labels`.\n\n        Args:\n            X (np.ndarray): A 2D array of shape (n_samples, n_features) containing\n                            the data to be clustered.\n\n        Subclasses must implement this method. After fitting the model,\n        `self.labels` should be set to an array of cluster labels of shape (n_samples,).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Return model parameters for logging or debugging.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing key model parameters and\n                            potentially any learned attributes (e.g. number of clusters).\n        \"\"\"\n        pass\n\n    def plots(self, X: np.ndarray, labels: np.ndarray) -&gt; Tuple[Figure, Path]:\n        \"\"\"\n        Create a 2D scatter plot of clusters using PCA for dimensionality reduction.\n\n        Steps:\n          1. If X has &gt;=2 features, run PCA to reduce it to 2 components.\n          2. If X has only 1 feature, it is zero-padded to form a 2D embedding for plotting.\n          3. Each unique cluster label is plotted with a distinct color.\n          4. The figure is saved in `self.plots_dir` as `cluster_plot_{self.model_type}.png`.\n\n        Args:\n            X (np.ndarray): Data array of shape (n_samples, n_features).\n            labels (np.ndarray): Cluster labels for each sample.\n\n        Returns:\n            Tuple[Figure, Path]:\n              - The matplotlib Figure object.\n              - The path where the figure was saved (plot_path).\n\n        Notes:\n            Subclasses typically do not override this method. Instead, they rely on the\n            base implementation for consistent plotting.\n        \"\"\"\n        n_features = X.shape[1]\n        if n_features &gt;= 2:\n            pca = PCA(n_components=2, random_state=self.random_state)\n            X_pca = pca.fit_transform(X)\n        else:\n            # If there's only 1 feature, we simulate a second dimension with zeros\n            print(\"Dataset has only 1 feature. Zero-padding to 2D for visualization.\")\n            pca = PCA(n_components=1, random_state=self.random_state)\n            X_1d = pca.fit_transform(X)\n            X_pca = np.hstack([X_1d, np.zeros((X_1d.shape[0], 1))])\n\n        unique_labels = np.unique(labels)\n\n        fig = plt.figure(figsize=(8, 6), dpi=100)\n        ax = fig.add_subplot(111)\n\n        colors = plt.cm.rainbow(np.linspace(0, 1, len(unique_labels)))\n        for label, color in zip(unique_labels, colors):\n            mask = labels == label\n            ax.scatter(\n                X_pca[mask, 0],\n                X_pca[mask, 1],\n                color=(\"k\" if label == -1 else color),\n                label=f\"Cluster {label}\",\n                alpha=0.7,\n                s=60,\n            )\n\n        ax.set_xlabel(\"PCA Component 1\", fontsize=10)\n        ax.set_ylabel(\"PCA Component 2\", fontsize=10)\n        ax.legend(fontsize=8)\n        ax.set_title(\n            f\"{self.model_type.upper()} Clustering Results (2D PCA)\",\n            fontsize=12,\n            pad=15,\n        )\n        plt.tight_layout()\n\n        # Save the figure\n        plot_path = self.plots_dir / f\"cluster_plot_{self.model_type}.png\"\n        fig.savefig(plot_path, dpi=300, bbox_inches=\"tight\")\n        plt.close(fig)\n        return fig, plot_path\n\n    def run(\n        self, data: Optional[np.ndarray] = None, path: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Run the complete clustering pipeline: data loading/preprocessing,\n        fitting the model, and computing standard clustering metrics.\n\n        Args:\n            data (Optional[np.ndarray]): Preprocessed data array of shape (n_samples, n_features).\n            path (Optional[str]): Path to a CSV file from which to read data.\n                                  If `data` is not provided, this must be specified.\n\n        Returns:\n            Dict[str, Any]: A dictionary with the following keys:\n                - \"params\" (Dict[str, Any]): Model parameters from `self.get_model_params()`\n                - \"silhouette_score\" (float)\n                - \"calinski_harabasz_score\" (float)\n                - \"davies_bouldin_score\" (float)\n\n        Raises:\n            ValueError: If neither `data` nor `path` is provided, or if `self.labels`\n                        remains None after fitting (indicating a subclass didn't set it).\n        \"\"\"\n        if data is None and path is None:\n            raise ValueError(\"Either 'data' or 'path' must be provided.\")\n\n        # Load/prepare data if needed\n        X = data if data is not None else self.prepare_data(path)\n\n        # Fit the model\n        self.fit(X)\n\n        # Check labels\n        if self.labels is None:\n            raise ValueError(\"Model has not assigned labels. Did you implement fit()?\")\n\n        # Compute clustering metrics\n        silhouette = silhouette_score(X, self.labels)\n        calinski_harabasz = calinski_harabasz_score(X, self.labels)\n        davies_bouldin = davies_bouldin_score(X, self.labels)\n\n        # Return results\n        return {\n            \"params\": self.get_model_params(),\n            \"silhouette_score\": silhouette,\n            \"calinski_harabasz_score\": calinski_harabasz,\n            \"davies_bouldin_score\": davies_bouldin,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.__init__","title":"<code>__init__(model_type, random_state=42)</code>","text":"<p>Initialize the base clustering class.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>A string identifier for the clustering algorithm               (e.g. \"kmeans\", \"dbscan\", etc.).</p> required <code>random_state</code> <code>int</code> <p>Seed for reproducibility where applicable.                           Defaults to 42.</p> <code>42</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def __init__(\n    self,\n    model_type: str,\n    random_state: int = 42,\n) -&gt; None:\n    \"\"\"\n    Initialize the base clustering class.\n\n    Args:\n        model_type (str): A string identifier for the clustering algorithm\n                          (e.g. \"kmeans\", \"dbscan\", etc.).\n        random_state (int, optional): Seed for reproducibility where applicable.\n                                      Defaults to 42.\n    \"\"\"\n    self.model_type = model_type\n    self.random_state = random_state\n\n    # Directory for saving plots\n    self.plots_dir = Path.cwd() / \"plots\"\n    self.plots_dir.mkdir(parents=True, exist_ok=True)\n\n    # Subclasses must set self.labels after fitting\n    self.labels: Optional[np.ndarray] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.fit","title":"<code>fit(X)</code>  <code>abstractmethod</code>","text":"<p>Fit the clustering model on a preprocessed dataset, assigning labels to <code>self.labels</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) containing             the data to be clustered.</p> required <p>Subclasses must implement this method. After fitting the model, <code>self.labels</code> should be set to an array of cluster labels of shape (n_samples,).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>@abstractmethod\ndef fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the clustering model on a preprocessed dataset, assigning labels to `self.labels`.\n\n    Args:\n        X (np.ndarray): A 2D array of shape (n_samples, n_features) containing\n                        the data to be clustered.\n\n    Subclasses must implement this method. After fitting the model,\n    `self.labels` should be set to an array of cluster labels of shape (n_samples,).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.get_model_params","title":"<code>get_model_params()</code>  <code>abstractmethod</code>","text":"<p>Return model parameters for logging or debugging.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing key model parameters and             potentially any learned attributes (e.g. number of clusters).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>@abstractmethod\ndef get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Return model parameters for logging or debugging.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing key model parameters and\n                        potentially any learned attributes (e.g. number of clusters).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.plots","title":"<code>plots(X, labels)</code>","text":"<p>Create a 2D scatter plot of clusters using PCA for dimensionality reduction.</p> Steps <ol> <li>If X has &gt;=2 features, run PCA to reduce it to 2 components.</li> <li>If X has only 1 feature, it is zero-padded to form a 2D embedding for plotting.</li> <li>Each unique cluster label is plotted with a distinct color.</li> <li>The figure is saved in <code>self.plots_dir</code> as <code>cluster_plot_{self.model_type}.png</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Data array of shape (n_samples, n_features).</p> required <code>labels</code> <code>ndarray</code> <p>Cluster labels for each sample.</p> required <p>Returns:</p> Type Description <code>Tuple[Figure, Path]</code> <p>Tuple[Figure, Path]: - The matplotlib Figure object. - The path where the figure was saved (plot_path).</p> Notes <p>Subclasses typically do not override this method. Instead, they rely on the base implementation for consistent plotting.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def plots(self, X: np.ndarray, labels: np.ndarray) -&gt; Tuple[Figure, Path]:\n    \"\"\"\n    Create a 2D scatter plot of clusters using PCA for dimensionality reduction.\n\n    Steps:\n      1. If X has &gt;=2 features, run PCA to reduce it to 2 components.\n      2. If X has only 1 feature, it is zero-padded to form a 2D embedding for plotting.\n      3. Each unique cluster label is plotted with a distinct color.\n      4. The figure is saved in `self.plots_dir` as `cluster_plot_{self.model_type}.png`.\n\n    Args:\n        X (np.ndarray): Data array of shape (n_samples, n_features).\n        labels (np.ndarray): Cluster labels for each sample.\n\n    Returns:\n        Tuple[Figure, Path]:\n          - The matplotlib Figure object.\n          - The path where the figure was saved (plot_path).\n\n    Notes:\n        Subclasses typically do not override this method. Instead, they rely on the\n        base implementation for consistent plotting.\n    \"\"\"\n    n_features = X.shape[1]\n    if n_features &gt;= 2:\n        pca = PCA(n_components=2, random_state=self.random_state)\n        X_pca = pca.fit_transform(X)\n    else:\n        # If there's only 1 feature, we simulate a second dimension with zeros\n        print(\"Dataset has only 1 feature. Zero-padding to 2D for visualization.\")\n        pca = PCA(n_components=1, random_state=self.random_state)\n        X_1d = pca.fit_transform(X)\n        X_pca = np.hstack([X_1d, np.zeros((X_1d.shape[0], 1))])\n\n    unique_labels = np.unique(labels)\n\n    fig = plt.figure(figsize=(8, 6), dpi=100)\n    ax = fig.add_subplot(111)\n\n    colors = plt.cm.rainbow(np.linspace(0, 1, len(unique_labels)))\n    for label, color in zip(unique_labels, colors):\n        mask = labels == label\n        ax.scatter(\n            X_pca[mask, 0],\n            X_pca[mask, 1],\n            color=(\"k\" if label == -1 else color),\n            label=f\"Cluster {label}\",\n            alpha=0.7,\n            s=60,\n        )\n\n    ax.set_xlabel(\"PCA Component 1\", fontsize=10)\n    ax.set_ylabel(\"PCA Component 2\", fontsize=10)\n    ax.legend(fontsize=8)\n    ax.set_title(\n        f\"{self.model_type.upper()} Clustering Results (2D PCA)\",\n        fontsize=12,\n        pad=15,\n    )\n    plt.tight_layout()\n\n    # Save the figure\n    plot_path = self.plots_dir / f\"cluster_plot_{self.model_type}.png\"\n    fig.savefig(plot_path, dpi=300, bbox_inches=\"tight\")\n    plt.close(fig)\n    return fig, plot_path\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.prepare_data","title":"<code>prepare_data(path)</code>","text":"<p>Load and preprocess data from a CSV file, returning a scaled NumPy array.</p> This method <ol> <li>Reads the CSV file into a pandas DataFrame.</li> <li>Drops rows containing NaN values.</li> <li>Selects only numeric columns from the DataFrame.</li> <li>Scales these features using scikit-learn's StandardScaler.</li> <li>Returns the scaled values as a NumPy array.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Filepath to the CSV data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A 2D array of shape (n_samples, n_features) containing         standardized numeric data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no numeric columns are found in the data.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def prepare_data(self, path: str) -&gt; np.ndarray:\n    \"\"\"\n    Load and preprocess data from a CSV file, returning a scaled NumPy array.\n\n    This method:\n      1. Reads the CSV file into a pandas DataFrame.\n      2. Drops rows containing NaN values.\n      3. Selects only numeric columns from the DataFrame.\n      4. Scales these features using scikit-learn's StandardScaler.\n      5. Returns the scaled values as a NumPy array.\n\n    Args:\n        path (str): Filepath to the CSV data file.\n\n    Returns:\n        np.ndarray: A 2D array of shape (n_samples, n_features) containing\n                    standardized numeric data.\n\n    Raises:\n        ValueError: If no numeric columns are found in the data.\n    \"\"\"\n    df = pd.read_csv(Path(path))\n    df = df.dropna()\n    numeric_columns = df.select_dtypes(include=[np.number]).columns\n    if numeric_columns.empty:\n        raise ValueError(\"No numeric columns found in the data.\")\n    features = df[numeric_columns].values\n    return StandardScaler().fit_transform(features)\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/base/#scirex.core.ml.unsupervised.clustering.base.Clustering.run","title":"<code>run(data=None, path=None)</code>","text":"<p>Run the complete clustering pipeline: data loading/preprocessing, fitting the model, and computing standard clustering metrics.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[ndarray]</code> <p>Preprocessed data array of shape (n_samples, n_features).</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Path to a CSV file from which to read data.                   If <code>data</code> is not provided, this must be specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary with the following keys: - \"params\" (Dict[str, Any]): Model parameters from <code>self.get_model_params()</code> - \"silhouette_score\" (float) - \"calinski_harabasz_score\" (float) - \"davies_bouldin_score\" (float)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>data</code> nor <code>path</code> is provided, or if <code>self.labels</code>         remains None after fitting (indicating a subclass didn't set it).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\base.py</code> <pre><code>def run(\n    self, data: Optional[np.ndarray] = None, path: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run the complete clustering pipeline: data loading/preprocessing,\n    fitting the model, and computing standard clustering metrics.\n\n    Args:\n        data (Optional[np.ndarray]): Preprocessed data array of shape (n_samples, n_features).\n        path (Optional[str]): Path to a CSV file from which to read data.\n                              If `data` is not provided, this must be specified.\n\n    Returns:\n        Dict[str, Any]: A dictionary with the following keys:\n            - \"params\" (Dict[str, Any]): Model parameters from `self.get_model_params()`\n            - \"silhouette_score\" (float)\n            - \"calinski_harabasz_score\" (float)\n            - \"davies_bouldin_score\" (float)\n\n    Raises:\n        ValueError: If neither `data` nor `path` is provided, or if `self.labels`\n                    remains None after fitting (indicating a subclass didn't set it).\n    \"\"\"\n    if data is None and path is None:\n        raise ValueError(\"Either 'data' or 'path' must be provided.\")\n\n    # Load/prepare data if needed\n    X = data if data is not None else self.prepare_data(path)\n\n    # Fit the model\n    self.fit(X)\n\n    # Check labels\n    if self.labels is None:\n        raise ValueError(\"Model has not assigned labels. Did you implement fit()?\")\n\n    # Compute clustering metrics\n    silhouette = silhouette_score(X, self.labels)\n    calinski_harabasz = calinski_harabasz_score(X, self.labels)\n    davies_bouldin = davies_bouldin_score(X, self.labels)\n\n    # Return results\n    return {\n        \"params\": self.get_model_params(),\n        \"silhouette_score\": silhouette,\n        \"calinski_harabasz_score\": calinski_harabasz,\n        \"davies_bouldin_score\": davies_bouldin,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/","title":"Dbscan","text":"<p>Module: dbscan.py</p> <p>This module provides a DBSCAN (Density-Based Spatial Clustering of Applications with Noise) implementation using scikit-learn's DBSCAN class.</p> <p>It includes an optional automated heuristic for estimating <code>eps</code> and <code>min_samples</code> by analyzing neighborhood distances. The user can override these defaults before fitting.</p> <p>Classes:</p> Name Description <code>Dbscan</code> <p>Implements DBSCAN with a simple heuristic for <code>eps</code> and <code>min_samples</code>.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.DBSCAN</li> <li>sklearn.neighbors.NearestNeighbors</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic estimation of <code>eps</code> via median k-distances</li> <li>Automatic estimation of <code>min_samples</code> via log2(n) heuristic</li> <li>Counting of discovered clusters and noise points</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan","title":"<code>Dbscan</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>DBSCAN clustering algorithm with optional automatic estimation of <code>eps</code> and <code>min_samples</code>.</p> <p>Attributes:</p> Name Type Description <code>eps</code> <code>Optional[float]</code> <p>The maximum neighborhood distance after estimation/user input.</p> <code>min_samples</code> <code>Optional[int]</code> <p>The number of samples in a neighborhood for                          a point to be considered a core point.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>The number of clusters found (excluding noise).</p> <code>n_noise</code> <code>Optional[int]</code> <p>The number of noise points labeled as -1 by DBSCAN.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>class Dbscan(Clustering):\n    \"\"\"\n    DBSCAN clustering algorithm with optional automatic estimation of `eps` and `min_samples`.\n\n    Attributes:\n        eps (Optional[float]): The maximum neighborhood distance after estimation/user input.\n        min_samples (Optional[int]): The number of samples in a neighborhood for\n                                     a point to be considered a core point.\n        n_clusters (Optional[int]): The number of clusters found (excluding noise).\n        n_noise (Optional[int]): The number of noise points labeled as -1 by DBSCAN.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the DBSCAN clustering model.\n\n        By default, `eps` and `min_samples` are not set until the user calls `.fit(...)`.\n        The final values are determined by a heuristic (plus optional user override).\n        \"\"\"\n        super().__init__(\"dbscan\")\n        self.eps: Optional[float] = None\n        self.min_samples: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n        self.n_noise: Optional[int] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the DBSCAN model to the data with a heuristic approach to determine eps and min_samples.\n\n        Args:\n            X (np.ndarray): Input data array of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples = X.shape[0]\n        rng = np.random.default_rng(self.random_state)\n\n        # Heuristic for min_samples\n        self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n        # Subsample for k-distance estimation\n        sample_size = min(1000, n_samples)\n        indices = rng.choice(n_samples, sample_size, replace=False)\n        X_sample = X[indices]\n\n        # Compute k-distance (k = min_samples)\n        nbrs = NearestNeighbors(n_neighbors=self.min_samples)\n        nbrs.fit(X_sample)\n        distances, _ = nbrs.kneighbors(X_sample)\n        k_distances = distances[\n            :, -1\n        ]  # Distance to the min_samples-th nearest neighbor\n        self.eps = float(np.median(k_distances))\n\n        print(\"Estimated parameters from heuristic:\")\n        print(f\"eps = {self.eps:.4f}, min_samples = {self.min_samples}\")\n\n        # Fit DBSCAN\n        self.model = DBSCAN(eps=self.eps, min_samples=self.min_samples)\n        self.labels = self.model.fit_predict(X)\n\n        # Compute the number of clusters (excluding noise)\n        self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n        self.n_noise = np.count_nonzero(self.labels == -1)\n\n        print(\n            f\"DBSCAN fitted with eps = {self.eps:.4f}, min_samples = {self.min_samples}\"\n        )\n        print(f\"Number of clusters found: {self.n_clusters}\")\n        print(f\"Number of noise points: {self.n_noise}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted DBSCAN model.\n\n        Returns:\n            Dict[str, Any]:\n                A dictionary containing:\n                - model_type (str)\n                - eps (float)\n                - min_samples (int)\n                - n_clusters (int)\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"eps\": self.eps,\n            \"min_samples\": self.min_samples,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the DBSCAN clustering model.</p> <p>By default, <code>eps</code> and <code>min_samples</code> are not set until the user calls <code>.fit(...)</code>. The final values are determined by a heuristic (plus optional user override).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the DBSCAN clustering model.\n\n    By default, `eps` and `min_samples` are not set until the user calls `.fit(...)`.\n    The final values are determined by a heuristic (plus optional user override).\n    \"\"\"\n    super().__init__(\"dbscan\")\n    self.eps: Optional[float] = None\n    self.min_samples: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n    self.n_noise: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan.fit","title":"<code>fit(X)</code>","text":"<p>Fit the DBSCAN model to the data with a heuristic approach to determine eps and min_samples.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input data array of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the DBSCAN model to the data with a heuristic approach to determine eps and min_samples.\n\n    Args:\n        X (np.ndarray): Input data array of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples = X.shape[0]\n    rng = np.random.default_rng(self.random_state)\n\n    # Heuristic for min_samples\n    self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n    # Subsample for k-distance estimation\n    sample_size = min(1000, n_samples)\n    indices = rng.choice(n_samples, sample_size, replace=False)\n    X_sample = X[indices]\n\n    # Compute k-distance (k = min_samples)\n    nbrs = NearestNeighbors(n_neighbors=self.min_samples)\n    nbrs.fit(X_sample)\n    distances, _ = nbrs.kneighbors(X_sample)\n    k_distances = distances[\n        :, -1\n    ]  # Distance to the min_samples-th nearest neighbor\n    self.eps = float(np.median(k_distances))\n\n    print(\"Estimated parameters from heuristic:\")\n    print(f\"eps = {self.eps:.4f}, min_samples = {self.min_samples}\")\n\n    # Fit DBSCAN\n    self.model = DBSCAN(eps=self.eps, min_samples=self.min_samples)\n    self.labels = self.model.fit_predict(X)\n\n    # Compute the number of clusters (excluding noise)\n    self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n    self.n_noise = np.count_nonzero(self.labels == -1)\n\n    print(\n        f\"DBSCAN fitted with eps = {self.eps:.4f}, min_samples = {self.min_samples}\"\n    )\n    print(f\"Number of clusters found: {self.n_clusters}\")\n    print(f\"Number of noise points: {self.n_noise}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/dbscan/#scirex.core.ml.unsupervised.clustering.dbscan.Dbscan.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted DBSCAN model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str) - eps (float) - min_samples (int) - n_clusters (int)</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\dbscan.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted DBSCAN model.\n\n    Returns:\n        Dict[str, Any]:\n            A dictionary containing:\n            - model_type (str)\n            - eps (float)\n            - min_samples (int)\n            - n_clusters (int)\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"eps\": self.eps,\n        \"min_samples\": self.min_samples,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/","title":"GMM","text":"<p>Module: gmm.py</p> <p>This module provides a Gaussian Mixture Model (GMM) clustering implementation using scikit-learn's GaussianMixture. The Gmm class automatically estimates the optimal number of components (clusters) via silhouette scores.</p> <p>Classes:</p> Name Description <code>Gmm</code> <p>Gaussian Mixture Model clustering with automatic component selection.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.mixture.GaussianMixture</li> <li>sklearn.metrics.silhouette_score</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Scans [2..max_k] for the best silhouette score</li> <li>Final model is stored, along with predicted cluster labels</li> <li>Ties into the base <code>Clustering</code> for plotting/metrics</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm","title":"<code>Gmm</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>Gaussian Mixture Model clustering with automatic component selection via silhouette scores.</p> <p>Attributes:</p> Name Type Description <code>max_k</code> <code>int</code> <p>Maximum number of components (clusters) to consider when searching          for the optimal mixture size.</p> <code>optimal_k</code> <code>Optional[int]</code> <p>The chosen (user-verified) number of components after fitting.</p> <code>model</code> <code>Optional[GaussianMixture]</code> <p>The underlying scikit-learn GaussianMixture model.</p> <code>labels</code> <code>Optional[ndarray]</code> <p>Cluster/component labels for each data point after fitting.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>class Gmm(Clustering):\n    \"\"\"\n    Gaussian Mixture Model clustering with automatic component selection via silhouette scores.\n\n    Attributes:\n        max_k (int): Maximum number of components (clusters) to consider when searching\n                     for the optimal mixture size.\n        optimal_k (Optional[int]): The chosen (user-verified) number of components after fitting.\n        model (Optional[GaussianMixture]): The underlying scikit-learn GaussianMixture model.\n        labels (Optional[np.ndarray]): Cluster/component labels for each data point after fitting.\n    \"\"\"\n\n    def __init__(self, max_k: int = 10) -&gt; None:\n        \"\"\"\n        Initialize the GMM clustering.\n\n        Args:\n            max_k (int, optional): Maximum number of components to try. Defaults to 10.\n        \"\"\"\n        super().__init__(\"gmm\")\n        self.max_k = max_k\n        self.optimal_k: Optional[int] = None\n        self.model: Optional[GaussianMixture] = None\n        self.labels: Optional[np.ndarray] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the GMM model to the data with automatic component selection.\n\n        Args:\n            X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples, n_features = X.shape\n\n        k_values = range(2, self.max_k + 1)\n        silhouettes = []\n\n        # Prepare a random generator for subsampling\n        rng = np.random.default_rng(self.random_state)\n        silhouette_sample_size = min(1000, n_samples)\n\n        # Evaluate silhouette scores for each candidate k\n        for k in k_values:\n            gmm = GaussianMixture(n_components=k, random_state=self.random_state)\n            gmm.fit(X)\n            labels = gmm.predict(X)\n\n            # Ensure at least 2 distinct clusters\n            if len(np.unique(labels)) &gt; 1:\n                # Subsample if large\n                if n_samples &gt; silhouette_sample_size:\n                    sample_indices = rng.choice(\n                        n_samples, silhouette_sample_size, replace=False\n                    )\n                    X_sample_silhouette = X[sample_indices]\n                    labels_sample = labels[sample_indices]\n                else:\n                    X_sample_silhouette = X\n                    labels_sample = labels\n\n                silhouettes.append(\n                    silhouette_score(\n                        X_sample_silhouette.reshape(-1, n_features), labels_sample\n                    )\n                )\n            else:\n                silhouettes.append(-1)  # Invalid silhouette if only one cluster\n\n        # Pick k with best silhouette\n        self.optimal_k = k_values[np.argmax(silhouettes)]\n        print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n        # Final fit\n        self.model = GaussianMixture(\n            n_components=self.optimal_k, random_state=self.random_state\n        )\n        self.labels = self.model.fit_predict(X)\n        print(f\"GMM fitted with optimal_k = {self.optimal_k}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted GMM model.\n\n        Returns:\n            Dict[str, Any]:\n                A dictionary containing:\n                - model_type (str)\n                - optimal_k (int)\n                - max_k (int)\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"optimal_k\": self.optimal_k,\n            \"max_k\": self.max_k,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm.__init__","title":"<code>__init__(max_k=10)</code>","text":"<p>Initialize the GMM clustering.</p> <p>Parameters:</p> Name Type Description Default <code>max_k</code> <code>int</code> <p>Maximum number of components to try. Defaults to 10.</p> <code>10</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>def __init__(self, max_k: int = 10) -&gt; None:\n    \"\"\"\n    Initialize the GMM clustering.\n\n    Args:\n        max_k (int, optional): Maximum number of components to try. Defaults to 10.\n    \"\"\"\n    super().__init__(\"gmm\")\n    self.max_k = max_k\n    self.optimal_k: Optional[int] = None\n    self.model: Optional[GaussianMixture] = None\n    self.labels: Optional[np.ndarray] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm.fit","title":"<code>fit(X)</code>","text":"<p>Fit the GMM model to the data with automatic component selection.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Scaled feature matrix of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the GMM model to the data with automatic component selection.\n\n    Args:\n        X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples, n_features = X.shape\n\n    k_values = range(2, self.max_k + 1)\n    silhouettes = []\n\n    # Prepare a random generator for subsampling\n    rng = np.random.default_rng(self.random_state)\n    silhouette_sample_size = min(1000, n_samples)\n\n    # Evaluate silhouette scores for each candidate k\n    for k in k_values:\n        gmm = GaussianMixture(n_components=k, random_state=self.random_state)\n        gmm.fit(X)\n        labels = gmm.predict(X)\n\n        # Ensure at least 2 distinct clusters\n        if len(np.unique(labels)) &gt; 1:\n            # Subsample if large\n            if n_samples &gt; silhouette_sample_size:\n                sample_indices = rng.choice(\n                    n_samples, silhouette_sample_size, replace=False\n                )\n                X_sample_silhouette = X[sample_indices]\n                labels_sample = labels[sample_indices]\n            else:\n                X_sample_silhouette = X\n                labels_sample = labels\n\n            silhouettes.append(\n                silhouette_score(\n                    X_sample_silhouette.reshape(-1, n_features), labels_sample\n                )\n            )\n        else:\n            silhouettes.append(-1)  # Invalid silhouette if only one cluster\n\n    # Pick k with best silhouette\n    self.optimal_k = k_values[np.argmax(silhouettes)]\n    print(f\"Estimated optimal number of clusters (optimal_k): {self.optimal_k}\")\n\n    # Final fit\n    self.model = GaussianMixture(\n        n_components=self.optimal_k, random_state=self.random_state\n    )\n    self.labels = self.model.fit_predict(X)\n    print(f\"GMM fitted with optimal_k = {self.optimal_k}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/gmm/#scirex.core.ml.unsupervised.clustering.gmm.Gmm.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted GMM model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str) - optimal_k (int) - max_k (int)</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\gmm.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted GMM model.\n\n    Returns:\n        Dict[str, Any]:\n            A dictionary containing:\n            - model_type (str)\n            - optimal_k (int)\n            - max_k (int)\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"optimal_k\": self.optimal_k,\n        \"max_k\": self.max_k,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/","title":"Hdbscan","text":"<p>Module: hdbscan.py</p> <p>This module provides an implementation of the HDBSCAN (Hierarchical Density-Based Spatial  Clustering of Applications with Noise) algorithm.</p> <p>HDBSCAN automatically finds clusters of varying densities by constructing a hierarchical tree structure and extracting stable clusters from the hierarchy using the EOM (Excess of Mass) method or another selection approach.</p> <p>Classes:</p> Name Description <code>Hdbscan</code> <p>Implements HDBSCAN with a heuristic for <code>min_cluster_size</code> and <code>min_samples</code>,      plus optional user override.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.HDBSCAN</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic heuristic for <code>min_cluster_size</code> and <code>min_samples</code></li> <li>Optional user override for parameters</li> <li>Summarizes discovered clusters and noise points</li> <li>Inherits from base <code>Clustering</code> for a consistent pipeline</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan","title":"<code>Hdbscan</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>HDBSCAN clustering with automatic heuristic for <code>min_cluster_size</code> and <code>min_samples</code>, plus optional user override.</p> <p>Attributes:</p> Name Type Description <code>min_cluster_size</code> <code>Optional[int]</code> <p>The minimum size of a cluster (in samples).</p> <code>min_samples</code> <code>Optional[int]</code> <p>The minimum number of samples in a neighborhood for                          a point to be considered a core point.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>Number of clusters discovered (excluding noise).</p> <code>n_noise</code> <code>Optional[int]</code> <p>Number of points labeled as noise (i.e., assigned label -1).</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>class Hdbscan(Clustering):\n    \"\"\"\n    HDBSCAN clustering with automatic heuristic for `min_cluster_size` and `min_samples`,\n    plus optional user override.\n\n    Attributes:\n        min_cluster_size (Optional[int]): The minimum size of a cluster (in samples).\n        min_samples (Optional[int]): The minimum number of samples in a neighborhood for\n                                     a point to be considered a core point.\n        n_clusters (Optional[int]): Number of clusters discovered (excluding noise).\n        n_noise (Optional[int]): Number of points labeled as noise (i.e., assigned label -1).\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the HDBSCAN clustering model.\n\n        By default, `min_cluster_size` and `min_samples` are computed at fit time\n        based on dataset properties, then optionally overridden by user input.\n        \"\"\"\n        super().__init__(\"hdbscan\")\n        self.min_cluster_size: Optional[int] = None\n        self.min_samples: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n        self.n_noise: Optional[int] = None\n\n    def fit(self, X: np.ndarray, expected_clusters: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Fit the HDBSCAN model to the data using a simple heuristic for initial parameters.\n\n        Args:\n            X (np.ndarray): Input data array of shape (n_samples, n_features).\n            expected_clusters (Optional[int]): Potential future extension for approximate cluster count.\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples = X.shape[0]\n\n        # Heuristic estimation of parameters\n        self.min_samples = max(1, int(np.log(n_samples)))\n        self.min_cluster_size = max(5, int(0.02 * n_samples))\n\n        print(\"Estimated parameters:\")\n        print(\n            f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n        )\n\n        # (Optional) prompt user for overrides if desired (not shown in snippet)\n        # For example: user_input = input(\"Do you want to override? ...\")\n\n        self.model = HDBSCAN(\n            min_cluster_size=self.min_cluster_size,\n            min_samples=self.min_samples,\n            cluster_selection_method=\"eom\",\n        )\n        self.model.fit(X)\n\n        self.labels = self.model.labels_\n        self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n        self.n_noise = np.count_nonzero(self.labels == -1)\n\n        print(f\"Number of clusters: {self.n_clusters}\")\n        print(f\"Number of noise points: {self.n_noise}\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the model parameters and clustering results.\n\n        Returns:\n            Dict[str, Any]:\n                - model_type (str): \"hdbscan\"\n                - min_cluster_size (int)\n                - min_samples (int)\n                - n_clusters (int)\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"min_cluster_size\": self.min_cluster_size,\n            \"min_samples\": self.min_samples,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the HDBSCAN clustering model.</p> <p>By default, <code>min_cluster_size</code> and <code>min_samples</code> are computed at fit time based on dataset properties, then optionally overridden by user input.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the HDBSCAN clustering model.\n\n    By default, `min_cluster_size` and `min_samples` are computed at fit time\n    based on dataset properties, then optionally overridden by user input.\n    \"\"\"\n    super().__init__(\"hdbscan\")\n    self.min_cluster_size: Optional[int] = None\n    self.min_samples: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n    self.n_noise: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan.fit","title":"<code>fit(X, expected_clusters=None)</code>","text":"<p>Fit the HDBSCAN model to the data using a simple heuristic for initial parameters.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input data array of shape (n_samples, n_features).</p> required <code>expected_clusters</code> <code>Optional[int]</code> <p>Potential future extension for approximate cluster count.</p> <code>None</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>def fit(self, X: np.ndarray, expected_clusters: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Fit the HDBSCAN model to the data using a simple heuristic for initial parameters.\n\n    Args:\n        X (np.ndarray): Input data array of shape (n_samples, n_features).\n        expected_clusters (Optional[int]): Potential future extension for approximate cluster count.\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples = X.shape[0]\n\n    # Heuristic estimation of parameters\n    self.min_samples = max(1, int(np.log(n_samples)))\n    self.min_cluster_size = max(5, int(0.02 * n_samples))\n\n    print(\"Estimated parameters:\")\n    print(\n        f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n    )\n\n    # (Optional) prompt user for overrides if desired (not shown in snippet)\n    # For example: user_input = input(\"Do you want to override? ...\")\n\n    self.model = HDBSCAN(\n        min_cluster_size=self.min_cluster_size,\n        min_samples=self.min_samples,\n        cluster_selection_method=\"eom\",\n    )\n    self.model.fit(X)\n\n    self.labels = self.model.labels_\n    self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n    self.n_noise = np.count_nonzero(self.labels == -1)\n\n    print(f\"Number of clusters: {self.n_clusters}\")\n    print(f\"Number of noise points: {self.n_noise}\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/hdbscan/#scirex.core.ml.unsupervised.clustering.hdbscan.Hdbscan.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get the model parameters and clustering results.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: - model_type (str): \"hdbscan\" - min_cluster_size (int) - min_samples (int) - n_clusters (int)</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\hdbscan.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the model parameters and clustering results.\n\n    Returns:\n        Dict[str, Any]:\n            - model_type (str): \"hdbscan\"\n            - min_cluster_size (int)\n            - min_samples (int)\n            - n_clusters (int)\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"min_cluster_size\": self.min_cluster_size,\n        \"min_samples\": self.min_samples,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/","title":"Kmeans","text":"<p>Module: kmeans.py</p> <p>This module provides a K-means clustering implementation using scikit-learn's MiniBatchKMeans. The Kmeans class inherits from a generic Clustering base class and offers:   - Automatic selection of the optimal number of clusters via silhouette or elbow methods   - Option for the user to input a custom number of clusters if desired</p> <p>Classes:</p> Name Description <code>Kmeans</code> <p>K-Means clustering with automatic parameter selection and optional user override.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.MiniBatchKMeans</li> <li>sklearn.metrics.silhouette_score</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Scans [2..max_k] to find the best cluster count using silhouette or elbow</li> <li>Final cluster count stored in <code>optimal_k</code>, with a fitted model and labels</li> <li>Inherits from the base <code>Clustering</code> for consistent plotting and metric computation</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans","title":"<code>Kmeans</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>K-Means clustering with automatic selection of the optimal number of clusters.</p> <p>Attributes:</p> Name Type Description <code>max_k</code> <code>int</code> <p>The maximum number of clusters to consider when scanning for the optimal cluster count.</p> <code>optimal_k</code> <code>Optional[int]</code> <p>The chosen number of clusters after fitting.</p> <code>model</code> <code>Optional[MiniBatchKMeans]</code> <p>The underlying scikit-learn MiniBatchKMeans model.</p> <code>labels</code> <code>Optional[ndarray]</code> <p>Cluster labels for each data point after fitting.</p> <code>n_clusters</code> <code>Optional[int]</code> <p>The actual number of clusters used by the final fitted model.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>class Kmeans(Clustering):\n    \"\"\"\n    K-Means clustering with automatic selection of the optimal number of clusters.\n\n    Attributes:\n        max_k (int): The maximum number of clusters to consider when scanning for the optimal cluster count.\n        optimal_k (Optional[int]): The chosen number of clusters after fitting.\n        model (Optional[MiniBatchKMeans]): The underlying scikit-learn MiniBatchKMeans model.\n        labels (Optional[np.ndarray]): Cluster labels for each data point after fitting.\n        n_clusters (Optional[int]): The actual number of clusters used by the final fitted model.\n    \"\"\"\n\n    def __init__(self, max_k: int = 10) -&gt; None:\n        \"\"\"\n        Initialize the Kmeans clustering class.\n\n        Args:\n            max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n        \"\"\"\n        super().__init__(\"kmeans\")\n        self.max_k = max_k\n        self.optimal_k: Optional[int] = None\n        self.model: Optional[MiniBatchKMeans] = None\n        self.labels: Optional[np.ndarray] = None\n        self.n_clusters: Optional[int] = None\n\n    def _calculate_elbow_scores(self, X: np.ndarray, k_values: range) -&gt; np.ndarray:\n        \"\"\"\n        Calculate inertia scores (in elbow method), then compute a \"second derivative\" style metric.\n\n        Args:\n            X (np.ndarray): Input data of shape (n_samples, n_features).\n            k_values (range): Range of k values to evaluate, e.g. range(2, max_k+1).\n\n        Returns:\n            np.ndarray: A numeric array of elbow scores, where higher indicates a stronger elbow.\n        \"\"\"\n        inertias = []\n        for k in k_values:\n            kmeans = MiniBatchKMeans(\n                n_clusters=k, random_state=self.random_state, batch_size=1000\n            )\n            kmeans.fit(X)\n            inertias.append(kmeans.inertia_)\n\n        inertias = np.array(inertias)\n\n        # First derivative of inertia\n        diffs = np.diff(inertias)\n        # Second derivative\n        diffs_r = np.diff(diffs)\n        # A ratio capturing second derivative relative to the first derivative\n        elbow_score = diffs_r / np.abs(diffs[1:])\n\n        return elbow_score\n\n    def _calculate_silhouette_scores(\n        self, X: np.ndarray, k_values: range\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate silhouette scores for each candidate k in k_values.\n\n        Steps:\n          1. For each k, fit a MiniBatchKMeans and obtain cluster labels.\n          2. Subsample large datasets (up to 1000 points) to speed silhouette calculations.\n          3. Return an array of silhouette scores, one per k.\n\n        Args:\n            X (np.ndarray): Input data of shape (n_samples, n_features).\n            k_values (range): Range of k values to evaluate, e.g. range(2, max_k+1).\n\n        Returns:\n            np.ndarray: Silhouette scores for each candidate k.\n        \"\"\"\n        silhouette_scores = []\n        sample_size = min(1000, X.shape[0])\n        rng = np.random.default_rng(self.random_state)\n\n        for k in k_values:\n            kmeans = MiniBatchKMeans(\n                n_clusters=k, random_state=self.random_state, batch_size=1000\n            )\n            labels = kmeans.fit_predict(X)\n\n            # If there's only one cluster, silhouette is invalid\n            if len(np.unique(labels)) &lt;= 1:\n                silhouette_scores.append(-1)\n                continue\n\n            # Subsample if the dataset is very large\n            if X.shape[0] &gt; sample_size:\n                indices = rng.choice(X.shape[0], sample_size, replace=False)\n                X_sample = X[indices]\n                labels_sample = labels[indices]\n            else:\n                X_sample = X\n                labels_sample = labels\n\n            score = silhouette_score(X_sample, labels_sample)\n            silhouette_scores.append(score)\n\n        return np.array(silhouette_scores)\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the K-Means model to the data with automatic cluster selection.\n\n        Steps:\n          1. Define k_values as range(2..max_k).\n          2. Compute silhouette scores and elbow scores across those k_values.\n          3. Determine an optimal k from either method (this example picks elbow).\n          4. Fit a final MiniBatchKMeans with the chosen k, storing labels and cluster count.\n\n        Args:\n            X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n        \"\"\"\n        k_values = range(2, self.max_k + 1)\n\n        # Evaluate silhouette and elbow\n        silhouette_scores = self._calculate_silhouette_scores(X, k_values)\n        elbow_scores = self._calculate_elbow_scores(X, k_values)\n\n        # Best k from silhouette = index of maximum silhouette\n        optimal_k_silhouette = k_values[np.argmax(silhouette_scores)]\n\n        # Best k from elbow = index of maximum elbow score\n        # Note: elbow_scores has length (len(k_values) - 2), so we align indexing\n        optimal_k_elbow = k_values[:-2][np.argmax(elbow_scores)]\n\n        # Choose whichever approach you'd like; here using elbow by default\n        self.optimal_k = optimal_k_elbow\n        print(f\"Optimal k from silhouette: {optimal_k_silhouette}\")\n        print(f\"Optimal k from elbow method: {self.optimal_k}\")\n\n        self.model = MiniBatchKMeans(\n            n_clusters=self.optimal_k, random_state=self.random_state, batch_size=1000\n        )\n        self.labels = self.model.fit_predict(X)\n        self.n_clusters = len(np.unique(self.labels))\n\n        print(f\"\\nKMeans fitted with {self.optimal_k} clusters\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get parameters of the fitted K-Means model.\n\n        Returns:\n            Dict[str, Any]:\n                - model_type (str): \"kmeans\"\n                - max_k (int): The maximum number of clusters originally specified\n                - n_clusters (int): The final number of clusters used\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"max_k\": self.max_k,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans.__init__","title":"<code>__init__(max_k=10)</code>","text":"<p>Initialize the Kmeans clustering class.</p> <p>Parameters:</p> Name Type Description Default <code>max_k</code> <code>int</code> <p>Maximum number of clusters to try. Defaults to 10.</p> <code>10</code> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>def __init__(self, max_k: int = 10) -&gt; None:\n    \"\"\"\n    Initialize the Kmeans clustering class.\n\n    Args:\n        max_k (int, optional): Maximum number of clusters to try. Defaults to 10.\n    \"\"\"\n    super().__init__(\"kmeans\")\n    self.max_k = max_k\n    self.optimal_k: Optional[int] = None\n    self.model: Optional[MiniBatchKMeans] = None\n    self.labels: Optional[np.ndarray] = None\n    self.n_clusters: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans.fit","title":"<code>fit(X)</code>","text":"<p>Fit the K-Means model to the data with automatic cluster selection.</p> Steps <ol> <li>Define k_values as range(2..max_k).</li> <li>Compute silhouette scores and elbow scores across those k_values.</li> <li>Determine an optimal k from either method (this example picks elbow).</li> <li>Fit a final MiniBatchKMeans with the chosen k, storing labels and cluster count.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Scaled feature matrix of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the K-Means model to the data with automatic cluster selection.\n\n    Steps:\n      1. Define k_values as range(2..max_k).\n      2. Compute silhouette scores and elbow scores across those k_values.\n      3. Determine an optimal k from either method (this example picks elbow).\n      4. Fit a final MiniBatchKMeans with the chosen k, storing labels and cluster count.\n\n    Args:\n        X (np.ndarray): Scaled feature matrix of shape (n_samples, n_features).\n    \"\"\"\n    k_values = range(2, self.max_k + 1)\n\n    # Evaluate silhouette and elbow\n    silhouette_scores = self._calculate_silhouette_scores(X, k_values)\n    elbow_scores = self._calculate_elbow_scores(X, k_values)\n\n    # Best k from silhouette = index of maximum silhouette\n    optimal_k_silhouette = k_values[np.argmax(silhouette_scores)]\n\n    # Best k from elbow = index of maximum elbow score\n    # Note: elbow_scores has length (len(k_values) - 2), so we align indexing\n    optimal_k_elbow = k_values[:-2][np.argmax(elbow_scores)]\n\n    # Choose whichever approach you'd like; here using elbow by default\n    self.optimal_k = optimal_k_elbow\n    print(f\"Optimal k from silhouette: {optimal_k_silhouette}\")\n    print(f\"Optimal k from elbow method: {self.optimal_k}\")\n\n    self.model = MiniBatchKMeans(\n        n_clusters=self.optimal_k, random_state=self.random_state, batch_size=1000\n    )\n    self.labels = self.model.fit_predict(X)\n    self.n_clusters = len(np.unique(self.labels))\n\n    print(f\"\\nKMeans fitted with {self.optimal_k} clusters\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/kmeans/#scirex.core.ml.unsupervised.clustering.kmeans.Kmeans.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get parameters of the fitted K-Means model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: - model_type (str): \"kmeans\" - max_k (int): The maximum number of clusters originally specified - n_clusters (int): The final number of clusters used</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\kmeans.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get parameters of the fitted K-Means model.\n\n    Returns:\n        Dict[str, Any]:\n            - model_type (str): \"kmeans\"\n            - max_k (int): The maximum number of clusters originally specified\n            - n_clusters (int): The final number of clusters used\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"max_k\": self.max_k,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/","title":"Optics","text":"<p>Module: optics.py</p> <p>This module provides an implementation of the OPTICS (Ordering Points To Identify Clustering Structure) clustering algorithm using scikit-learn's OPTICS. It automatically estimates minimum cluster size and minimum samples based on the dataset, and lets the user override these parameters.</p> <p>Classes:</p> Name Description <code>Optics</code> <p>An OPTICS clustering implementation with heuristic parameter estimation and optional user override.</p> Dependencies <ul> <li>numpy</li> <li>sklearn.cluster.OPTICS</li> <li>base.py (Clustering)</li> </ul> Key Features <ul> <li>Automatic estimation of <code>min_samples</code> based on dataset size (log2 heuristic)</li> <li>Automatic estimation of <code>min_cluster_size</code> (5% of data or 50, whichever is smaller,   but not less than <code>min_samples</code>)</li> <li>Computation of discovered clusters, noise points, and summary messages</li> </ul> Authors <ul> <li>Debajyoti Sahoo (debajyotis@iisc.ac.in)</li> </ul> Version Info <ul> <li>28/Dec/2024: Initial version</li> </ul>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics","title":"<code>Optics</code>","text":"<p>               Bases: <code>Clustering</code></p> <p>OPTICS clustering implementation with parameter estimation and optional user override.</p> <p>Attributes:</p> Name Type Description <code>min_samples</code> <code>int</code> <p>The minimum number of samples in a neighborhood for a point                to be considered a core point. Initialized after heuristic                or user input.</p> <code>min_cluster_size</code> <code>int</code> <p>The minimum number of samples in a cluster.                     Initialized after heuristic or user input.</p> <code>n_clusters</code> <code>int</code> <p>Number of clusters found (excluding noise).</p> <code>n_noise</code> <code>int</code> <p>Number of points labeled as noise.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>class Optics(Clustering):\n    \"\"\"\n    OPTICS clustering implementation with parameter estimation and optional user override.\n\n    Attributes:\n        min_samples (int): The minimum number of samples in a neighborhood for a point\n                           to be considered a core point. Initialized after heuristic\n                           or user input.\n        min_cluster_size (int): The minimum number of samples in a cluster.\n                                Initialized after heuristic or user input.\n        n_clusters (int): Number of clusters found (excluding noise).\n        n_noise (int): Number of points labeled as noise.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the OPTICS clustering model.\n\n        By default, `min_cluster_size` and `min_samples` are estimated after analyzing\n        dataset size. The user can override these parameters in the `.fit(...)` method.\n        \"\"\"\n        super().__init__(\"optics\")\n        self.min_samples: Optional[int] = None\n        self.min_cluster_size: Optional[int] = None\n        self.n_clusters: Optional[int] = None\n        self.n_noise: Optional[int] = None\n\n    def fit(self, X: np.ndarray) -&gt; None:\n        \"\"\"\n        Fit the OPTICS model to the data, estimating `min_cluster_size` and `min_samples`.\n\n        Args:\n            X (np.ndarray): Input data array of shape (n_samples, n_features).\n        \"\"\"\n        X = X.astype(np.float32, copy=False)\n        n_samples, n_features = X.shape\n\n        # Heuristic for min_samples\n        self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n        # Heuristic for min_cluster_size:\n        #   - Minimum of 5% of data or 50\n        #   - but not less than min_samples\n        self.min_cluster_size = max(self.min_samples, min(50, int(0.05 * n_samples)))\n\n        print(\"Estimated parameters:\")\n        print(\n            f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n        )\n\n        # Fit the OPTICS model\n        self.model = SKLearnOPTICS(\n            min_samples=self.min_samples,\n            min_cluster_size=self.min_cluster_size,\n            xi=0.05,\n            metric=\"euclidean\",\n            n_jobs=-1,\n        )\n        self.model.fit(X)\n\n        self.labels = self.model.labels_\n        self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n        self.n_noise = np.count_nonzero(self.labels == -1)\n\n        if self.n_clusters == 0:\n            print(\"Warning: No clusters found. All points labeled as noise.\")\n        else:\n            print(f\"OPTICS found {self.n_clusters} clusters\")\n            print(f\"Noise points: {self.n_noise} ({(self.n_noise/n_samples)*100:.1f}%)\")\n\n    def get_model_params(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the model parameters and clustering results.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing:\n                - model_type (str): The name of the clustering algorithm (\"optics\").\n                - min_cluster_size (int): Final min_cluster_size used.\n                - min_samples (int): Final min_samples used.\n                - n_clusters (int, optional): Number of clusters found.\n        \"\"\"\n        return {\n            \"model_type\": self.model_type,\n            \"min_cluster_size\": self.min_cluster_size,\n            \"min_samples\": self.min_samples,\n            \"n_clusters\": self.n_clusters,\n        }\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the OPTICS clustering model.</p> <p>By default, <code>min_cluster_size</code> and <code>min_samples</code> are estimated after analyzing dataset size. The user can override these parameters in the <code>.fit(...)</code> method.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the OPTICS clustering model.\n\n    By default, `min_cluster_size` and `min_samples` are estimated after analyzing\n    dataset size. The user can override these parameters in the `.fit(...)` method.\n    \"\"\"\n    super().__init__(\"optics\")\n    self.min_samples: Optional[int] = None\n    self.min_cluster_size: Optional[int] = None\n    self.n_clusters: Optional[int] = None\n    self.n_noise: Optional[int] = None\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics.fit","title":"<code>fit(X)</code>","text":"<p>Fit the OPTICS model to the data, estimating <code>min_cluster_size</code> and <code>min_samples</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input data array of shape (n_samples, n_features).</p> required Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>def fit(self, X: np.ndarray) -&gt; None:\n    \"\"\"\n    Fit the OPTICS model to the data, estimating `min_cluster_size` and `min_samples`.\n\n    Args:\n        X (np.ndarray): Input data array of shape (n_samples, n_features).\n    \"\"\"\n    X = X.astype(np.float32, copy=False)\n    n_samples, n_features = X.shape\n\n    # Heuristic for min_samples\n    self.min_samples = max(5, int(np.log2(n_samples)) + 1)\n\n    # Heuristic for min_cluster_size:\n    #   - Minimum of 5% of data or 50\n    #   - but not less than min_samples\n    self.min_cluster_size = max(self.min_samples, min(50, int(0.05 * n_samples)))\n\n    print(\"Estimated parameters:\")\n    print(\n        f\"min_cluster_size = {self.min_cluster_size}, min_samples = {self.min_samples}\"\n    )\n\n    # Fit the OPTICS model\n    self.model = SKLearnOPTICS(\n        min_samples=self.min_samples,\n        min_cluster_size=self.min_cluster_size,\n        xi=0.05,\n        metric=\"euclidean\",\n        n_jobs=-1,\n    )\n    self.model.fit(X)\n\n    self.labels = self.model.labels_\n    self.n_clusters = len(set(self.labels)) - (1 if -1 in self.labels else 0)\n    self.n_noise = np.count_nonzero(self.labels == -1)\n\n    if self.n_clusters == 0:\n        print(\"Warning: No clusters found. All points labeled as noise.\")\n    else:\n        print(f\"OPTICS found {self.n_clusters} clusters\")\n        print(f\"Noise points: {self.n_noise} ({(self.n_noise/n_samples)*100:.1f}%)\")\n</code></pre>"},{"location":"api/core/ml/unsupervised/clustering/optics/#scirex.core.ml.unsupervised.clustering.optics.Optics.get_model_params","title":"<code>get_model_params()</code>","text":"<p>Get the model parameters and clustering results.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - model_type (str): The name of the clustering algorithm (\"optics\"). - min_cluster_size (int): Final min_cluster_size used. - min_samples (int): Final min_samples used. - n_clusters (int, optional): Number of clusters found.</p> Source code in <code>scirex\\core\\ml\\unsupervised\\clustering\\optics.py</code> <pre><code>def get_model_params(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the model parameters and clustering results.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing:\n            - model_type (str): The name of the clustering algorithm (\"optics\").\n            - min_cluster_size (int): Final min_cluster_size used.\n            - min_samples (int): Final min_samples used.\n            - n_clusters (int, optional): Number of clusters found.\n    \"\"\"\n    return {\n        \"model_type\": self.model_type,\n        \"min_cluster_size\": self.min_cluster_size,\n        \"min_samples\": self.min_samples,\n        \"n_clusters\": self.n_clusters,\n    }\n</code></pre>"},{"location":"api/core/model_compression/pruning/","title":"pruning","text":""},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning","title":"<code>ModelPruning</code>","text":"<p>A reusable class for performing pruning on any model and dataset.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The base model architecture that will undergo pruning.</p> <code>pruned_model</code> <code>Model</code> <p>The model after pruning.</p> <code>baseline_model_accuracy</code> <code>float</code> <p>Accuracy of the baseline model evaluated on test data.</p> <code>pruned_model_accuracy</code> <code>float</code> <p>Accuracy of the pruned model evaluated on test data.</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>class ModelPruning:\n    \"\"\"\n    A reusable class for performing pruning on any model and dataset.\n\n    Attributes:\n        model (tf.keras.Model): The base model architecture that will undergo pruning.\n        pruned_model (tf.keras.Model): The model after pruning.\n        baseline_model_accuracy (float): Accuracy of the baseline model evaluated on test data.\n        pruned_model_accuracy (float): Accuracy of the pruned model evaluated on test data.\n    \"\"\"\n\n    def __init__(\n        self,\n        input_shape=(28, 28),\n        num_classes=10,\n        epochs=10,\n        batch_size=128,\n        validation_split=0.1,\n    ):\n        \"\"\"\n        Initializes the pruning process for a model.\n\n        :param input_shape: Shape of the input data.\n        :type input_shape: tuple\n        :param num_classes: Number of output classes.\n        :type num_classes: int\n        :param epochs: Number of epochs to train the pruned model. Default is 2.\n        :type epochs: int\n        :param batch_size: Size of the training batch. Default is 128.\n        :type batch_size: int\n        :param validation_split: Fraction of training data to be used for validation. Default is 0.1.\n        :type validation_split: float\n        \"\"\"\n        self.input_shape = input_shape\n        self.num_classes = num_classes\n        self.epochs = epochs\n        self.batch_size = batch_size\n        self.validation_split = validation_split\n        self.model = self._build_model()\n        self.pruned_model = None\n        self.baseline_model_accuracy = None\n        self.pruned_model_accuracy = None\n\n    def _build_model(self):\n        \"\"\"\n        Builds the base model architecture.\n\n        :return: A compiled Keras model.\n        :rtype: tf.keras.Model\n        \"\"\"\n        model = keras.Sequential(\n            [\n                keras.layers.InputLayer(input_shape=self.input_shape),\n                keras.layers.Reshape(target_shape=(28, 28, 1)),\n                keras.layers.Conv2D(filters=12, kernel_size=(3, 3), activation=\"relu\"),\n                keras.layers.MaxPooling2D(pool_size=(2, 2)),\n                keras.layers.Flatten(),\n                keras.layers.Dense(self.num_classes),\n            ]\n        )\n        model.compile(\n            optimizer=\"adam\",\n            loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n            metrics=[\"accuracy\"],\n        )\n        return model\n\n    def train_baseline_model(self, train_images, train_labels):\n        \"\"\"\n        Trains the baseline model without pruning.\n\n        :param train_images: Training data features.\n        :param train_labels: Training data labels.\n        \"\"\"\n        self.model.fit(\n            train_images,\n            train_labels,\n            epochs=10,\n            validation_split=self.validation_split,\n        )\n\n    def evaluate_baseline(self, test_images, test_labels):\n        \"\"\"\n        Evaluates the baseline model.\n\n        :param test_images: Test data features.\n        :param test_labels: Test data labels.\n        :return: Accuracy of the baseline model.\n        :rtype: float\n        \"\"\"\n        _, self.baseline_model_accuracy = self.model.evaluate(\n            test_images, test_labels, verbose=0\n        )\n        return self.baseline_model_accuracy\n\n    def save_baseline_model(self):\n        \"\"\"\n        Saves the baseline model to a temporary file using the .keras format.\n\n        :return: Path to the saved model file.\n        :rtype: str\n        \"\"\"\n        keras_file = tempfile.mktemp(\".keras\")\n        self.model.save(keras_file, save_format=\"keras\")  # Use the .keras format\n        return keras_file\n\n    def apply_pruning(self):\n        \"\"\"\n        Applies pruning to the base model.\n\n        :return: A pruned model.\n        :rtype: tf.keras.Model\n        \"\"\"\n        prune_low_magnitude = tfmot.sparsity.keras.prune_low_magnitude\n        batch_size = self.batch_size\n        epochs = self.epochs\n        validation_split = self.validation_split\n\n        # Ensure the model is built before accessing input_shape\n        self.model.build((None, *self.input_shape))  # Build the model\n        num_images = self.model.input_shape[1] * (\n            1 - validation_split\n        )  # Use 1 instead of 0 for axis\n\n        end_step = np.ceil(num_images / batch_size).astype(np.int32) * epochs\n\n        pruning_params = {\n            \"pruning_schedule\": tfmot.sparsity.keras.PolynomialDecay(\n                initial_sparsity=0.50,\n                final_sparsity=0.80,\n                begin_step=0,\n                end_step=end_step,\n            )\n        }\n\n        self.pruned_model = prune_low_magnitude(self.model, **pruning_params)\n        self.pruned_model.compile(\n            optimizer=\"adam\",\n            loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n            metrics=[\"accuracy\"],\n        )\n\n        return self.pruned_model\n\n    def train_pruned_model(self, train_images, train_labels):\n        \"\"\"\n        Trains the pruned model.\n\n        :param train_images: Training data features.\n        :param train_labels: Training data labels.\n        \"\"\"\n        logdir = tempfile.mkdtemp()\n\n        callbacks = [\n            tfmot.sparsity.keras.UpdatePruningStep(),\n            tfmot.sparsity.keras.PruningSummaries(log_dir=logdir),\n        ]\n\n        self.pruned_model.fit(\n            train_images,\n            train_labels,\n            batch_size=self.batch_size,\n            epochs=self.epochs,\n            validation_split=self.validation_split,\n            callbacks=callbacks,\n        )\n\n    def evaluate_pruned_model(self, test_images, test_labels):\n        \"\"\"\n        Evaluates the pruned model.\n\n        :param test_images: Test data features.\n        :param test_labels: Test data labels.\n        :return: Accuracy of the pruned model.\n        :rtype: float\n        \"\"\"\n        _, self.pruned_model_accuracy = self.pruned_model.evaluate(\n            test_images, test_labels, verbose=0\n        )\n        return self.pruned_model_accuracy\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.__init__","title":"<code>__init__(input_shape=(28, 28), num_classes=10, epochs=10, batch_size=128, validation_split=0.1)</code>","text":"<p>Initializes the pruning process for a model.</p> <p>:param input_shape: Shape of the input data. :type input_shape: tuple :param num_classes: Number of output classes. :type num_classes: int :param epochs: Number of epochs to train the pruned model. Default is 2. :type epochs: int :param batch_size: Size of the training batch. Default is 128. :type batch_size: int :param validation_split: Fraction of training data to be used for validation. Default is 0.1. :type validation_split: float</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def __init__(\n    self,\n    input_shape=(28, 28),\n    num_classes=10,\n    epochs=10,\n    batch_size=128,\n    validation_split=0.1,\n):\n    \"\"\"\n    Initializes the pruning process for a model.\n\n    :param input_shape: Shape of the input data.\n    :type input_shape: tuple\n    :param num_classes: Number of output classes.\n    :type num_classes: int\n    :param epochs: Number of epochs to train the pruned model. Default is 2.\n    :type epochs: int\n    :param batch_size: Size of the training batch. Default is 128.\n    :type batch_size: int\n    :param validation_split: Fraction of training data to be used for validation. Default is 0.1.\n    :type validation_split: float\n    \"\"\"\n    self.input_shape = input_shape\n    self.num_classes = num_classes\n    self.epochs = epochs\n    self.batch_size = batch_size\n    self.validation_split = validation_split\n    self.model = self._build_model()\n    self.pruned_model = None\n    self.baseline_model_accuracy = None\n    self.pruned_model_accuracy = None\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.apply_pruning","title":"<code>apply_pruning()</code>","text":"<p>Applies pruning to the base model.</p> <p>:return: A pruned model. :rtype: tf.keras.Model</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def apply_pruning(self):\n    \"\"\"\n    Applies pruning to the base model.\n\n    :return: A pruned model.\n    :rtype: tf.keras.Model\n    \"\"\"\n    prune_low_magnitude = tfmot.sparsity.keras.prune_low_magnitude\n    batch_size = self.batch_size\n    epochs = self.epochs\n    validation_split = self.validation_split\n\n    # Ensure the model is built before accessing input_shape\n    self.model.build((None, *self.input_shape))  # Build the model\n    num_images = self.model.input_shape[1] * (\n        1 - validation_split\n    )  # Use 1 instead of 0 for axis\n\n    end_step = np.ceil(num_images / batch_size).astype(np.int32) * epochs\n\n    pruning_params = {\n        \"pruning_schedule\": tfmot.sparsity.keras.PolynomialDecay(\n            initial_sparsity=0.50,\n            final_sparsity=0.80,\n            begin_step=0,\n            end_step=end_step,\n        )\n    }\n\n    self.pruned_model = prune_low_magnitude(self.model, **pruning_params)\n    self.pruned_model.compile(\n        optimizer=\"adam\",\n        loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n        metrics=[\"accuracy\"],\n    )\n\n    return self.pruned_model\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.evaluate_baseline","title":"<code>evaluate_baseline(test_images, test_labels)</code>","text":"<p>Evaluates the baseline model.</p> <p>:param test_images: Test data features. :param test_labels: Test data labels. :return: Accuracy of the baseline model. :rtype: float</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def evaluate_baseline(self, test_images, test_labels):\n    \"\"\"\n    Evaluates the baseline model.\n\n    :param test_images: Test data features.\n    :param test_labels: Test data labels.\n    :return: Accuracy of the baseline model.\n    :rtype: float\n    \"\"\"\n    _, self.baseline_model_accuracy = self.model.evaluate(\n        test_images, test_labels, verbose=0\n    )\n    return self.baseline_model_accuracy\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.evaluate_pruned_model","title":"<code>evaluate_pruned_model(test_images, test_labels)</code>","text":"<p>Evaluates the pruned model.</p> <p>:param test_images: Test data features. :param test_labels: Test data labels. :return: Accuracy of the pruned model. :rtype: float</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def evaluate_pruned_model(self, test_images, test_labels):\n    \"\"\"\n    Evaluates the pruned model.\n\n    :param test_images: Test data features.\n    :param test_labels: Test data labels.\n    :return: Accuracy of the pruned model.\n    :rtype: float\n    \"\"\"\n    _, self.pruned_model_accuracy = self.pruned_model.evaluate(\n        test_images, test_labels, verbose=0\n    )\n    return self.pruned_model_accuracy\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.save_baseline_model","title":"<code>save_baseline_model()</code>","text":"<p>Saves the baseline model to a temporary file using the .keras format.</p> <p>:return: Path to the saved model file. :rtype: str</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def save_baseline_model(self):\n    \"\"\"\n    Saves the baseline model to a temporary file using the .keras format.\n\n    :return: Path to the saved model file.\n    :rtype: str\n    \"\"\"\n    keras_file = tempfile.mktemp(\".keras\")\n    self.model.save(keras_file, save_format=\"keras\")  # Use the .keras format\n    return keras_file\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.train_baseline_model","title":"<code>train_baseline_model(train_images, train_labels)</code>","text":"<p>Trains the baseline model without pruning.</p> <p>:param train_images: Training data features. :param train_labels: Training data labels.</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def train_baseline_model(self, train_images, train_labels):\n    \"\"\"\n    Trains the baseline model without pruning.\n\n    :param train_images: Training data features.\n    :param train_labels: Training data labels.\n    \"\"\"\n    self.model.fit(\n        train_images,\n        train_labels,\n        epochs=10,\n        validation_split=self.validation_split,\n    )\n</code></pre>"},{"location":"api/core/model_compression/pruning/#scirex.core.model_compression.pruning.ModelPruning.train_pruned_model","title":"<code>train_pruned_model(train_images, train_labels)</code>","text":"<p>Trains the pruned model.</p> <p>:param train_images: Training data features. :param train_labels: Training data labels.</p> Source code in <code>scirex\\core\\model_compression\\pruning.py</code> <pre><code>def train_pruned_model(self, train_images, train_labels):\n    \"\"\"\n    Trains the pruned model.\n\n    :param train_images: Training data features.\n    :param train_labels: Training data labels.\n    \"\"\"\n    logdir = tempfile.mkdtemp()\n\n    callbacks = [\n        tfmot.sparsity.keras.UpdatePruningStep(),\n        tfmot.sparsity.keras.PruningSummaries(log_dir=logdir),\n    ]\n\n    self.pruned_model.fit(\n        train_images,\n        train_labels,\n        batch_size=self.batch_size,\n        epochs=self.epochs,\n        validation_split=self.validation_split,\n        callbacks=callbacks,\n    )\n</code></pre>"},{"location":"api/core/model_compression/quantization/","title":"quantization","text":""},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining","title":"<code>QuantizationAwareTraining</code>","text":"<p>A reusable class for performing quantization-aware training on any dataset.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The base model architecture.</p> <code>q_aware_model</code> <code>Model</code> <p>The quantization-aware trained model.</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>class QuantizationAwareTraining:\n    \"\"\"\n    A reusable class for performing quantization-aware training on any dataset.\n\n    Attributes:\n        model (tf.keras.Model): The base model architecture.\n        q_aware_model (tf.keras.Model): The quantization-aware trained model.\n    \"\"\"\n\n    def __init__(self, input_shape, num_classes):\n        \"\"\"\n        Initializes the model architecture.\n\n        :param input_shape: Shape of input data\n        :type input_shape: tuple\n        :param num_classes: Number of output classes.\n        :type num_classes: int\n        \"\"\"\n        self.model = self._build_model(input_shape, num_classes)\n        self.q_aware_model = None\n\n    @staticmethod\n    def _build_model(input_shape, num_classes):\n        \"\"\"\n        Builds the base model architecture.\n\n        :param input_shape: Shape of input data.\n        :type input_shape: tuple\n        :param num_classes: Number of output classes.\n        :type num_classes: int\n        :return: A Keras model.\n        :rtype: tf.keras.Model\n        \"\"\"\n        model = tf.keras.Sequential(\n            [\n                tf.keras.layers.InputLayer(input_shape=input_shape),\n                tf.keras.layers.Reshape(target_shape=input_shape + (1,)),\n                tf.keras.layers.Conv2D(\n                    filters=12, kernel_size=(3, 3), activation=\"relu\"\n                ),\n                tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),\n                tf.keras.layers.Flatten(),\n                tf.keras.layers.Dense(num_classes),\n            ]\n        )\n        return model\n\n    def train(self, train_data, train_labels, epochs=10, validation_split=0.1):\n        \"\"\"\n        Trains the base model.\n\n        :param train_data: Training dataset.\n        :type train_data: np.ndarray\n        :param train_labels: Training labels.\n        :type train_labels: np.ndarray\n        :param epochs: Number of training epochs.\n        :type epochs: int\n        :param validation_split: Fraction of training data to be used for validation.\n        :type validation_split: float\n        \"\"\"\n        self.model.compile(\n            optimizer=\"adam\",\n            loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n            metrics=[\"accuracy\"],\n        )\n        self.model.fit(\n            train_data, train_labels, epochs=epochs, validation_split=validation_split\n        )\n\n    def apply_quantization_aware_training(self):\n        \"\"\"\n        Applies quantization-aware training to the base model.\n        \"\"\"\n        quantize_model = tfmot.quantization.keras.quantize_model\n        self.q_aware_model = quantize_model(self.model)\n\n        self.q_aware_model.compile(\n            optimizer=\"adam\",\n            loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n            metrics=[\"accuracy\"],\n        )\n\n    def train_q_aware_model(\n        self, train_data, train_labels, batch_size=500, epochs=10, validation_split=0.1\n    ):\n        \"\"\"\n        Trains the quantization-aware model.\n\n        :param train_data: Training dataset.\n        :type train_data: np.ndarray\n        :param train_labels: Training labels.\n        :type train_labels: np.ndarray\n        :param batch_size: Batch size for training.\n        :type batch_size: int\n        :param epochs: Number of training epochs.\n        :type epochs: int\n        :param validation_split: Fraction of training data to be used for validation.\n        :type validation_split: float\n        \"\"\"\n        self.q_aware_model.fit(\n            train_data,\n            train_labels,\n            batch_size=batch_size,\n            epochs=epochs,\n            validation_split=validation_split,\n        )\n\n    def evaluate(self, test_data, test_labels):\n        \"\"\"\n        Evaluates both the base model and the quantized model.\n\n        :param test_data: Test dataset.\n        :type test_data: np.ndarray\n        :param test_labels: Test labels.\n        :type test_labels: np.ndarray\n        :return: Accuracy of base model and quantized model.\n        :rtype: tuple\n        \"\"\"\n        baseline_accuracy = self.model.evaluate(test_data, test_labels, verbose=0)[1]\n        q_aware_accuracy = self.q_aware_model.evaluate(\n            test_data, test_labels, verbose=0\n        )[1]\n        return baseline_accuracy, q_aware_accuracy\n\n    def convert_to_tflite(self):\n        \"\"\"\n        Converts the quantization-aware model to TensorFlow Lite format.\n\n        :return: Quantized TFLite model.\n        :rtype: bytes\n        \"\"\"\n        converter = tf.lite.TFLiteConverter.from_keras_model(self.q_aware_model)\n        converter.optimizations = [tf.lite.Optimize.DEFAULT]\n        return converter.convert()\n\n    def post_quantization(self):\n        \"\"\"\n        Applies post-training quantization to the base model.\n\n        :return: Post-quantized TFLite model.\n        :rtype: bytes\n        \"\"\"\n        converter = tf.lite.TFLiteConverter.from_keras_model(self.model)\n        converter.optimizations = [tf.lite.Optimize.DEFAULT]\n        return converter.convert()\n\n    @staticmethod\n    def save_model(model_content, filename):\n        \"\"\"\n        Saves the TFLite model to a file.\n\n        :param model_content: The TFLite model content.\n        :type model_content: bytes\n        :param filename: File name to save the model.\n        :type filename: str\n        \"\"\"\n        with open(filename, \"wb\") as f:\n            f.write(model_content)\n\n    @staticmethod\n    def measure_model_size(filepath):\n        \"\"\"\n        Measures the size of a model file.\n\n        :param filepath: Path to the model file.\n        :type filepath: str\n        :return: Size of the model in megabytes.\n        :rtype: float\n        \"\"\"\n        return os.path.getsize(filepath) / float(2**20)\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.__init__","title":"<code>__init__(input_shape, num_classes)</code>","text":"<p>Initializes the model architecture.</p> <p>:param input_shape: Shape of input data :type input_shape: tuple :param num_classes: Number of output classes. :type num_classes: int</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def __init__(self, input_shape, num_classes):\n    \"\"\"\n    Initializes the model architecture.\n\n    :param input_shape: Shape of input data\n    :type input_shape: tuple\n    :param num_classes: Number of output classes.\n    :type num_classes: int\n    \"\"\"\n    self.model = self._build_model(input_shape, num_classes)\n    self.q_aware_model = None\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.apply_quantization_aware_training","title":"<code>apply_quantization_aware_training()</code>","text":"<p>Applies quantization-aware training to the base model.</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def apply_quantization_aware_training(self):\n    \"\"\"\n    Applies quantization-aware training to the base model.\n    \"\"\"\n    quantize_model = tfmot.quantization.keras.quantize_model\n    self.q_aware_model = quantize_model(self.model)\n\n    self.q_aware_model.compile(\n        optimizer=\"adam\",\n        loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n        metrics=[\"accuracy\"],\n    )\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.convert_to_tflite","title":"<code>convert_to_tflite()</code>","text":"<p>Converts the quantization-aware model to TensorFlow Lite format.</p> <p>:return: Quantized TFLite model. :rtype: bytes</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def convert_to_tflite(self):\n    \"\"\"\n    Converts the quantization-aware model to TensorFlow Lite format.\n\n    :return: Quantized TFLite model.\n    :rtype: bytes\n    \"\"\"\n    converter = tf.lite.TFLiteConverter.from_keras_model(self.q_aware_model)\n    converter.optimizations = [tf.lite.Optimize.DEFAULT]\n    return converter.convert()\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.evaluate","title":"<code>evaluate(test_data, test_labels)</code>","text":"<p>Evaluates both the base model and the quantized model.</p> <p>:param test_data: Test dataset. :type test_data: np.ndarray :param test_labels: Test labels. :type test_labels: np.ndarray :return: Accuracy of base model and quantized model. :rtype: tuple</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def evaluate(self, test_data, test_labels):\n    \"\"\"\n    Evaluates both the base model and the quantized model.\n\n    :param test_data: Test dataset.\n    :type test_data: np.ndarray\n    :param test_labels: Test labels.\n    :type test_labels: np.ndarray\n    :return: Accuracy of base model and quantized model.\n    :rtype: tuple\n    \"\"\"\n    baseline_accuracy = self.model.evaluate(test_data, test_labels, verbose=0)[1]\n    q_aware_accuracy = self.q_aware_model.evaluate(\n        test_data, test_labels, verbose=0\n    )[1]\n    return baseline_accuracy, q_aware_accuracy\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.measure_model_size","title":"<code>measure_model_size(filepath)</code>  <code>staticmethod</code>","text":"<p>Measures the size of a model file.</p> <p>:param filepath: Path to the model file. :type filepath: str :return: Size of the model in megabytes. :rtype: float</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>@staticmethod\ndef measure_model_size(filepath):\n    \"\"\"\n    Measures the size of a model file.\n\n    :param filepath: Path to the model file.\n    :type filepath: str\n    :return: Size of the model in megabytes.\n    :rtype: float\n    \"\"\"\n    return os.path.getsize(filepath) / float(2**20)\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.post_quantization","title":"<code>post_quantization()</code>","text":"<p>Applies post-training quantization to the base model.</p> <p>:return: Post-quantized TFLite model. :rtype: bytes</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def post_quantization(self):\n    \"\"\"\n    Applies post-training quantization to the base model.\n\n    :return: Post-quantized TFLite model.\n    :rtype: bytes\n    \"\"\"\n    converter = tf.lite.TFLiteConverter.from_keras_model(self.model)\n    converter.optimizations = [tf.lite.Optimize.DEFAULT]\n    return converter.convert()\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.save_model","title":"<code>save_model(model_content, filename)</code>  <code>staticmethod</code>","text":"<p>Saves the TFLite model to a file.</p> <p>:param model_content: The TFLite model content. :type model_content: bytes :param filename: File name to save the model. :type filename: str</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>@staticmethod\ndef save_model(model_content, filename):\n    \"\"\"\n    Saves the TFLite model to a file.\n\n    :param model_content: The TFLite model content.\n    :type model_content: bytes\n    :param filename: File name to save the model.\n    :type filename: str\n    \"\"\"\n    with open(filename, \"wb\") as f:\n        f.write(model_content)\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.train","title":"<code>train(train_data, train_labels, epochs=10, validation_split=0.1)</code>","text":"<p>Trains the base model.</p> <p>:param train_data: Training dataset. :type train_data: np.ndarray :param train_labels: Training labels. :type train_labels: np.ndarray :param epochs: Number of training epochs. :type epochs: int :param validation_split: Fraction of training data to be used for validation. :type validation_split: float</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def train(self, train_data, train_labels, epochs=10, validation_split=0.1):\n    \"\"\"\n    Trains the base model.\n\n    :param train_data: Training dataset.\n    :type train_data: np.ndarray\n    :param train_labels: Training labels.\n    :type train_labels: np.ndarray\n    :param epochs: Number of training epochs.\n    :type epochs: int\n    :param validation_split: Fraction of training data to be used for validation.\n    :type validation_split: float\n    \"\"\"\n    self.model.compile(\n        optimizer=\"adam\",\n        loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n        metrics=[\"accuracy\"],\n    )\n    self.model.fit(\n        train_data, train_labels, epochs=epochs, validation_split=validation_split\n    )\n</code></pre>"},{"location":"api/core/model_compression/quantization/#scirex.core.model_compression.quantization.QuantizationAwareTraining.train_q_aware_model","title":"<code>train_q_aware_model(train_data, train_labels, batch_size=500, epochs=10, validation_split=0.1)</code>","text":"<p>Trains the quantization-aware model.</p> <p>:param train_data: Training dataset. :type train_data: np.ndarray :param train_labels: Training labels. :type train_labels: np.ndarray :param batch_size: Batch size for training. :type batch_size: int :param epochs: Number of training epochs. :type epochs: int :param validation_split: Fraction of training data to be used for validation. :type validation_split: float</p> Source code in <code>scirex\\core\\model_compression\\quantization.py</code> <pre><code>def train_q_aware_model(\n    self, train_data, train_labels, batch_size=500, epochs=10, validation_split=0.1\n):\n    \"\"\"\n    Trains the quantization-aware model.\n\n    :param train_data: Training dataset.\n    :type train_data: np.ndarray\n    :param train_labels: Training labels.\n    :type train_labels: np.ndarray\n    :param batch_size: Batch size for training.\n    :type batch_size: int\n    :param epochs: Number of training epochs.\n    :type epochs: int\n    :param validation_split: Fraction of training data to be used for validation.\n    :type validation_split: float\n    \"\"\"\n    self.q_aware_model.fit(\n        train_data,\n        train_labels,\n        batch_size=batch_size,\n        epochs=epochs,\n        validation_split=validation_split,\n    )\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/","title":"datahandler","text":"<p>Abstract Base Interface for Neural Network Data Handling in PDEs.</p> <p>This module provides the base interface for handling data transformations and tensor conversions required for neural network-based PDE solvers. It defines the essential structure for managing various data types involved in finite element computations.</p> The implementation supports <ul> <li>Finite element data processing</li> <li>Dirichlet boundary condition handling</li> <li>Test point generation and management</li> <li>Bilinear parameter tensor conversion</li> <li>Sensor data generation and handling</li> <li>Parameter management for inverse problems</li> </ul> Key classes <ul> <li>DataHandler: Abstract base class for PDE data handling</li> </ul> Note <p>All implementations assume double precision (float64) numpy arrays as inputs, with optional conversion to float32 for computational efficiency.</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> <li>tensorflow: For tensor operations</li> <li>numpy: For numerical arrays</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler","title":"<code>DataHandler</code>","text":"<p>Abstract base class for PDE solution data handling and tensor conversion.</p> <p>This class defines the interface for managing and converting various data types required in neural network-based PDE solvers. It handles transformation between numpy arrays and tensorflow tensors, and manages different aspects of the finite element computation data.</p> <p>Attributes:</p> Name Type Description <code>fespace</code> <p>Finite element space object containing mesh and element info</p> <code>domain</code> <p>Domain object containing geometric and boundary information</p> <code>dtype</code> <p>TensorFlow data type for tensor conversion (float32/float64)</p> Example <p>class MyDataHandler(DataHandler): ...     def init(self, fespace, domain): ...         super().init(fespace, domain, tf.float32) ... ...     def get_dirichlet_input(self): ...         # Implementation ...         pass ... ...     def get_test_points(self): ...         # Implementation ...         pass</p> Note <p>Concrete implementations must override: - get_dirichlet_input() - get_test_points() - get_bilinear_params_dict_as_tensors() - get_sensor_data() - get_inverse_params()</p> <p>All methods should handle type conversion between numpy arrays and tensorflow tensors consistently.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>class DataHandler:\n    \"\"\"Abstract base class for PDE solution data handling and tensor conversion.\n\n    This class defines the interface for managing and converting various data types\n    required in neural network-based PDE solvers. It handles transformation between\n    numpy arrays and tensorflow tensors, and manages different aspects of the finite\n    element computation data.\n\n    Attributes:\n        fespace: Finite element space object containing mesh and element info\n        domain: Domain object containing geometric and boundary information\n        dtype: TensorFlow data type for tensor conversion (float32/float64)\n\n    Example:\n        &gt;&gt;&gt; class MyDataHandler(DataHandler):\n        ...     def __init__(self, fespace, domain):\n        ...         super().__init__(fespace, domain, tf.float32)\n        ...\n        ...     def get_dirichlet_input(self):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def get_test_points(self):\n        ...         # Implementation\n        ...         pass\n\n    Note:\n        Concrete implementations must override:\n        - get_dirichlet_input()\n        - get_test_points()\n        - get_bilinear_params_dict_as_tensors()\n        - get_sensor_data()\n        - get_inverse_params()\n\n        All methods should handle type conversion between numpy arrays\n        and tensorflow tensors consistently.\n    \"\"\"\n\n    def __init__(self, fespace, domain, dtype):\n        \"\"\"\n        Constructor for the DataHandler class\n\n        Args:\n            fespace (FESpace2D): The FESpace2D object.\n            domain (Domain2D): The Domain2D object.\n            dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.fespace = fespace\n        self.domain = domain\n        self.dtype = dtype\n\n    @abstractmethod\n    def get_dirichlet_input(self) -&gt; tuple:\n        \"\"\"\n        This function will return the input for the Dirichlet boundary data\n\n        Args:\n            None\n\n        Returns:\n            The Dirichlet boundary data as a tuple of tensors\n        \"\"\"\n\n    @abstractmethod\n    def get_test_points(self):\n        \"\"\"\n        Get the test points for the given domain.\n\n        Args:\n            None\n\n        Returns:\n            The test points as a tensor\n        \"\"\"\n\n    @abstractmethod\n    def get_bilinear_params_dict_as_tensors(self, function) -&gt; dict:\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            function (function): The function from the example file which returns the bilinear parameters dictionary\n\n        Returns:\n            The bilinear parameters dictionary with all the values converted to tensors\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data(self, exact_sol, num_sensor_points, mesh_type, file_name=None):\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            exact_sol (function): The exact solution function\n            num_sensor_points (int): The number of sensor points\n            mesh_type (str): The type of mesh\n            file_name (str): The file name to save the sensor data\n\n        Returns:\n            The sensor data as a tensor\n        \"\"\"\n\n    @abstractmethod\n    def get_inverse_params(self, inverse_params_dict_function):\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n        Returns:\n            The inverse parameters dictionary with all the values converted to tensors\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.__init__","title":"<code>__init__(fespace, domain, dtype)</code>","text":"<p>Constructor for the DataHandler class</p> <p>Parameters:</p> Name Type Description Default <code>fespace</code> <code>FESpace2D</code> <p>The FESpace2D object.</p> required <code>domain</code> <code>Domain2D</code> <p>The Domain2D object.</p> required <code>dtype</code> <code>DType</code> <p>The tensorflow dtype to be used for all the tensors.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>def __init__(self, fespace, domain, dtype):\n    \"\"\"\n    Constructor for the DataHandler class\n\n    Args:\n        fespace (FESpace2D): The FESpace2D object.\n        domain (Domain2D): The Domain2D object.\n        dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n    Returns:\n        None\n    \"\"\"\n\n    self.fespace = fespace\n    self.domain = domain\n    self.dtype = dtype\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_bilinear_params_dict_as_tensors","title":"<code>get_bilinear_params_dict_as_tensors(function)</code>  <code>abstractmethod</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>function</code> <p>The function from the example file which returns the bilinear parameters dictionary</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The bilinear parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_bilinear_params_dict_as_tensors(self, function) -&gt; dict:\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        function (function): The function from the example file which returns the bilinear parameters dictionary\n\n    Returns:\n        The bilinear parameters dictionary with all the values converted to tensors\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_dirichlet_input","title":"<code>get_dirichlet_input()</code>  <code>abstractmethod</code>","text":"<p>This function will return the input for the Dirichlet boundary data</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The Dirichlet boundary data as a tuple of tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_dirichlet_input(self) -&gt; tuple:\n    \"\"\"\n    This function will return the input for the Dirichlet boundary data\n\n    Args:\n        None\n\n    Returns:\n        The Dirichlet boundary data as a tuple of tensors\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_inverse_params","title":"<code>get_inverse_params(inverse_params_dict_function)</code>  <code>abstractmethod</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>inverse_params_dict_function</code> <code>function</code> <p>The function from the example file which returns the inverse parameters dictionary</p> required <p>Returns:</p> Type Description <p>The inverse parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_inverse_params(self, inverse_params_dict_function):\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n    Returns:\n        The inverse parameters dictionary with all the values converted to tensors\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_sensor_data","title":"<code>get_sensor_data(exact_sol, num_sensor_points, mesh_type, file_name=None)</code>  <code>abstractmethod</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function</p> required <code>num_sensor_points</code> <code>int</code> <p>The number of sensor points</p> required <code>mesh_type</code> <code>str</code> <p>The type of mesh</p> required <code>file_name</code> <code>str</code> <p>The file name to save the sensor data</p> <code>None</code> <p>Returns:</p> Type Description <p>The sensor data as a tensor</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_sensor_data(self, exact_sol, num_sensor_points, mesh_type, file_name=None):\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        exact_sol (function): The exact solution function\n        num_sensor_points (int): The number of sensor points\n        mesh_type (str): The type of mesh\n        file_name (str): The file name to save the sensor data\n\n    Returns:\n        The sensor data as a tensor\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler/#scirex.core.sciml.fastvpinns.data.datahandler.DataHandler.get_test_points","title":"<code>get_test_points()</code>  <code>abstractmethod</code>","text":"<p>Get the test points for the given domain.</p> <p>Returns:</p> Type Description <p>The test points as a tensor</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler.py</code> <pre><code>@abstractmethod\ndef get_test_points(self):\n    \"\"\"\n    Get the test points for the given domain.\n\n    Args:\n        None\n\n    Returns:\n        The test points as a tensor\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/","title":"datahandler2","text":"<p>Two-Dimensional Data Handler Implementation for PDE Solvers.</p> <p>This module implements data handling functionality for 2D PDE problems, focusing on efficient tensor conversions and management of finite element data structures. It provides methods for converting numpy arrays to tensorflow tensors and handling various aspects of the PDE solution process.</p> The implementation supports <ul> <li>Shape function and gradient tensor management</li> <li>Dirichlet boundary data processing</li> <li>Test point generation and handling</li> <li>Sensor data management for inverse problems</li> <li>Bilinear parameter tensor conversion</li> <li>Forcing function data handling</li> </ul> Key classes <ul> <li>DataHandler2D: Implementation for 2D PDE data handling</li> </ul> Dependencies <ul> <li>tensorflow: For tensor operations</li> <li>numpy: For numerical arrays</li> <li>FESpace2D: For finite element space handling</li> <li>Domain2D: For domain management</li> </ul> Note <p>The implementation follows FastVPINNs methodology [1] for efficient handling of finite element data structures.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D","title":"<code>DataHandler2D</code>","text":"<p>               Bases: <code>DataHandler</code></p> <p>Handles data conversion and management for 2D PDE problems.</p> <p>This class implements the DataHandler interface for 2D problems, providing methods for converting finite element data to tensorflow tensors and managing various aspects of the PDE solution process.</p> <p>Attributes:</p> Name Type Description <code>fespace</code> <p>Finite element space object for mesh and element info</p> <code>domain</code> <p>Domain object for geometric information</p> <code>dtype</code> <p>TensorFlow data type for tensor conversion</p> <code>shape_val_mat_list</code> <p>Tensor of shape function values Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements</p> <code>grad_x_mat_list</code> <p>Tensor of x-derivatives Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements</p> <code>grad_y_mat_list</code> <p>Tensor of y-derivatives Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements</p> <code>x_pde_list</code> <p>Tensor of quadrature point coordinates</p> <code>forcing_function_list</code> <p>Tensor of forcing function values</p> <code>test_points</code> <p>Tensor of test point coordinates</p> Example <p>fespace = FESpace2D(mesh, elements) domain = Domain2D(bounds) handler = DataHandler2D(fespace, domain, tf.float32) dirichlet_input, dirichlet_vals = handler.get_dirichlet_input() test_points = handler.get_test_points()</p> Note <p>All input numpy arrays are assumed to be float64. The class handles conversion to the specified tensorflow dtype (typically float32) for computational efficiency.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>class DataHandler2D(DataHandler):\n    \"\"\"Handles data conversion and management for 2D PDE problems.\n\n    This class implements the DataHandler interface for 2D problems,\n    providing methods for converting finite element data to tensorflow\n    tensors and managing various aspects of the PDE solution process.\n\n    Attributes:\n        fespace: Finite element space object for mesh and element info\n        domain: Domain object for geometric information\n        dtype: TensorFlow data type for tensor conversion\n        shape_val_mat_list: Tensor of shape function values\n            Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements\n        grad_x_mat_list: Tensor of x-derivatives\n            Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements\n        grad_y_mat_list: Tensor of y-derivatives\n            Shape: List of matrices of shape (n_test_functions, n_quad_points) with length n_elements\n        x_pde_list: Tensor of quadrature point coordinates\n        forcing_function_list: Tensor of forcing function values\n        test_points: Tensor of test point coordinates\n\n    Example:\n        &gt;&gt;&gt; fespace = FESpace2D(mesh, elements)\n        &gt;&gt;&gt; domain = Domain2D(bounds)\n        &gt;&gt;&gt; handler = DataHandler2D(fespace, domain, tf.float32)\n        &gt;&gt;&gt; dirichlet_input, dirichlet_vals = handler.get_dirichlet_input()\n        &gt;&gt;&gt; test_points = handler.get_test_points()\n\n    Note:\n        All input numpy arrays are assumed to be float64. The class handles\n        conversion to the specified tensorflow dtype (typically float32)\n        for computational efficiency.\n    \"\"\"\n\n    def __init__(self, fespace, domain, dtype):\n        \"\"\"\n        Constructor for the DataHandler2D class\n\n        Args:\n            fespace (FESpace2D): The FESpace2D object.\n            domain (Domain2D): The Domain2D object.\n            dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n        Returns:\n            None\n        \"\"\"\n        # call the parent class constructor\n        super().__init__(fespace=fespace, domain=domain, dtype=dtype)\n\n        self.shape_val_mat_list = []\n        self.grad_x_mat_list = []\n        self.grad_y_mat_list = []\n        self.x_pde_list = []\n        self.forcing_function_list = []\n\n        # check if the given dtype is a valid tensorflow dtype\n        if not isinstance(self.dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        for cell_index in range(self.fespace.n_cells):\n            shape_val_mat = tf.constant(\n                self.fespace.get_shape_function_val(cell_index), dtype=self.dtype\n            )\n            grad_x_mat = tf.constant(\n                self.fespace.get_shape_function_grad_x(cell_index), dtype=self.dtype\n            )\n            grad_y_mat = tf.constant(\n                self.fespace.get_shape_function_grad_y(cell_index), dtype=self.dtype\n            )\n            x_pde = tf.constant(\n                self.fespace.get_quadrature_actual_coordinates(cell_index),\n                dtype=self.dtype,\n            )\n            forcing_function = tf.constant(\n                self.fespace.get_forcing_function_values(cell_index), dtype=self.dtype\n            )\n            self.shape_val_mat_list.append(shape_val_mat)\n            self.grad_x_mat_list.append(grad_x_mat)\n            self.grad_y_mat_list.append(grad_y_mat)\n            self.x_pde_list.append(x_pde)\n            self.forcing_function_list.append(forcing_function)\n\n        # now convert all the shapes into 3D tensors for easy multiplication\n        # input tensor - x_pde_list\n        self.x_pde_list = tf.reshape(self.x_pde_list, [-1, 2])\n\n        self.forcing_function_list = tf.concat(self.forcing_function_list, axis=1)\n\n        self.shape_val_mat_list = tf.stack(self.shape_val_mat_list, axis=0)\n        self.grad_x_mat_list = tf.stack(self.grad_x_mat_list, axis=0)\n        self.grad_y_mat_list = tf.stack(self.grad_y_mat_list, axis=0)\n\n        # test points\n        self.test_points = None\n\n    def get_dirichlet_input(self) -&gt; tuple:\n        \"\"\"\n        This function will return the input for the Dirichlet boundary data\n\n        Args:\n            None\n\n        Returns:\n            The Dirichlet boundary data as a tuple of tensors\n        \"\"\"\n        input_dirichlet, actual_dirichlet = (\n            self.fespace.generate_dirichlet_boundary_data()\n        )\n\n        # convert to tensors\n        input_dirichlet = tf.constant(input_dirichlet, dtype=self.dtype)\n        actual_dirichlet = tf.constant(actual_dirichlet, dtype=self.dtype)\n        actual_dirichlet = tf.reshape(actual_dirichlet, [-1, 1])\n\n        return input_dirichlet, actual_dirichlet\n\n    def get_test_points(self) -&gt; tf.Tensor:\n        \"\"\"\n        Get the test points for the given domain.\n\n        Args:\n            None\n\n        Returns:\n            The test points as a tensor\n        \"\"\"\n        self.test_points = self.domain.get_test_points()\n        self.test_points = tf.constant(self.test_points, dtype=self.dtype)\n        return self.test_points\n\n    def get_bilinear_params_dict_as_tensors(self, function):\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            function (function): The function from the example file which returns the bilinear parameters dictionary\n\n        Returns:\n            The bilinear parameters dictionary with all the values converted to tensors\n        \"\"\"\n        # get the dictionary of bilinear parameters\n        bilinear_params_dict = function()\n\n        # loop over all keys and convert the values to tensors\n        for key in bilinear_params_dict.keys():\n            bilinear_params_dict[key] = tf.constant(\n                bilinear_params_dict[key], dtype=self.dtype\n            )\n\n        return bilinear_params_dict\n\n    # to be used only in inverse problems\n    def get_sensor_data(\n        self, exact_sol, num_sensor_points, mesh_type, file_name=None\n    ) -&gt; tuple:\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            exact_sol (function): The exact solution function\n            num_sensor_points (int): The number of sensor points\n            mesh_type (str): The type of mesh\n            file_name (str): The file name to save the sensor data\n\n        Returns:\n            The sensor data as a tensor\n\n        Raises:\n            ValueError: If the mesh type is not internal or external\n        \"\"\"\n        print(f\"mesh_type = {mesh_type}\")\n        if mesh_type == \"internal\":\n            # Call the method to get the sensor data\n            points, sensor_values = self.fespace.get_sensor_data(\n                exact_sol, num_sensor_points\n            )\n        elif mesh_type == \"external\":\n            # Call the method to get the sensor data\n            points, sensor_values = self.fespace.get_sensor_data_external(\n                exact_sol, num_sensor_points, file_name\n            )\n        # convert the points and sensor values into tensors\n        points = tf.constant(points, dtype=self.dtype)\n        sensor_values = tf.constant(sensor_values, dtype=self.dtype)\n\n        sensor_values = tf.reshape(sensor_values, [-1, 1])\n        points = tf.reshape(points, [-1, 2])\n\n        return points, sensor_values\n\n    # get inverse param dict as tensors\n    def get_inverse_params(self, inverse_params_dict_function) -&gt; dict:\n        \"\"\"\n        Accepts a function from example file and converts all the values into tensors of the given dtype\n\n        Args:\n            inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n        Returns:\n            The inverse parameters dictionary with all the values converted to tensors\n        \"\"\"\n        # loop over all keys and convert the values to tensors\n\n        inverse_params_dict = inverse_params_dict_function()\n\n        for key in inverse_params_dict.keys():\n            inverse_params_dict[key] = tf.constant(\n                inverse_params_dict[key], dtype=self.dtype\n            )\n\n        return inverse_params_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.__init__","title":"<code>__init__(fespace, domain, dtype)</code>","text":"<p>Constructor for the DataHandler2D class</p> <p>Parameters:</p> Name Type Description Default <code>fespace</code> <code>FESpace2D</code> <p>The FESpace2D object.</p> required <code>domain</code> <code>Domain2D</code> <p>The Domain2D object.</p> required <code>dtype</code> <code>DType</code> <p>The tensorflow dtype to be used for all the tensors.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def __init__(self, fespace, domain, dtype):\n    \"\"\"\n    Constructor for the DataHandler2D class\n\n    Args:\n        fespace (FESpace2D): The FESpace2D object.\n        domain (Domain2D): The Domain2D object.\n        dtype (tf.DType): The tensorflow dtype to be used for all the tensors.\n\n    Returns:\n        None\n    \"\"\"\n    # call the parent class constructor\n    super().__init__(fespace=fespace, domain=domain, dtype=dtype)\n\n    self.shape_val_mat_list = []\n    self.grad_x_mat_list = []\n    self.grad_y_mat_list = []\n    self.x_pde_list = []\n    self.forcing_function_list = []\n\n    # check if the given dtype is a valid tensorflow dtype\n    if not isinstance(self.dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    for cell_index in range(self.fespace.n_cells):\n        shape_val_mat = tf.constant(\n            self.fespace.get_shape_function_val(cell_index), dtype=self.dtype\n        )\n        grad_x_mat = tf.constant(\n            self.fespace.get_shape_function_grad_x(cell_index), dtype=self.dtype\n        )\n        grad_y_mat = tf.constant(\n            self.fespace.get_shape_function_grad_y(cell_index), dtype=self.dtype\n        )\n        x_pde = tf.constant(\n            self.fespace.get_quadrature_actual_coordinates(cell_index),\n            dtype=self.dtype,\n        )\n        forcing_function = tf.constant(\n            self.fespace.get_forcing_function_values(cell_index), dtype=self.dtype\n        )\n        self.shape_val_mat_list.append(shape_val_mat)\n        self.grad_x_mat_list.append(grad_x_mat)\n        self.grad_y_mat_list.append(grad_y_mat)\n        self.x_pde_list.append(x_pde)\n        self.forcing_function_list.append(forcing_function)\n\n    # now convert all the shapes into 3D tensors for easy multiplication\n    # input tensor - x_pde_list\n    self.x_pde_list = tf.reshape(self.x_pde_list, [-1, 2])\n\n    self.forcing_function_list = tf.concat(self.forcing_function_list, axis=1)\n\n    self.shape_val_mat_list = tf.stack(self.shape_val_mat_list, axis=0)\n    self.grad_x_mat_list = tf.stack(self.grad_x_mat_list, axis=0)\n    self.grad_y_mat_list = tf.stack(self.grad_y_mat_list, axis=0)\n\n    # test points\n    self.test_points = None\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_bilinear_params_dict_as_tensors","title":"<code>get_bilinear_params_dict_as_tensors(function)</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>function</code> <p>The function from the example file which returns the bilinear parameters dictionary</p> required <p>Returns:</p> Type Description <p>The bilinear parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_bilinear_params_dict_as_tensors(self, function):\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        function (function): The function from the example file which returns the bilinear parameters dictionary\n\n    Returns:\n        The bilinear parameters dictionary with all the values converted to tensors\n    \"\"\"\n    # get the dictionary of bilinear parameters\n    bilinear_params_dict = function()\n\n    # loop over all keys and convert the values to tensors\n    for key in bilinear_params_dict.keys():\n        bilinear_params_dict[key] = tf.constant(\n            bilinear_params_dict[key], dtype=self.dtype\n        )\n\n    return bilinear_params_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_dirichlet_input","title":"<code>get_dirichlet_input()</code>","text":"<p>This function will return the input for the Dirichlet boundary data</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The Dirichlet boundary data as a tuple of tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_dirichlet_input(self) -&gt; tuple:\n    \"\"\"\n    This function will return the input for the Dirichlet boundary data\n\n    Args:\n        None\n\n    Returns:\n        The Dirichlet boundary data as a tuple of tensors\n    \"\"\"\n    input_dirichlet, actual_dirichlet = (\n        self.fespace.generate_dirichlet_boundary_data()\n    )\n\n    # convert to tensors\n    input_dirichlet = tf.constant(input_dirichlet, dtype=self.dtype)\n    actual_dirichlet = tf.constant(actual_dirichlet, dtype=self.dtype)\n    actual_dirichlet = tf.reshape(actual_dirichlet, [-1, 1])\n\n    return input_dirichlet, actual_dirichlet\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_inverse_params","title":"<code>get_inverse_params(inverse_params_dict_function)</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>inverse_params_dict_function</code> <code>function</code> <p>The function from the example file which returns the inverse parameters dictionary</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The inverse parameters dictionary with all the values converted to tensors</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_inverse_params(self, inverse_params_dict_function) -&gt; dict:\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        inverse_params_dict_function (function): The function from the example file which returns the inverse parameters dictionary\n\n    Returns:\n        The inverse parameters dictionary with all the values converted to tensors\n    \"\"\"\n    # loop over all keys and convert the values to tensors\n\n    inverse_params_dict = inverse_params_dict_function()\n\n    for key in inverse_params_dict.keys():\n        inverse_params_dict[key] = tf.constant(\n            inverse_params_dict[key], dtype=self.dtype\n        )\n\n    return inverse_params_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_sensor_data","title":"<code>get_sensor_data(exact_sol, num_sensor_points, mesh_type, file_name=None)</code>","text":"<p>Accepts a function from example file and converts all the values into tensors of the given dtype</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function</p> required <code>num_sensor_points</code> <code>int</code> <p>The number of sensor points</p> required <code>mesh_type</code> <code>str</code> <p>The type of mesh</p> required <code>file_name</code> <code>str</code> <p>The file name to save the sensor data</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>The sensor data as a tensor</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mesh type is not internal or external</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_sensor_data(\n    self, exact_sol, num_sensor_points, mesh_type, file_name=None\n) -&gt; tuple:\n    \"\"\"\n    Accepts a function from example file and converts all the values into tensors of the given dtype\n\n    Args:\n        exact_sol (function): The exact solution function\n        num_sensor_points (int): The number of sensor points\n        mesh_type (str): The type of mesh\n        file_name (str): The file name to save the sensor data\n\n    Returns:\n        The sensor data as a tensor\n\n    Raises:\n        ValueError: If the mesh type is not internal or external\n    \"\"\"\n    print(f\"mesh_type = {mesh_type}\")\n    if mesh_type == \"internal\":\n        # Call the method to get the sensor data\n        points, sensor_values = self.fespace.get_sensor_data(\n            exact_sol, num_sensor_points\n        )\n    elif mesh_type == \"external\":\n        # Call the method to get the sensor data\n        points, sensor_values = self.fespace.get_sensor_data_external(\n            exact_sol, num_sensor_points, file_name\n        )\n    # convert the points and sensor values into tensors\n    points = tf.constant(points, dtype=self.dtype)\n    sensor_values = tf.constant(sensor_values, dtype=self.dtype)\n\n    sensor_values = tf.reshape(sensor_values, [-1, 1])\n    points = tf.reshape(points, [-1, 2])\n\n    return points, sensor_values\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.DataHandler2D.get_test_points","title":"<code>get_test_points()</code>","text":"<p>Get the test points for the given domain.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>The test points as a tensor</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\data\\datahandler2d.py</code> <pre><code>def get_test_points(self) -&gt; tf.Tensor:\n    \"\"\"\n    Get the test points for the given domain.\n\n    Args:\n        None\n\n    Returns:\n        The test points as a tensor\n    \"\"\"\n    self.test_points = self.domain.get_test_points()\n    self.test_points = tf.constant(self.test_points, dtype=self.dtype)\n    return self.test_points\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell","title":"<code>FE2D_Cell</code>","text":"<p>A class for managing finite element computations at the cell level.</p> <p>This class handles the storage and computation of finite element values, including basis functions, quadrature rules, and transformations for a single cell in a 2D mesh.</p> <p>Attributes:</p> Name Type Description <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation</code> <code>str</code> <p>Type of geometric transformation</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>basis_function</code> <code>BasisFunction2D</code> <p>Basis function implementation</p> <code>quad_xi</code> <code>ndarray</code> <p>Xi coordinates of quadrature points</p> <code>quad_eta</code> <code>ndarray</code> <p>Eta coordinates of quadrature points</p> <code>quad_weight</code> <code>ndarray</code> <p>Quadrature weights</p> <code>jacobian</code> <code>ndarray</code> <p>Transformation Jacobian</p> <code>basis_at_quad</code> <code>ndarray</code> <p>Basis values at quadrature points</p> <code>basis_gradx_at_quad</code> <code>ndarray</code> <p>X-derivatives at quadrature points</p> <code>basis_grady_at_quad</code> <code>ndarray</code> <p>Y-derivatives at quadrature points</p> <code>quad_actual_coordinates</code> <code>ndarray</code> <p>Physical quadrature point coordinates</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) cell = FE2D_Cell( ...     cell_coordinates=coords, ...     cell_type='quad', ...     fe_order=2, ...     fe_type='lagrange', ...     quad_order=3, ...     quad_type='gauss', ...     fe_transformation_type='bilinear', ...     forcing_function=lambda x, y: x*y ... ) cell.basis_at_quad  # Get basis values at quadrature points</p> Notes <ul> <li>All gradient and derivative values are stored in the reference domain</li> <li>Jacobian and quadrature weights are combined for efficiency</li> <li>Forcing function values are typically computed in the fespace class</li> <li>Supports multiple types of transformations and element types</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>class FE2D_Cell:\n    \"\"\"\n    A class for managing finite element computations at the cell level.\n\n    This class handles the storage and computation of finite element values,\n    including basis functions, quadrature rules, and transformations for a\n    single cell in a 2D mesh.\n\n    Attributes:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n        basis_function (BasisFunction2D): Basis function implementation\n        quad_xi (np.ndarray): Xi coordinates of quadrature points\n        quad_eta (np.ndarray): Eta coordinates of quadrature points\n        quad_weight (np.ndarray): Quadrature weights\n        jacobian (np.ndarray): Transformation Jacobian\n        basis_at_quad (np.ndarray): Basis values at quadrature points\n        basis_gradx_at_quad (np.ndarray): X-derivatives at quadrature points\n        basis_grady_at_quad (np.ndarray): Y-derivatives at quadrature points\n        quad_actual_coordinates (np.ndarray): Physical quadrature point coordinates\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; cell = FE2D_Cell(\n        ...     cell_coordinates=coords,\n        ...     cell_type='quad',\n        ...     fe_order=2,\n        ...     fe_type='lagrange',\n        ...     quad_order=3,\n        ...     quad_type='gauss',\n        ...     fe_transformation_type='bilinear',\n        ...     forcing_function=lambda x, y: x*y\n        ... )\n        &gt;&gt;&gt; cell.basis_at_quad  # Get basis values at quadrature points\n\n    Notes:\n        - All gradient and derivative values are stored in the reference domain\n        - Jacobian and quadrature weights are combined for efficiency\n        - Forcing function values are typically computed in the fespace class\n        - Supports multiple types of transformations and element types\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_coordinates: np.ndarray,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        forcing_function,\n    ):\n        \"\"\"\n        Constructor for the FE2D_Cell class.\n\n        Args:\n            cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n            cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n            fe_order (int): Order of the finite element approximation\n            fe_type (str): Type of finite element basis\n            quad_order (int): Order of quadrature rule\n            quad_type (str): Type of quadrature formula\n            fe_transformation_type (str): Type of geometric transformation\n            forcing_function (callable): Source term function\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_coordinates = cell_coordinates\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.fe_transformation = fe_transformation_type\n        self.forcing_function = forcing_function\n\n        # Basis function Class\n        self.basis_function = None\n\n        # Quadrature Values\n        self.quad_xi = None\n        self.quad_eta = None\n        self.quad_weight = None\n        self.jacobian = None\n        self.mult = None\n\n        # FE Values\n        self.basis_at_quad = None\n        self.basis_gradx_at_quad = None\n        self.basis_grady_at_quad = None\n        self.basis_gradxy_at_quad = None\n        self.basis_gradxx_at_quad = None\n        self.basis_gradyy_at_quad = None\n\n        # Quadrature Coordinates\n        self.quad_actual_coordinates = None\n\n        # Forcing function values at the quadrature points\n        self.forcing_at_quad = None\n\n        # FE Transformation Class\n        self.fetransformation = None\n\n        # get instance of the FE_setup class\n        self.fe_setup = FE2DSetupMain(\n            cell_type=self.cell_type,\n            fe_order=self.fe_order,\n            fe_type=self.fe_type,\n            quad_order=self.quad_order,\n            quad_type=self.quad_type,\n        )\n\n        # Call the function to assign the basis function\n        self.assign_basis_function()\n\n        # Assign the quadrature points and weights\n        self.assign_quadrature()\n\n        # Assign the FE Transformation\n        self.assign_fe_transformation()\n\n        # calculate mult -&gt; quadrature weights * Jacobian\n        self.assign_quad_weights_and_jacobian()\n\n        # Calculate the basis function values at the quadrature points\n        self.assign_basis_values_at_quadrature_points()\n\n        # calculate the actual coordinates of the quadrature points\n        self.assign_quadrature_coordinates()\n\n        # Calculate the forcing function values at the actual quadrature points\n        # NOTE : The function is just for printing the shape of the force matrix, the\n        # actual calculation is performed on the fespace class\n        self.assign_forcing_term(self.forcing_function)\n\n        # # print the values\n        # print(\"============================================================================\")\n        # print(\"Cell Co-ord : \", self.cell_coordinates)\n        # print(\"Basis function values at the quadrature points: \\n\", self.basis_at_quad / self.mult)\n        # print(\"Basis function gradx at the quadrature points: \\n\", self.basis_gradx_at_quad)\n        # print(\"Basis function grady at the quadrature points: \\n\", self.basis_grady_at_quad)\n        # print(\"Forcing function values at the quadrature points: \\n\", self.forcing_at_quad)\n\n        # grad_x = np.array([5,6,7,8])\n        # grad_y = np.array([1,2,3,4])\n\n        # pde = np.matmul(self.basis_gradx_at_quad, grad_x.reshape(-1,1)) + np.matmul(self.basis_grady_at_quad, grad_y.reshape(-1,1))\n        # print(\"PDE values at the quadrature points: \\n\", pde)\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function class based on the cell type and the FE order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function class for the given cell type and FE order.\n        \"\"\"\n        self.basis_function = self.fe_setup.assign_basis_function()\n\n    def assign_quadrature(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_weight, self.quad_xi, self.quad_eta = (\n            self.fe_setup.assign_quadrature_rules()\n        )\n\n    def assign_fe_transformation(self) -&gt; None:\n        \"\"\"\n        Assigns the FE Transformation class based on the cell type and the FE order.\n\n        This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n        It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.fetransformation = self.fe_setup.assign_fe_transformation(\n            self.fe_transformation, self.cell_coordinates\n        )\n        # Sets cell co-ordinates for the FE Transformation\n        self.fetransformation.set_cell()\n\n        # obtains the Jacobian of the transformation\n        self.jacobian = self.fetransformation.get_jacobian(\n            self.quad_xi, self.quad_eta\n        ).reshape(-1, 1)\n\n    def assign_basis_values_at_quadrature_points(self) -&gt; None:\n        \"\"\"\n        Assigns the basis function values at the quadrature points.\n\n        This method calculates the values of the basis functions and their gradients at the quadrature points.\n        The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n        `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n        `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.basis_at_quad = []\n        self.basis_gradx_at_quad = []\n        self.basis_grady_at_quad = []\n        self.basis_gradxy_at_quad = []\n        self.basis_gradxx_at_quad = []\n        self.basis_gradyy_at_quad = []\n\n        self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n        # For Gradients we need to perform a transformation to the original cell\n        grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n        grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n        grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n            grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n        )\n\n        self.basis_gradx_at_quad = grad_x_orig\n        self.basis_grady_at_quad = grad_y_orig\n\n        self.basis_gradx_at_quad_ref = grad_x_ref\n        self.basis_grady_at_quad_ref = grad_y_ref\n\n        # get the double derivatives of the basis functions ( ref co-ordinates )\n        grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n        grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n        grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n        # get the double derivatives of the basis functions ( orig co-ordinates )\n        grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n            self.fetransformation.get_orig_from_ref_second_derivative(\n                grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n            )\n        )\n\n        # = the value\n        self.basis_gradxy_at_quad = grad_xy_orig\n        self.basis_gradxx_at_quad = grad_xx_orig\n        self.basis_gradyy_at_quad = grad_yy_orig\n\n        # Multiply each row with the quadrature weights\n        # Basis at Quad - n_test * N_quad\n        self.basis_at_quad = self.basis_at_quad * self.mult\n        self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n        self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n        self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n        self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n        self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n\n    def assign_quad_weights_and_jacobian(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature weights and the Jacobian of the transformation.\n\n        This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n        for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n        and stored in the `mult` attribute of the class.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.mult = self.quad_weight * self.jacobian.flatten()\n\n    def assign_quadrature_coordinates(self) -&gt; None:\n        \"\"\"\n        Assigns the actual coordinates of the quadrature points.\n\n        This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n        The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n        The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        actual_co_ord = []\n        for xi, eta in zip(self.quad_xi, self.quad_eta):\n            actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n        self.quad_actual_coordinates = np.array(actual_co_ord)\n\n    def assign_forcing_term(self, forcing_function) -&gt; None:\n        \"\"\"\n        Assigns the forcing function values at the quadrature points.\n\n        This function computes the values of the forcing function at the quadrature points\n        and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n        Args:\n            forcing_function (callable): The forcing function to be integrated\n\n        Returns:\n            None\n\n        Notes:\n            - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n            - This function is for backward compatibility with old code and currently assigns\n              the values as zeros. The actual calculation is performed in the fespace class.\n        \"\"\"\n        # get number of shape functions\n        n_shape_functions = self.basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n        # the actual calculation is performed in the fespace class\n\n        # for i in range(n_shape_functions):\n        #     val = 0\n        #     for q in range(self.basis_at_quad.shape[1]):\n        #         x = self.quad_actual_coordinates[q, 0]\n        #         y = self.quad_actual_coordinates[q, 1]\n        #         # print(\"f_values[q] = \",f_values[q])\n\n        #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n        #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n        #         # print(\"val = \", val)\n\n        #     f_integral[i] = val\n\n        self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.__init__","title":"<code>__init__(cell_coordinates, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, forcing_function)</code>","text":"<p>Constructor for the FE2D_Cell class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> required <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> required <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> required <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> required <code>forcing_function</code> <code>callable</code> <p>Source term function</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def __init__(\n    self,\n    cell_coordinates: np.ndarray,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    forcing_function,\n):\n    \"\"\"\n    Constructor for the FE2D_Cell class.\n\n    Args:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_coordinates = cell_coordinates\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.fe_transformation = fe_transformation_type\n    self.forcing_function = forcing_function\n\n    # Basis function Class\n    self.basis_function = None\n\n    # Quadrature Values\n    self.quad_xi = None\n    self.quad_eta = None\n    self.quad_weight = None\n    self.jacobian = None\n    self.mult = None\n\n    # FE Values\n    self.basis_at_quad = None\n    self.basis_gradx_at_quad = None\n    self.basis_grady_at_quad = None\n    self.basis_gradxy_at_quad = None\n    self.basis_gradxx_at_quad = None\n    self.basis_gradyy_at_quad = None\n\n    # Quadrature Coordinates\n    self.quad_actual_coordinates = None\n\n    # Forcing function values at the quadrature points\n    self.forcing_at_quad = None\n\n    # FE Transformation Class\n    self.fetransformation = None\n\n    # get instance of the FE_setup class\n    self.fe_setup = FE2DSetupMain(\n        cell_type=self.cell_type,\n        fe_order=self.fe_order,\n        fe_type=self.fe_type,\n        quad_order=self.quad_order,\n        quad_type=self.quad_type,\n    )\n\n    # Call the function to assign the basis function\n    self.assign_basis_function()\n\n    # Assign the quadrature points and weights\n    self.assign_quadrature()\n\n    # Assign the FE Transformation\n    self.assign_fe_transformation()\n\n    # calculate mult -&gt; quadrature weights * Jacobian\n    self.assign_quad_weights_and_jacobian()\n\n    # Calculate the basis function values at the quadrature points\n    self.assign_basis_values_at_quadrature_points()\n\n    # calculate the actual coordinates of the quadrature points\n    self.assign_quadrature_coordinates()\n\n    # Calculate the forcing function values at the actual quadrature points\n    # NOTE : The function is just for printing the shape of the force matrix, the\n    # actual calculation is performed on the fespace class\n    self.assign_forcing_term(self.forcing_function)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function class based on the cell type and the FE order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function class for the given cell type and FE order.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function class based on the cell type and the FE order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function class for the given cell type and FE order.\n    \"\"\"\n    self.basis_function = self.fe_setup.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_basis_values_at_quadrature_points","title":"<code>assign_basis_values_at_quadrature_points()</code>","text":"<p>Assigns the basis function values at the quadrature points.</p> <p>This method calculates the values of the basis functions and their gradients at the quadrature points. The basis function values are stored in <code>self.basis_at_quad</code>, while the gradients are stored in <code>self.basis_gradx_at_quad</code>, <code>self.basis_grady_at_quad</code>, <code>self.basis_gradxy_at_quad</code>, <code>self.basis_gradxx_at_quad</code>, and <code>self.basis_gradyy_at_quad</code>.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_values_at_quadrature_points(self) -&gt; None:\n    \"\"\"\n    Assigns the basis function values at the quadrature points.\n\n    This method calculates the values of the basis functions and their gradients at the quadrature points.\n    The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n    `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n    `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.basis_at_quad = []\n    self.basis_gradx_at_quad = []\n    self.basis_grady_at_quad = []\n    self.basis_gradxy_at_quad = []\n    self.basis_gradxx_at_quad = []\n    self.basis_gradyy_at_quad = []\n\n    self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n    # For Gradients we need to perform a transformation to the original cell\n    grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n    grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n    grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n        grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n    )\n\n    self.basis_gradx_at_quad = grad_x_orig\n    self.basis_grady_at_quad = grad_y_orig\n\n    self.basis_gradx_at_quad_ref = grad_x_ref\n    self.basis_grady_at_quad_ref = grad_y_ref\n\n    # get the double derivatives of the basis functions ( ref co-ordinates )\n    grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n    grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n    grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n    # get the double derivatives of the basis functions ( orig co-ordinates )\n    grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n        self.fetransformation.get_orig_from_ref_second_derivative(\n            grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n        )\n    )\n\n    # = the value\n    self.basis_gradxy_at_quad = grad_xy_orig\n    self.basis_gradxx_at_quad = grad_xx_orig\n    self.basis_gradyy_at_quad = grad_yy_orig\n\n    # Multiply each row with the quadrature weights\n    # Basis at Quad - n_test * N_quad\n    self.basis_at_quad = self.basis_at_quad * self.mult\n    self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n    self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n    self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n    self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n    self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_fe_transformation","title":"<code>assign_fe_transformation()</code>","text":"<p>Assigns the FE Transformation class based on the cell type and the FE order.</p> <p>This method assigns the appropriate FE Transformation class based on the cell type and the FE order. It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_fe_transformation(self) -&gt; None:\n    \"\"\"\n    Assigns the FE Transformation class based on the cell type and the FE order.\n\n    This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n    It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.fetransformation = self.fe_setup.assign_fe_transformation(\n        self.fe_transformation, self.cell_coordinates\n    )\n    # Sets cell co-ordinates for the FE Transformation\n    self.fetransformation.set_cell()\n\n    # obtains the Jacobian of the transformation\n    self.jacobian = self.fetransformation.get_jacobian(\n        self.quad_xi, self.quad_eta\n    ).reshape(-1, 1)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_forcing_term","title":"<code>assign_forcing_term(forcing_function)</code>","text":"<p>Assigns the forcing function values at the quadrature points.</p> <p>This function computes the values of the forcing function at the quadrature points and assigns them to the <code>forcing_at_quad</code> attribute of the FE2D_Cell object.</p> <p>Parameters:</p> Name Type Description Default <code>forcing_function</code> <code>callable</code> <p>The forcing function to be integrated</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Notes <ul> <li>The final shape of <code>forcing_at_quad</code> will be N_shape_functions x 1.</li> <li>This function is for backward compatibility with old code and currently assigns   the values as zeros. The actual calculation is performed in the fespace class.</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_forcing_term(self, forcing_function) -&gt; None:\n    \"\"\"\n    Assigns the forcing function values at the quadrature points.\n\n    This function computes the values of the forcing function at the quadrature points\n    and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n    Args:\n        forcing_function (callable): The forcing function to be integrated\n\n    Returns:\n        None\n\n    Notes:\n        - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n        - This function is for backward compatibility with old code and currently assigns\n          the values as zeros. The actual calculation is performed in the fespace class.\n    \"\"\"\n    # get number of shape functions\n    n_shape_functions = self.basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n    # the actual calculation is performed in the fespace class\n\n    # for i in range(n_shape_functions):\n    #     val = 0\n    #     for q in range(self.basis_at_quad.shape[1]):\n    #         x = self.quad_actual_coordinates[q, 0]\n    #         y = self.quad_actual_coordinates[q, 1]\n    #         # print(\"f_values[q] = \",f_values[q])\n\n    #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n    #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n    #         # print(\"val = \", val)\n\n    #     f_integral[i] = val\n\n    self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_quad_weights_and_jacobian","title":"<code>assign_quad_weights_and_jacobian()</code>","text":"<p>Assigns the quadrature weights and the Jacobian of the transformation.</p> <p>This method calculates and assigns the quadrature weights and the Jacobian of the transformation for the current cell. The quadrature weights are multiplied by the flattened Jacobian array and stored in the <code>mult</code> attribute of the class.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quad_weights_and_jacobian(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature weights and the Jacobian of the transformation.\n\n    This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n    for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n    and stored in the `mult` attribute of the class.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.mult = self.quad_weight * self.jacobian.flatten()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_quadrature","title":"<code>assign_quadrature()</code>","text":"<p>Assigns the quadrature points and weights based on the cell type and the quadrature order.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_weight, self.quad_xi, self.quad_eta = (\n        self.fe_setup.assign_quadrature_rules()\n    )\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.FE2D_Cell.assign_quadrature_coordinates","title":"<code>assign_quadrature_coordinates()</code>","text":"<p>Assigns the actual coordinates of the quadrature points.</p> <p>This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values. The Xi and Eta values are obtained from the <code>quad_xi</code> and <code>quad_eta</code> attributes of the class. The calculated coordinates are stored in the <code>quad_actual_coordinates</code> attribute as a NumPy array.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature_coordinates(self) -&gt; None:\n    \"\"\"\n    Assigns the actual coordinates of the quadrature points.\n\n    This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n    The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n    The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    actual_co_ord = []\n    for xi, eta in zip(self.quad_xi, self.quad_eta):\n        actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n    self.quad_actual_coordinates = np.array(actual_co_ord)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace","title":"<code>Fespace</code>","text":"<p>Abstract base class defining the interface for finite element spaces.</p> <p>This class provides the foundation for implementing finite element spaces, including mesh handling, element operations, and solution computations.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <p>Mesh object containing geometric information</p> <code>cells</code> <code>ndarray</code> <p>Array of cell indices</p> <code>boundary_points</code> <code>dict</code> <p>Dictionary of boundary point information</p> <code>cell_type</code> <code>str</code> <p>Type of finite element cell</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> <code>bound_function_dict</code> <code>dict</code> <p>Dictionary of boundary condition functions</p> <code>bound_condition_dict</code> <code>dict</code> <p>Dictionary of boundary condition types</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>output_path</code> <code>str</code> <p>Path for output files</p> Example <p>class MyFespace(Fespace): ...     def set_finite_elements(self): ...         # Implementation ...         pass ...     def generate_dirichlet_boundary_data(self): ...         # Implementation ...         pass ...     # Implement other abstract methods</p> Notes <ul> <li>All coordinate transformations must be implemented</li> <li>Shape function values and gradients are available in both reference and physical spaces</li> <li>Supports both internal and external sensor data for inverse problems</li> <li>Boundary conditions must be properly specified through the boundary dictionaries</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>class Fespace:\n    \"\"\"\n    Abstract base class defining the interface for finite element spaces.\n\n    This class provides the foundation for implementing finite element spaces,\n    including mesh handling, element operations, and solution computations.\n\n    Attributes:\n        mesh: Mesh object containing geometric information\n        cells (ndarray): Array of cell indices\n        boundary_points (dict): Dictionary of boundary point information\n        cell_type (str): Type of finite element cell\n        fe_order (int): Order of finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        bound_function_dict (dict): Dictionary of boundary condition functions\n        bound_condition_dict (dict): Dictionary of boundary condition types\n        forcing_function (callable): Source term function\n        output_path (str): Path for output files\n\n    Example:\n        &gt;&gt;&gt; class MyFespace(Fespace):\n        ...     def set_finite_elements(self):\n        ...         # Implementation\n        ...         pass\n        ...     def generate_dirichlet_boundary_data(self):\n        ...         # Implementation\n        ...         pass\n        ...     # Implement other abstract methods\n\n    Notes:\n        - All coordinate transformations must be implemented\n        - Shape function values and gradients are available in both\n        reference and physical spaces\n        - Supports both internal and external sensor data for\n        inverse problems\n        - Boundary conditions must be properly specified through\n        the boundary dictionaries\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n\n        Args:\n            mesh: The mesh object.\n            cells: The cells of the mesh.\n            boundary_points: The boundary points of the mesh.\n            cell_type: The type of the cell.\n            fe_order: The order of the finite element.\n            fe_type: The type of the finite element.\n            quad_order: The order of the quadrature.\n            quad_type: The type of the quadrature.\n            fe_transformation_type: The type of the finite element transformation.\n            bound_function_dict: The dictionary of the boundary functions.\n            bound_condition_dict: The dictionary of the boundary conditions.\n            forcing_function: The forcing function.\n            output_path: The path to the output directory.\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh = mesh\n        self.boundary_points = boundary_points\n        self.cells = cells\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.fe_transformation_type = fe_transformation_type\n        self.output_path = output_path\n        self.bound_function_dict = bound_function_dict\n        self.bound_condition_dict = bound_condition_dict\n        self.forcing_function = forcing_function\n\n    @abstractmethod\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data.\n\n        This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            np.ndarray: The boundary points and their values.\n\n        Notes:\n            The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual values of the shape functions.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n\n    @abstractmethod\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n            object.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        Args:\n            exact_solution (ndarray): The exact solution values.\n            num_points (int): The number of points to sample from the domain.\n\n        Returns:\n            np.ndarray: The sensor data at the given points.\n\n        Notes:\n            This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n            Methodologies to obtain sensor data for problems from a file are not implemented yet.\n            It is also not implemented for external or complex meshes.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data_external(\n        self, exact_sol, num_points: int, file_name: str\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n        Args:\n            exact_sol: The exact solution values.\n            num_points: The number of points to sample from the domain.\n            file_name: The name of the file containing the sensor data.\n\n        Returns:\n            np.ndarray: The sensor data at the given points based on the external file.\n\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path)</code>","text":"<p>The constructor of the Fespace2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <p>The mesh object.</p> required <code>cells</code> <p>The cells of the mesh.</p> required <code>boundary_points</code> <p>The boundary points of the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell.</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element.</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature.</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation.</p> required <code>bound_function_dict</code> <code>dict</code> <p>The dictionary of the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>The dictionary of the boundary conditions.</p> required <code>forcing_function</code> <p>The forcing function.</p> required <code>output_path</code> <code>str</code> <p>The path to the output directory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n\n    Args:\n        mesh: The mesh object.\n        cells: The cells of the mesh.\n        boundary_points: The boundary points of the mesh.\n        cell_type: The type of the cell.\n        fe_order: The order of the finite element.\n        fe_type: The type of the finite element.\n        quad_order: The order of the quadrature.\n        quad_type: The type of the quadrature.\n        fe_transformation_type: The type of the finite element transformation.\n        bound_function_dict: The dictionary of the boundary functions.\n        bound_condition_dict: The dictionary of the boundary conditions.\n        forcing_function: The forcing function.\n        output_path: The path to the output directory.\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh = mesh\n    self.boundary_points = boundary_points\n    self.cells = cells\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.fe_transformation_type = fe_transformation_type\n    self.output_path = output_path\n    self.bound_function_dict = bound_function_dict\n    self.bound_condition_dict = bound_condition_dict\n    self.forcing_function = forcing_function\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>  <code>abstractmethod</code>","text":"<p>Generate Dirichlet boundary data.</p> <p>This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The boundary points and their values.</p> Notes <p>The boundary points and values are stored in the <code>boundary_points</code> attribute of the <code>Fespace</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data.\n\n    This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        np.ndarray: The boundary points and their values.\n\n    Notes:\n        The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object. The forcing function is evaluated using the <code>forcing_function</code> method of the <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n        object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>  <code>abstractmethod</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>ndarray</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points.</p> Notes <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    Args:\n        exact_solution (ndarray): The exact solution values.\n        num_points (int): The number of points to sample from the domain.\n\n    Returns:\n        np.ndarray: The sensor data at the given points.\n\n    Notes:\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>  <code>abstractmethod</code>","text":"<p>This method is used to obtain the sensor data from an external file when there is no analytical solution available.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points based on the external file.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data_external(\n    self, exact_sol, num_points: int, file_name: str\n) -&gt; np.ndarray:\n    \"\"\"\n    This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n    Args:\n        exact_sol: The exact solution values.\n        num_points: The number of points to sample from the domain.\n        file_name: The name of the file containing the sensor data.\n\n    Returns:\n        np.ndarray: The sensor data at the given points based on the external file.\n\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to y.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual values of the shape functions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual values of the shape functions.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace.set_finite_elements","title":"<code>set_finite_elements()</code>  <code>abstractmethod</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D","title":"<code>Fespace2D</code>","text":"<p>               Bases: <code>Fespace</code></p> <p>Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces, including mesh generation, basis function evaluation, and boundary condition handling.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh object containing the mesh information.</p> required <code>cells</code> <code>ndarray</code> <p>The cell information from the mesh.</p> required <code>boundary_points</code> <code>dict</code> <p>The boundary points information from the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell (e.g., 'quadrilateral').</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element basis functions.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element basis functions (e.g., 'legendre').</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature rule.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature rule (e.g., 'gauss-legendre').</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation (e.g., 'affine').</p> required <code>bound_function_dict</code> <code>dict</code> <p>A dictionary containing the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>A dictionary containing the boundary conditions.</p> required <code>forcing_function</code> <code>function</code> <p>The forcing function for the problem.</p> required <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <code>generate_mesh_plot</code> <code>bool</code> <p>Flag to generate the mesh plot (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is not supported.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>class Fespace2D(Fespace):\n    \"\"\"\n    Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces,\n    including mesh generation, basis function evaluation, and boundary condition handling.\n\n    Args:\n        mesh (meshio.Mesh): The mesh object containing the mesh information.\n        cells (np.ndarray): The cell information from the mesh.\n        boundary_points (dict): The boundary points information from the mesh.\n        cell_type (str): The type of the cell (e.g., 'quadrilateral').\n        fe_order (int): The order of the finite element basis functions.\n        fe_type (str): The type of the finite element basis functions (e.g., 'legendre').\n        quad_order (int): The order of the quadrature rule.\n        quad_type (str): The type of the quadrature rule (e.g., 'gauss-legendre').\n        fe_transformation_type (str): The type of the finite element transformation (e.g., 'affine').\n        bound_function_dict (dict): A dictionary containing the boundary functions.\n        bound_condition_dict (dict): A dictionary containing the boundary conditions.\n        forcing_function (function): The forcing function for the problem.\n        output_path (str): The path to save the output files.\n        generate_mesh_plot (bool): Flag to generate the mesh plot (default: False).\n\n    Raises:\n        ValueError: If the cell type is not supported.\n\n    Returns:\n        None\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n        generate_mesh_plot: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n        \"\"\"\n        # call the constructor of the parent class\n        super().__init__(\n            mesh=mesh,\n            cells=cells,\n            boundary_points=boundary_points,\n            cell_type=cell_type,\n            fe_order=fe_order,\n            fe_type=fe_type,\n            quad_order=quad_order,\n            quad_type=quad_type,\n            fe_transformation_type=fe_transformation_type,\n            bound_function_dict=bound_function_dict,\n            bound_condition_dict=bound_condition_dict,\n            forcing_function=forcing_function,\n            output_path=output_path,\n        )\n\n        if self.cell_type == \"triangle\":\n            raise ValueError(\n                \"Triangle Mesh is not supported yet\"\n            )  # added by thivin - to remove support for triangular mesh\n\n        self.generate_mesh_plot = generate_mesh_plot\n\n        # to be calculated in the plot function\n        self.total_dofs = 0\n        self.total_boundary_dofs = 0\n\n        # to be calculated on get_boundary_data_dirichlet function\n        self.total_dirichlet_dofs = 0\n\n        # get the number of cells\n        self.n_cells = self.cells.shape[0]\n\n        self.fe_cell = []\n\n        # Function which assigns the fe_cell for each cell\n        self.set_finite_elements()\n\n        # generate the plot of the mesh\n        if self.generate_mesh_plot:\n            self.generate_plot(self.output_path)\n        # self.generate_plot(self.output_path)\n\n        # Obtain boundary Data\n        self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n        title = [\n            \"Number of Cells\",\n            \"Number of Quadrature Points\",\n            \"Number of Dirichlet Boundary Points\",\n            \"Quadrature Order\",\n            \"fe Order\",\n            \"fe Type\",\n            \"fe Transformation Type\",\n        ]\n        values = [\n            self.n_cells,\n            self.total_dofs,\n            self.total_dirichlet_dofs,\n            self.quad_order,\n            self.fe_order,\n            self.fe_type,\n            self.fe_transformation_type,\n        ]\n        # print the table\n        print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        :return: None\n        \"\"\"\n        progress_bar = tqdm(\n            total=self.n_cells,\n            desc=\"Fe2D_cell Setup\",\n            unit=\"cells_assembled\",\n            bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n            colour=\"blue\",\n            ncols=100,\n        )\n\n        dof = 0\n        for i in range(self.n_cells):\n            self.fe_cell.append(\n                FE2D_Cell(\n                    self.cells[i],\n                    self.cell_type,\n                    self.fe_order,\n                    self.fe_type,\n                    self.quad_order,\n                    self.quad_type,\n                    self.fe_transformation_type,\n                    self.forcing_function,\n                )\n            )\n\n            # obtain the shape of the basis function (n_test, N_quad)\n            dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n            progress_bar.update(1)\n        # print the Shape details of all the matrices from cell 0 using print_table function\n        title = [\n            \"Shape function Matrix Shape\",\n            \"Shape function Gradient Matrix Shape\",\n            \"Jacobian Matrix Shape\",\n            \"Quadrature Points Shape\",\n            \"Quadrature Weights Shape\",\n            \"Quadrature Actual Coordinates Shape\",\n            \"Forcing Function Shape\",\n        ]\n        values = [\n            self.fe_cell[0].basis_at_quad.shape,\n            self.fe_cell[0].basis_gradx_at_quad.shape,\n            self.fe_cell[0].jacobian.shape,\n            self.fe_cell[0].quad_xi.shape,\n            self.fe_cell[0].quad_weight.shape,\n            self.fe_cell[0].quad_actual_coordinates.shape,\n            self.fe_cell[0].forcing_at_quad.shape,\n        ]\n        print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n        # update the total number of dofs\n        self.total_dofs = dof\n\n    def generate_plot(self, output_path) -&gt; None:\n        \"\"\"\n        Generate a plot of the mesh.\n\n        Args:\n            output_path (str): The path to save the output files.\n\n        Returns:\n            None\n        \"\"\"\n        total_quad = 0\n        marker_list = [\n            \"o\",\n            \".\",\n            \",\",\n            \"x\",\n            \"+\",\n            \"P\",\n            \"s\",\n            \"D\",\n            \"d\",\n            \"^\",\n            \"v\",\n            \"&lt;\",\n            \"&gt;\",\n            \"p\",\n            \"h\",\n            \"H\",\n        ]\n\n        print(f\"[INFO] : Generating the plot of the mesh\")\n        # Plot the mesh\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # label flag ( to add the label only once)\n        label_set = False\n\n        # plot every cell as a quadrilateral\n        # loop over all the cells\n        for i in range(self.n_cells):\n            # get the coordinates of the cell\n            x = self.fe_cell[i].cell_coordinates[:, 0]\n            y = self.fe_cell[i].cell_coordinates[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            plt.plot(x, y, \"k-\", linewidth=0.5)\n\n            # plot the quadrature points\n            x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n            y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n            total_quad += x_quad.shape[0]\n\n            if not label_set:\n                plt.scatter(\n                    x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n                )\n                label_set = True\n            else:\n                plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n        self.total_dofs = total_quad\n\n        bound_dof = 0\n        # plot the boundary points\n        # loop over all the boundary tags\n        for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n            # get the coordinates of the boundary points\n            x = bound_pts[:, 0]\n            y = bound_pts[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            bound_dof += x.shape[0]\n\n            plt.scatter(\n                x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n            )\n\n        self.total_boundary_dofs = bound_dof\n\n        plt.legend(bbox_to_anchor=(0.85, 1.02))\n        plt.axis(\"equal\")\n        plt.axis(\"off\")\n        plt.tight_layout()\n\n        plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n        plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n        # print the total number of quadrature points\n        print(f\"Plots generated\")\n        print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n        print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n        print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n                ).reshape(-1, 1)\n                y.append(val)\n\n        print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n        self.total_dirichlet_dofs = len(x)\n        print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n        print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n        return x, y\n\n    def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n        \"\"\"\n        Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n        Args:\n            component (int): The component of the boundary data vector.\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                    dtype=np.float64,\n                ).reshape(-1, 1)\n                y.append(val)\n\n        return x, y\n\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_at_quad.copy()\n\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n\n    def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Return the quadrature weights for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n        Returns:\n            np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n        Raises:\n            ValueError: If cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].mult.copy()\n\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n        # so that it can be used to handle multiple dimensions on a vector valud problem\n\n        # get number of shape functions\n        n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        for i in range(n_shape_functions):\n            val = 0\n            for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n                x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n                y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n                # print(\"f_values[q] = \",f_values[q])\n\n                # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n                val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                    cell_index\n                ].forcing_function(x, y)\n                # print(\"val = \", val)\n\n            f_integral[i] = val\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_forcing_function_values_vector(\n        self, cell_index: int, component: int\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This function will return the forcing function values at the quadrature points\n        based on the Component of the RHS Needed, for vector valued problems\n\n        Args:\n            cell_index (int): The index of the cell.\n            component (int): The component of the forcing function.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # get the coordinates\n        x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n        y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n        # compute the forcing function values\n        f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n        # compute the integral\n        f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_sensor_data(self, exact_solution, num_points: int):\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n        Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n\n        Args:\n            exact_solution (function): The exact solution function.\n            num_points (int): The number of points to sample.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n        \"\"\"\n        # generate random points within the bounds of the domain\n        # get the bounds of the domain\n        x_min = np.min(self.mesh.points[:, 0])\n        x_max = np.max(self.mesh.points[:, 0])\n        y_min = np.min(self.mesh.points[:, 1])\n        y_max = np.max(self.mesh.points[:, 1])\n        # sample n random points within the bounds of the domain\n        # Generate points in the unit square\n\n        num_internal_points = int(num_points * 0.9)\n\n        points = lhs(2, samples=num_internal_points)\n        points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n        points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n        # get the exact solution at the points\n        exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n        # print the shape of the points and the exact solution\n        print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n        print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n        # plot the points\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n        plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n        plt.axis(\"equal\")\n        plt.title(\"Sensor Points\")\n        plt.tight_layout()\n        plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n        return points, exact_sol\n\n    def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n        \"\"\"\n        This method is used to obtain the sensor data from an external file.\n\n        Args:\n            exact_sol (function): The exact solution function.\n            num_points (int): The number of points to sample.\n            file_name (str): The name of the file containing the sensor data.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n        Note:\n            This method reads the sensor data from a file and samples `num_points` from the data.\n            The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n        \"\"\"\n        # use pandas to read the file\n        df = pd.read_csv(file_name)\n\n        x = df.iloc[:, 0].values\n        y = df.iloc[:, 1].values\n        exact_sol = df.iloc[:, 2].values\n\n        # now sample num_points from the data\n        indices = np.random.randint(0, x.shape[0], num_points)\n\n        x = x[indices]\n        y = y[indices]\n        exact_sol = exact_sol[indices]\n\n        # stack them together\n        points = np.stack((x, y), axis=1)\n\n        return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path, generate_mesh_plot=False)</code>","text":"<p>The constructor of the Fespace2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n    generate_mesh_plot: bool = False,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n    \"\"\"\n    # call the constructor of the parent class\n    super().__init__(\n        mesh=mesh,\n        cells=cells,\n        boundary_points=boundary_points,\n        cell_type=cell_type,\n        fe_order=fe_order,\n        fe_type=fe_type,\n        quad_order=quad_order,\n        quad_type=quad_type,\n        fe_transformation_type=fe_transformation_type,\n        bound_function_dict=bound_function_dict,\n        bound_condition_dict=bound_condition_dict,\n        forcing_function=forcing_function,\n        output_path=output_path,\n    )\n\n    if self.cell_type == \"triangle\":\n        raise ValueError(\n            \"Triangle Mesh is not supported yet\"\n        )  # added by thivin - to remove support for triangular mesh\n\n    self.generate_mesh_plot = generate_mesh_plot\n\n    # to be calculated in the plot function\n    self.total_dofs = 0\n    self.total_boundary_dofs = 0\n\n    # to be calculated on get_boundary_data_dirichlet function\n    self.total_dirichlet_dofs = 0\n\n    # get the number of cells\n    self.n_cells = self.cells.shape[0]\n\n    self.fe_cell = []\n\n    # Function which assigns the fe_cell for each cell\n    self.set_finite_elements()\n\n    # generate the plot of the mesh\n    if self.generate_mesh_plot:\n        self.generate_plot(self.output_path)\n    # self.generate_plot(self.output_path)\n\n    # Obtain boundary Data\n    self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n    title = [\n        \"Number of Cells\",\n        \"Number of Quadrature Points\",\n        \"Number of Dirichlet Boundary Points\",\n        \"Quadrature Order\",\n        \"fe Order\",\n        \"fe Type\",\n        \"fe Transformation Type\",\n    ]\n    values = [\n        self.n_cells,\n        self.total_dofs,\n        self.total_dirichlet_dofs,\n        self.quad_order,\n        self.fe_order,\n        self.fe_type,\n        self.fe_transformation_type,\n    ]\n    # print the table\n    print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>","text":"<p>Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n            ).reshape(-1, 1)\n            y.append(val)\n\n    print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n    self.total_dirichlet_dofs = len(x)\n    print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n    print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.generate_dirichlet_boundary_data_vector","title":"<code>generate_dirichlet_boundary_data_vector(component)</code>","text":"<p>Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>int</code> <p>The component of the boundary data vector.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n    \"\"\"\n    Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n    Args:\n        component (int): The component of the boundary data vector.\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                dtype=np.float64,\n            ).reshape(-1, 1)\n            y.append(val)\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.generate_plot","title":"<code>generate_plot(output_path)</code>","text":"<p>Generate a plot of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_plot(self, output_path) -&gt; None:\n    \"\"\"\n    Generate a plot of the mesh.\n\n    Args:\n        output_path (str): The path to save the output files.\n\n    Returns:\n        None\n    \"\"\"\n    total_quad = 0\n    marker_list = [\n        \"o\",\n        \".\",\n        \",\",\n        \"x\",\n        \"+\",\n        \"P\",\n        \"s\",\n        \"D\",\n        \"d\",\n        \"^\",\n        \"v\",\n        \"&lt;\",\n        \"&gt;\",\n        \"p\",\n        \"h\",\n        \"H\",\n    ]\n\n    print(f\"[INFO] : Generating the plot of the mesh\")\n    # Plot the mesh\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # label flag ( to add the label only once)\n    label_set = False\n\n    # plot every cell as a quadrilateral\n    # loop over all the cells\n    for i in range(self.n_cells):\n        # get the coordinates of the cell\n        x = self.fe_cell[i].cell_coordinates[:, 0]\n        y = self.fe_cell[i].cell_coordinates[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        plt.plot(x, y, \"k-\", linewidth=0.5)\n\n        # plot the quadrature points\n        x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n        y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n        total_quad += x_quad.shape[0]\n\n        if not label_set:\n            plt.scatter(\n                x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n            )\n            label_set = True\n        else:\n            plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n    self.total_dofs = total_quad\n\n    bound_dof = 0\n    # plot the boundary points\n    # loop over all the boundary tags\n    for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n        # get the coordinates of the boundary points\n        x = bound_pts[:, 0]\n        y = bound_pts[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        bound_dof += x.shape[0]\n\n        plt.scatter(\n            x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n        )\n\n    self.total_boundary_dofs = bound_dof\n\n    plt.legend(bbox_to_anchor=(0.85, 1.02))\n    plt.axis(\"equal\")\n    plt.axis(\"off\")\n    plt.tight_layout()\n\n    plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n    plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n    # print the total number of quadrature points\n    print(f\"Plots generated\")\n    print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n    print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n    print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n    # so that it can be used to handle multiple dimensions on a vector valud problem\n\n    # get number of shape functions\n    n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    for i in range(n_shape_functions):\n        val = 0\n        for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n            x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n            y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n            # print(\"f_values[q] = \",f_values[q])\n\n            # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n            val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                cell_index\n            ].forcing_function(x, y)\n            # print(\"val = \", val)\n\n        f_integral[i] = val\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_forcing_function_values_vector","title":"<code>get_forcing_function_values_vector(cell_index, component)</code>","text":"<p>This function will return the forcing function values at the quadrature points based on the Component of the RHS Needed, for vector valued problems</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <code>component</code> <code>int</code> <p>The component of the forcing function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values_vector(\n    self, cell_index: int, component: int\n) -&gt; np.ndarray:\n    \"\"\"\n    This function will return the forcing function values at the quadrature points\n    based on the Component of the RHS Needed, for vector valued problems\n\n    Args:\n        cell_index (int): The index of the cell.\n        component (int): The component of the forcing function.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # get the coordinates\n    x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n    y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n    # compute the forcing function values\n    f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n    # compute the integral\n    f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_quadrature_weights","title":"<code>get_quadrature_weights(cell_index)</code>","text":"<p>Return the quadrature weights for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell for which the quadrature weights are needed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Return the quadrature weights for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n    Returns:\n        np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n    Raises:\n        ValueError: If cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].mult.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data(self, exact_solution, num_points: int):\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n    Currently, it only works for problems with an analytical solution.\n    Methodologies to obtain sensor data for problems from a file are not implemented yet.\n    It is also not implemented for external or complex meshes.\n\n    Args:\n        exact_solution (function): The exact solution function.\n        num_points (int): The number of points to sample.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n    \"\"\"\n    # generate random points within the bounds of the domain\n    # get the bounds of the domain\n    x_min = np.min(self.mesh.points[:, 0])\n    x_max = np.max(self.mesh.points[:, 0])\n    y_min = np.min(self.mesh.points[:, 1])\n    y_max = np.max(self.mesh.points[:, 1])\n    # sample n random points within the bounds of the domain\n    # Generate points in the unit square\n\n    num_internal_points = int(num_points * 0.9)\n\n    points = lhs(2, samples=num_internal_points)\n    points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n    points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n    # get the exact solution at the points\n    exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n    # print the shape of the points and the exact solution\n    print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n    print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n    # plot the points\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n    plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n    plt.axis(\"equal\")\n    plt.title(\"Sensor Points\")\n    plt.tight_layout()\n    plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>","text":"<p>This method is used to obtain the sensor data from an external file.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Note <p>This method reads the sensor data from a file and samples <code>num_points</code> from the data. The sensor data is then returned as a tuple containing the sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n    \"\"\"\n    This method is used to obtain the sensor data from an external file.\n\n    Args:\n        exact_sol (function): The exact solution function.\n        num_points (int): The number of points to sample.\n        file_name (str): The name of the file containing the sensor data.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n    Note:\n        This method reads the sensor data from a file and samples `num_points` from the data.\n        The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n    \"\"\"\n    # use pandas to read the file\n    df = pd.read_csv(file_name)\n\n    x = df.iloc[:, 0].values\n    y = df.iloc[:, 1].values\n    exact_sol = df.iloc[:, 2].values\n\n    # now sample num_points from the data\n    indices = np.random.randint(0, x.shape[0], num_points)\n\n    x = x[indices]\n    y = y[indices]\n    exact_sol = exact_sol[indices]\n\n    # stack them together\n    points = np.stack((x, y), axis=1)\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Fespace2D.set_finite_elements","title":"<code>set_finite_elements()</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    :return: None\n    \"\"\"\n    progress_bar = tqdm(\n        total=self.n_cells,\n        desc=\"Fe2D_cell Setup\",\n        unit=\"cells_assembled\",\n        bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n        colour=\"blue\",\n        ncols=100,\n    )\n\n    dof = 0\n    for i in range(self.n_cells):\n        self.fe_cell.append(\n            FE2D_Cell(\n                self.cells[i],\n                self.cell_type,\n                self.fe_order,\n                self.fe_type,\n                self.quad_order,\n                self.quad_type,\n                self.fe_transformation_type,\n                self.forcing_function,\n            )\n        )\n\n        # obtain the shape of the basis function (n_test, N_quad)\n        dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n        progress_bar.update(1)\n    # print the Shape details of all the matrices from cell 0 using print_table function\n    title = [\n        \"Shape function Matrix Shape\",\n        \"Shape function Gradient Matrix Shape\",\n        \"Jacobian Matrix Shape\",\n        \"Quadrature Points Shape\",\n        \"Quadrature Weights Shape\",\n        \"Quadrature Actual Coordinates Shape\",\n        \"Forcing Function Shape\",\n    ]\n    values = [\n        self.fe_cell[0].basis_at_quad.shape,\n        self.fe_cell[0].basis_gradx_at_quad.shape,\n        self.fe_cell[0].jacobian.shape,\n        self.fe_cell[0].quad_xi.shape,\n        self.fe_cell[0].quad_weight.shape,\n        self.fe_cell[0].quad_actual_coordinates.shape,\n        self.fe_cell[0].forcing_at_quad.shape,\n    ]\n    print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n    # update the total number of dofs\n    self.total_dofs = dof\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry","title":"<code>Geometry</code>","text":"<p>Abstract base class for geometry and mesh operations.</p> <p>This class defines the interface that all geometry implementations must follow, providing the basic structure for mesh handling operations in both 2D and 3D contexts.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> <code>mesh_generation_method</code> <p>Method for mesh generation ('internal'/'external')</p> Example <p>class Geometry2D(Geometry): ...     def init(self, mesh_type='quadrilateral', ...                  method='internal'): ...         super().init(mesh_type, method) ... ...     def read_mesh(self, mesh_file, boundary_level, ...                   sampling_method, refine_level): ...         # Implementation ...         pass ... ...     def generate_vtk_for_test(self): ...         # Implementation ...         pass ... ...     def get_test_points(self): ...         # Implementation ...         return points</p> Note <p>This is an abstract base class. Concrete implementations must override: - read_mesh() - generate_vtk_for_test() - get_test_points()</p> <p>Each implementation should provide appropriate mesh handling for its specific dimensional and element type requirements.</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>class Geometry:\n    \"\"\"Abstract base class for geometry and mesh operations.\n\n    This class defines the interface that all geometry implementations must\n    follow, providing the basic structure for mesh handling operations in\n    both 2D and 3D contexts.\n\n    Attributes:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Example:\n        &gt;&gt;&gt; class Geometry2D(Geometry):\n        ...     def __init__(self, mesh_type='quadrilateral',\n        ...                  method='internal'):\n        ...         super().__init__(mesh_type, method)\n        ...\n        ...     def read_mesh(self, mesh_file, boundary_level,\n        ...                   sampling_method, refine_level):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def generate_vtk_for_test(self):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def get_test_points(self):\n        ...         # Implementation\n        ...         return points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - read_mesh()\n        - generate_vtk_for_test()\n        - get_test_points()\n\n        Each implementation should provide appropriate mesh handling for its\n        specific dimensional and element type requirements.\n    \"\"\"\n\n    def __init__(self, mesh_type: str, mesh_generation_method: str):\n        \"\"\"\n        Constructor for the Geometry class.\n\n        Args:\n            mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n            mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n\n    @abstractmethod\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n        Args:\n            mesh_file (str): Path to the mesh file\n            boundary_point_refinement_level (int): Level of refinement for boundary points\n            bd_sampling_method (str): Sampling method for boundary points\n            refinement_level (int): Level of mesh refinement\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n        None\n\n        Returns:\n        None\n        \"\"\"\n\n    @abstractmethod\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            points (np.ndarray): Test points extracted from the mesh\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.__init__","title":"<code>__init__(mesh_type, mesh_generation_method)</code>","text":"<p>Constructor for the Geometry class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method for mesh generation ('internal'/'external')</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>def __init__(self, mesh_type: str, mesh_generation_method: str):\n    \"\"\"\n    Constructor for the Geometry class.\n\n    Args:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>  <code>abstractmethod</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Args: None</p> <p>Returns: None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n    None\n\n    Returns:\n    None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.get_test_points","title":"<code>get_test_points()</code>  <code>abstractmethod</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Test points extracted from the mesh</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        points (np.ndarray): Test points extracted from the mesh\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of refinement for boundary points</p> required <code>bd_sampling_method</code> <code>str</code> <p>Sampling method for boundary points</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n    Args:\n        mesh_file (str): Path to the mesh file\n        boundary_point_refinement_level (int): Level of refinement for boundary points\n        bd_sampling_method (str): Sampling method for boundary points\n        refinement_level (int): Level of mesh refinement\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D","title":"<code>Geometry_2D</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>Implements 2D geometry and mesh handling capabilities.</p> <p>This class provides comprehensive functionality for managing 2D meshes, including both internal generation and external mesh reading. It supports various mesh operations, boundary handling, and visualization capabilities.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements ('quadrilateral')</p> <code>mesh_generation_method</code> <p>Method of mesh generation ('internal'/'external')</p> <code>n_test_points_x</code> <p>Number of test points in x-direction</p> <code>n_test_points_y</code> <p>Number of test points in y-direction</p> <code>output_folder</code> <p>Path for output files</p> <code>is_optimized</code> <p>Flag for mesh optimization</p> <code>n_cells_x</code> <p>Number of cells in x-direction (internal mesh)</p> <code>n_cells_y</code> <p>Number of cells in y-direction (internal mesh)</p> <code>x_limits</code> <p>Domain limits in x-direction</p> <code>y_limits</code> <p>Domain limits in y-direction</p> <code>mesh_file_name</code> <p>Name of external mesh file</p> <code>mesh</code> <p>MeshIO mesh object</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <code>cell_points</code> <p>Array of cell vertices</p> <code>test_points</code> <p>Array of test points</p> Example <p>geometry = Geometry_2D( ...     mesh_type='quadrilateral', ...     mesh_generation_method='internal', ...     n_test_points_x=10, ...     n_test_points_y=10, ...     output_folder='./output' ... ) cells, bounds = geometry.generate_quad_mesh_internal( ...     x_limits=(0,1), ...     y_limits=(0,1), ...     n_cells_x=5, ...     n_cells_y=5, ...     num_boundary_points=40 ... )</p> Note <ul> <li>Only supports quadrilateral elements</li> <li>Internal mesh generation is limited to rectangular domains</li> <li>External mesh reading requires Gmsh format</li> <li>Boundary points can be sampled uniformly or using LHS</li> </ul> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>class Geometry_2D(Geometry):\n    \"\"\"Implements 2D geometry and mesh handling capabilities.\n\n    This class provides comprehensive functionality for managing 2D meshes,\n    including both internal generation and external mesh reading. It supports\n    various mesh operations, boundary handling, and visualization capabilities.\n\n    Attributes:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n        n_cells_x: Number of cells in x-direction (internal mesh)\n        n_cells_y: Number of cells in y-direction (internal mesh)\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        mesh_file_name: Name of external mesh file\n        mesh: MeshIO mesh object\n        bd_dict: Dictionary of boundary points\n        cell_points: Array of cell vertices\n        test_points: Array of test points\n\n    Example:\n        &gt;&gt;&gt; geometry = Geometry_2D(\n        ...     mesh_type='quadrilateral',\n        ...     mesh_generation_method='internal',\n        ...     n_test_points_x=10,\n        ...     n_test_points_y=10,\n        ...     output_folder='./output'\n        ... )\n        &gt;&gt;&gt; cells, bounds = geometry.generate_quad_mesh_internal(\n        ...     x_limits=(0,1),\n        ...     y_limits=(0,1),\n        ...     n_cells_x=5,\n        ...     n_cells_y=5,\n        ...     num_boundary_points=40\n        ... )\n\n    Note:\n        - Only supports quadrilateral elements\n        - Internal mesh generation is limited to rectangular domains\n        - External mesh reading requires Gmsh format\n        - Boundary points can be sampled uniformly or using LHS\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh_type: str,\n        mesh_generation_method: str,\n        n_test_points_x: int,\n        n_test_points_y: int,\n        output_folder: str,\n        is_optimized: bool = False,\n    ):\n        \"\"\"\n        Constructor for Geometry_2D class.\n\n        Args:\n            mesh_type: Type of mesh elements ('quadrilateral')\n            mesh_generation_method: Method of mesh generation ('internal'/'external')\n            n_test_points_x: Number of test points in x-direction\n            n_test_points_y: Number of test points in y-direction\n            output_folder: Path for output files\n            is_optimized: Flag for mesh optimization\n\n        Raises:\n            ValueError: If mesh type or generation method is invalid\n\n        Returns:\n            None\n        \"\"\"\n        # Call the super class constructor\n        super().__init__(mesh_type, mesh_generation_method)\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n        self.n_test_points_x = n_test_points_x\n        self.n_test_points_y = n_test_points_y\n        self.output_folder = output_folder\n        self.is_optimized = is_optimized\n\n        if self.mesh_generation_method not in [\"internal\", \"external\"]:\n            print(\n                f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                \"Mesh generation method should be either internal or external.\"\n            )\n\n        if self.mesh_type not in [\"quadrilateral\"]:\n            print(\n                f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n        # To be filled - only when mesh is internal\n        self.n_cells_x = None\n        self.n_cells_y = None\n        self.x_limits = None\n        self.y_limits = None\n\n        # to be filled by external\n        self.mesh_file_name = None\n        self.mesh = None\n        self.bd_dict = None\n        self.cell_points = None\n        self.test_points = None\n\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Reads mesh from a Gmsh .msh file and extracts cell information.\n\n        Args:\n            mesh_file: Path to the mesh file\n            boundary_point_refinement_level: Level of boundary point refinement\n            bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n            refinement_level: Level of mesh refinement\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n\n        Raises:\n            ValueError: If mesh file format is invalid\n        \"\"\"\n\n        self.mesh_file_name = mesh_file\n\n        # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n        file_extension = Path(mesh_file).suffix\n\n        if file_extension != \".mesh\":\n            raise ValueError(\"Mesh file should be in .mesh format.\")\n\n        # Read mesh using meshio\n        self.mesh = meshio.read(mesh_file)\n\n        if self.mesh_type == \"quadrilateral\":\n            # Extract cell information\n            cells = self.mesh.cells_dict[\"quad\"]\n\n        num_cells = cells.shape[0]\n        print(f\"[INFO] : Number of cells = {num_cells}\")\n        cell_points = self.mesh.points[cells][\n            :, :, 0:2\n        ]  # remove the z coordinate, which is 0 for all points\n\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(num_cells):\n            cell = cell_points[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cell_points[i] = cell[np.argsort(angles)]\n\n        # Extract number of points within each cell\n        print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n        # Collect the Boundary point id's within the domain\n        boundary_edges = self.mesh.cells_dict[\"line\"]\n\n        # Using the point id, collect the coordinates of the boundary points\n        boundary_coordinates = self.mesh.points[boundary_edges]\n\n        # Number of Existing Boundary points\n        print(\n            f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n        )\n\n        # now Get the physical tag of the boundary edges\n        boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n        # Generate a Dictionary of boundary tags and boundary coordinates\n        # Keys will be the boundary tags and values will be the list of coordinates\n        boundary_dict = {}\n\n        # refine the boundary points based on the number of boundary points needed\n        for i in range(boundary_coordinates.shape[0]):\n            p1 = boundary_coordinates[i, 0, :]\n            p2 = boundary_coordinates[i, 1, :]\n\n            if bd_sampling_method == \"uniform\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = np.linspace(\n                    p1, p2, pow(2, boundary_point_refinement_level) + 1\n                )\n            elif bd_sampling_method == \"lhs\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n                new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n                new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n            else:\n                print(\n                    f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n            # get the boundary tag\n            tag = boundary_tags[i]\n\n            if tag not in boundary_dict:\n                boundary_dict[tag] = new_points\n            else:\n                current_val = new_points\n                prev_val = boundary_dict[tag]\n                final = np.vstack([prev_val, current_val])\n                boundary_dict[tag] = final\n\n        # get unique\n        for tag in boundary_dict.keys():\n            val = boundary_dict[tag]\n            val = np.unique(val, axis=0)\n            boundary_dict[tag] = val\n\n        self.bd_dict = boundary_dict\n        # print the new boundary points  on each boundary tag (key) in a tabular format\n\n        total_bound_points = 0\n        print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n        print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n        for k, v in self.bd_dict.items():\n            print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n            total_bound_points += v.shape[0]\n\n        print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n        # Assign to class values\n        self.cell_points = cell_points\n\n        # generate testvtk\n        self.generate_vtk_for_test()\n\n        return cell_points, self.bd_dict\n\n    def generate_quad_mesh_internal(\n        self,\n        x_limits: tuple,\n        y_limits: tuple,\n        n_cells_x: int,\n        n_cells_y: int,\n        num_boundary_points: int,\n    ):\n        \"\"\"\n        Generate and save a quadrilateral mesh with physical curves.\n\n        Args:\n            x_limits: Domain limits in x-direction\n            y_limits: Domain limits in y-direction\n            n_cells_x: Number of cells in x-direction\n            n_cells_y: Number of cells in y-direction\n            num_boundary_points: Number of boundary points\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n        \"\"\"\n\n        self.n_cells_x = n_cells_x\n        self.n_cells_y = n_cells_y\n        self.x_limits = x_limits\n        self.y_limits = y_limits\n\n        # generate linspace of points in x and y direction\n        x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n        y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n        # Generate quad cells from the points\n        # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n        cells = []\n\n        for i in range(n_cells_x):\n            for j in range(n_cells_y):\n                # get the four points of the cell\n                p1 = [x[i], y[j]]\n                p2 = [x[i + 1], y[j]]\n                p3 = [x[i + 1], y[j + 1]]\n                p4 = [x[i], y[j + 1]]\n\n                # append the points to the cells\n                cells.append([p1, p2, p3, p4])\n\n        # convert to numpy array\n        cells = np.array(cells, dtype=np.float64)\n\n        # use arctan2 to sort the points in anticlockwise direction\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(cells.shape[0]):\n            cell = cells[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cells[i] = cell[np.argsort(angles)]\n\n        # generate a meshio mesh object using the cells\n        self.mesh = meshio.Mesh(\n            points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n        )\n\n        # lets generate the boundary points, this function will return a dictionary of boundary points\n        # the keys will be the boundary tags and values will be the list of boundary points\n        bd_points = {}\n\n        num_bound_per_side = int(num_boundary_points / 4)\n\n        def _temp_bd_func(start, end, num_pts):\n            \"\"\"\n            This function returns the boundary points between the start and end points\n            using lhs sampling.\n\n            Args:\n                start: Start point of the boundary\n                end: End point of the boundary\n                num_pts: Number of boundary points to be generated\n\n            Returns:\n                bd_pts: Array of boundary points\n            \"\"\"\n            # generate the boundary points using lhs as a np.float64 array\n            bd_pts = lhs(1, num_pts).astype(np.float64)\n            # scale the points\n            bd_pts = bd_pts * (end - start) + start\n\n            return bd_pts.reshape(-1)\n\n        # bottom boundary\n        y_bottom = (\n            np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n        ).reshape(-1)\n        x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n        # right boundary\n        x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n            -1\n        )\n        y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1001] = np.vstack([x_right, y_right]).T\n\n        # top boundary\n        y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n            -1\n        )\n        x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1002] = np.vstack([x_top, y_top]).T\n\n        # left boundary\n        x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n            -1\n        )\n        y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1003] = np.vstack([x_left, y_left]).T\n\n        self.cell_points = cells\n        self.bd_dict = bd_points\n\n        # generate vtk\n        if not self.is_optimized:\n            self.generate_vtk_for_test()\n\n        return self.cell_points, self.bd_dict\n\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # initialise the mesh\n            gmsh.initialize()\n\n            # Now, lets generate the mesh with the points.\n            x_range = self.x_limits[1] - self.x_limits[0]\n            y_range = self.y_limits[1] - self.y_limits[0]\n\n            mesh_size_x = x_range / self.n_test_points_x\n            mesh_size_y = y_range / self.n_test_points_y\n\n            # generate a gmsh with the given parameters\n            Xmin = self.x_limits[0]\n            Xmax = self.x_limits[1]\n            Ymin = self.y_limits[0]\n            Ymax = self.y_limits[1]\n\n            point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n            point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n            point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n            point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n            line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n            line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n            line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n            line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n            face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n            gmsh.model.geo.add_plane_surface([face1])\n\n            # Create the relevant Gmsh data structures\n            # from Gmsh model.\n            gmsh.model.geo.synchronize()\n\n            # Generate mesh:\n            gmsh.model.mesh.generate()\n\n            mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n            gmsh.write(str(mesh_file_name))\n            print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n            # close the gmsh\n            gmsh.finalize()\n\n            # read the mesh using meshio\n            mesh = meshio.gmsh.read(str(mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for internal mesh file generated at \",\n                str(mesh_file_name),\n            )\n\n        elif self.mesh_generation_method == \"external\":\n\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n            # Use the internal mesh to generate the vtk file\n            mesh = meshio.read(str(self.mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for external mesh file generated at \",\n                str(vtk_file_name),\n            )\n\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            test_points (np.ndarray): Array of test points\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n            # code over written to plot from np.linspace instead of vtk file\n            # generate linspace of points in x and y direction based on x and y limits\n            x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n            y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n            # generate meshgrid\n            x_grid, y_grid = np.meshgrid(x, y)\n            # stack the points\n            self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n            return self.test_points\n\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        mesh = meshio.read(str(vtk_file_name))\n        points = mesh.points\n        return points[:, 0:2]  # return only first two columns\n\n    def write_vtk(\n        self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n    ):\n        \"\"\"\n        Writes the data to a VTK file.\n\n        Args:\n            solution: The solution data to be written\n            output_path: The output path for the VTK file\n            filename: The name of the output file\n            data_names: List of data names\n\n        Returns:\n            None\n        \"\"\"\n        # read the existing vtk into file\n        if self.mesh_generation_method == \"internal\":\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        data = []\n        with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n            for line in File:\n                data.append(line)\n\n        # get the output file name\n        output_file_name = Path(output_path) / filename\n\n        if solution.shape[1] != len(data_names):\n            print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n            print(\n                \"Num Columns in solution = \",\n                solution.shape[1],\n                \" Num of data names = \",\n                len(data_names),\n            )\n            raise ValueError(\"Number of data names and solution columns are not equal\")\n\n        # write the data to the output file\n        with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n            for line in data:\n                FN.write(line)\n                if \"POINT_DATA\" in line.strip():\n                    break\n\n            for i in range(solution.shape[1]):\n                FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n                FN.write(\"LOOKUP_TABLE default\\n\")\n                np.savetxt(FN, solution[:, i])\n                FN.write(\"\\n\")\n\n        # save the vtk file as image\n        # self.save_vtk_as_image(str(output_file_name), data_names)\n\n    def plot_adaptive_mesh(\n        self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n    ):\n        \"\"\"\n        Plots the residuals in each cell of the mesh.\n\n        Args:\n            cells_list: List of cell vertices\n            area_averaged_cell_loss_list: List of area averaged cell loss\n            epoch: The epoch number\n            filename: The output filename\n\n        Returns:\n            None\n        \"\"\"\n\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # normalise colors\n        norm = mcolors.Normalize(\n            vmin=np.min(area_averaged_cell_loss_list),\n            vmax=np.max(area_averaged_cell_loss_list),\n        )\n\n        # Create a colormap\n        colormap = plt.cm.jet\n\n        for index, cell in enumerate(cells_list):\n            x = cell[:, 0]\n            y = cell[:, 1]\n\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n            color = colormap(norm(curr_cell_loss))\n\n            plt.fill(x, y, color=color, alpha=0.9)\n\n            plt.plot(x, y, \"k\")\n\n            # # compute x_min, x_max, y_min, y_max\n            # x_min = np.min(x)\n            # x_max = np.max(x)\n            # y_min = np.min(y)\n            # y_max = np.max(y)\n\n            # # compute centroid of the cells\n            # centroid = np.array([np.mean(x), np.mean(y)])\n\n            # plot the loss text within the cell\n            # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n        sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n        sm.set_array([])\n        plt.colorbar(sm)\n\n        # output filename\n        output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n        plt.title(f\"Cell Residual\")\n        plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.__init__","title":"<code>__init__(mesh_type, mesh_generation_method, n_test_points_x, n_test_points_y, output_folder, is_optimized=False)</code>","text":"<p>Constructor for Geometry_2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements ('quadrilateral')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method of mesh generation ('internal'/'external')</p> required <code>n_test_points_x</code> <code>int</code> <p>Number of test points in x-direction</p> required <code>n_test_points_y</code> <code>int</code> <p>Number of test points in y-direction</p> required <code>output_folder</code> <code>str</code> <p>Path for output files</p> required <code>is_optimized</code> <code>bool</code> <p>Flag for mesh optimization</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh type or generation method is invalid</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def __init__(\n    self,\n    mesh_type: str,\n    mesh_generation_method: str,\n    n_test_points_x: int,\n    n_test_points_y: int,\n    output_folder: str,\n    is_optimized: bool = False,\n):\n    \"\"\"\n    Constructor for Geometry_2D class.\n\n    Args:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n\n    Raises:\n        ValueError: If mesh type or generation method is invalid\n\n    Returns:\n        None\n    \"\"\"\n    # Call the super class constructor\n    super().__init__(mesh_type, mesh_generation_method)\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n    self.n_test_points_x = n_test_points_x\n    self.n_test_points_y = n_test_points_y\n    self.output_folder = output_folder\n    self.is_optimized = is_optimized\n\n    if self.mesh_generation_method not in [\"internal\", \"external\"]:\n        print(\n            f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\n            \"Mesh generation method should be either internal or external.\"\n        )\n\n    if self.mesh_type not in [\"quadrilateral\"]:\n        print(\n            f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n    # To be filled - only when mesh is internal\n    self.n_cells_x = None\n    self.n_cells_y = None\n    self.x_limits = None\n    self.y_limits = None\n\n    # to be filled by external\n    self.mesh_file_name = None\n    self.mesh = None\n    self.bd_dict = None\n    self.cell_points = None\n    self.test_points = None\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.generate_quad_mesh_internal","title":"<code>generate_quad_mesh_internal(x_limits, y_limits, n_cells_x, n_cells_y, num_boundary_points)</code>","text":"<p>Generate and save a quadrilateral mesh with physical curves.</p> <p>Parameters:</p> Name Type Description Default <code>x_limits</code> <code>tuple</code> <p>Domain limits in x-direction</p> required <code>y_limits</code> <code>tuple</code> <p>Domain limits in y-direction</p> required <code>n_cells_x</code> <code>int</code> <p>Number of cells in x-direction</p> required <code>n_cells_y</code> <code>int</code> <p>Number of cells in y-direction</p> required <code>num_boundary_points</code> <code>int</code> <p>Number of boundary points</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_quad_mesh_internal(\n    self,\n    x_limits: tuple,\n    y_limits: tuple,\n    n_cells_x: int,\n    n_cells_y: int,\n    num_boundary_points: int,\n):\n    \"\"\"\n    Generate and save a quadrilateral mesh with physical curves.\n\n    Args:\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        n_cells_x: Number of cells in x-direction\n        n_cells_y: Number of cells in y-direction\n        num_boundary_points: Number of boundary points\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n    \"\"\"\n\n    self.n_cells_x = n_cells_x\n    self.n_cells_y = n_cells_y\n    self.x_limits = x_limits\n    self.y_limits = y_limits\n\n    # generate linspace of points in x and y direction\n    x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n    y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n    # Generate quad cells from the points\n    # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n    cells = []\n\n    for i in range(n_cells_x):\n        for j in range(n_cells_y):\n            # get the four points of the cell\n            p1 = [x[i], y[j]]\n            p2 = [x[i + 1], y[j]]\n            p3 = [x[i + 1], y[j + 1]]\n            p4 = [x[i], y[j + 1]]\n\n            # append the points to the cells\n            cells.append([p1, p2, p3, p4])\n\n    # convert to numpy array\n    cells = np.array(cells, dtype=np.float64)\n\n    # use arctan2 to sort the points in anticlockwise direction\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(cells.shape[0]):\n        cell = cells[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cells[i] = cell[np.argsort(angles)]\n\n    # generate a meshio mesh object using the cells\n    self.mesh = meshio.Mesh(\n        points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n    )\n\n    # lets generate the boundary points, this function will return a dictionary of boundary points\n    # the keys will be the boundary tags and values will be the list of boundary points\n    bd_points = {}\n\n    num_bound_per_side = int(num_boundary_points / 4)\n\n    def _temp_bd_func(start, end, num_pts):\n        \"\"\"\n        This function returns the boundary points between the start and end points\n        using lhs sampling.\n\n        Args:\n            start: Start point of the boundary\n            end: End point of the boundary\n            num_pts: Number of boundary points to be generated\n\n        Returns:\n            bd_pts: Array of boundary points\n        \"\"\"\n        # generate the boundary points using lhs as a np.float64 array\n        bd_pts = lhs(1, num_pts).astype(np.float64)\n        # scale the points\n        bd_pts = bd_pts * (end - start) + start\n\n        return bd_pts.reshape(-1)\n\n    # bottom boundary\n    y_bottom = (\n        np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n    ).reshape(-1)\n    x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n    # right boundary\n    x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n        -1\n    )\n    y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1001] = np.vstack([x_right, y_right]).T\n\n    # top boundary\n    y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n        -1\n    )\n    x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1002] = np.vstack([x_top, y_top]).T\n\n    # left boundary\n    x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n        -1\n    )\n    y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1003] = np.vstack([x_left, y_left]).T\n\n    self.cell_points = cells\n    self.bd_dict = bd_points\n\n    # generate vtk\n    if not self.is_optimized:\n        self.generate_vtk_for_test()\n\n    return self.cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # initialise the mesh\n        gmsh.initialize()\n\n        # Now, lets generate the mesh with the points.\n        x_range = self.x_limits[1] - self.x_limits[0]\n        y_range = self.y_limits[1] - self.y_limits[0]\n\n        mesh_size_x = x_range / self.n_test_points_x\n        mesh_size_y = y_range / self.n_test_points_y\n\n        # generate a gmsh with the given parameters\n        Xmin = self.x_limits[0]\n        Xmax = self.x_limits[1]\n        Ymin = self.y_limits[0]\n        Ymax = self.y_limits[1]\n\n        point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n        point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n        point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n        point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n        line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n        line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n        line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n        line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n        face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n        gmsh.model.geo.add_plane_surface([face1])\n\n        # Create the relevant Gmsh data structures\n        # from Gmsh model.\n        gmsh.model.geo.synchronize()\n\n        # Generate mesh:\n        gmsh.model.mesh.generate()\n\n        mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n        gmsh.write(str(mesh_file_name))\n        print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n        # close the gmsh\n        gmsh.finalize()\n\n        # read the mesh using meshio\n        mesh = meshio.gmsh.read(str(mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for internal mesh file generated at \",\n            str(mesh_file_name),\n        )\n\n    elif self.mesh_generation_method == \"external\":\n\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        # Use the internal mesh to generate the vtk file\n        mesh = meshio.read(str(self.mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for external mesh file generated at \",\n            str(vtk_file_name),\n        )\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.get_test_points","title":"<code>get_test_points()</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>test_points</code> <code>ndarray</code> <p>Array of test points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        test_points (np.ndarray): Array of test points\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n        # code over written to plot from np.linspace instead of vtk file\n        # generate linspace of points in x and y direction based on x and y limits\n        x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n        y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n        # generate meshgrid\n        x_grid, y_grid = np.meshgrid(x, y)\n        # stack the points\n        self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n        return self.test_points\n\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    mesh = meshio.read(str(vtk_file_name))\n    points = mesh.points\n    return points[:, 0:2]  # return only first two columns\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.plot_adaptive_mesh","title":"<code>plot_adaptive_mesh(cells_list, area_averaged_cell_loss_list, epoch, filename='cell_residual')</code>","text":"<p>Plots the residuals in each cell of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>cells_list</code> <p>List of cell vertices</p> required <code>area_averaged_cell_loss_list</code> <p>List of area averaged cell loss</p> required <code>epoch</code> <p>The epoch number</p> required <code>filename</code> <p>The output filename</p> <code>'cell_residual'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def plot_adaptive_mesh(\n    self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n):\n    \"\"\"\n    Plots the residuals in each cell of the mesh.\n\n    Args:\n        cells_list: List of cell vertices\n        area_averaged_cell_loss_list: List of area averaged cell loss\n        epoch: The epoch number\n        filename: The output filename\n\n    Returns:\n        None\n    \"\"\"\n\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # normalise colors\n    norm = mcolors.Normalize(\n        vmin=np.min(area_averaged_cell_loss_list),\n        vmax=np.max(area_averaged_cell_loss_list),\n    )\n\n    # Create a colormap\n    colormap = plt.cm.jet\n\n    for index, cell in enumerate(cells_list):\n        x = cell[:, 0]\n        y = cell[:, 1]\n\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n        color = colormap(norm(curr_cell_loss))\n\n        plt.fill(x, y, color=color, alpha=0.9)\n\n        plt.plot(x, y, \"k\")\n\n        # # compute x_min, x_max, y_min, y_max\n        # x_min = np.min(x)\n        # x_max = np.max(x)\n        # y_min = np.min(y)\n        # y_max = np.max(y)\n\n        # # compute centroid of the cells\n        # centroid = np.array([np.mean(x), np.mean(y)])\n\n        # plot the loss text within the cell\n        # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n    sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n    sm.set_array([])\n    plt.colorbar(sm)\n\n    # output filename\n    output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n    plt.title(f\"Cell Residual\")\n    plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>","text":"<p>Reads mesh from a Gmsh .msh file and extracts cell information.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of boundary point refinement</p> required <code>bd_sampling_method</code> <code>str</code> <p>Method for boundary point sampling ('uniform'/'lhs')</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh file format is invalid</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Reads mesh from a Gmsh .msh file and extracts cell information.\n\n    Args:\n        mesh_file: Path to the mesh file\n        boundary_point_refinement_level: Level of boundary point refinement\n        bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n        refinement_level: Level of mesh refinement\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n\n    Raises:\n        ValueError: If mesh file format is invalid\n    \"\"\"\n\n    self.mesh_file_name = mesh_file\n\n    # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n    file_extension = Path(mesh_file).suffix\n\n    if file_extension != \".mesh\":\n        raise ValueError(\"Mesh file should be in .mesh format.\")\n\n    # Read mesh using meshio\n    self.mesh = meshio.read(mesh_file)\n\n    if self.mesh_type == \"quadrilateral\":\n        # Extract cell information\n        cells = self.mesh.cells_dict[\"quad\"]\n\n    num_cells = cells.shape[0]\n    print(f\"[INFO] : Number of cells = {num_cells}\")\n    cell_points = self.mesh.points[cells][\n        :, :, 0:2\n    ]  # remove the z coordinate, which is 0 for all points\n\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(num_cells):\n        cell = cell_points[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cell_points[i] = cell[np.argsort(angles)]\n\n    # Extract number of points within each cell\n    print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n    # Collect the Boundary point id's within the domain\n    boundary_edges = self.mesh.cells_dict[\"line\"]\n\n    # Using the point id, collect the coordinates of the boundary points\n    boundary_coordinates = self.mesh.points[boundary_edges]\n\n    # Number of Existing Boundary points\n    print(\n        f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n    )\n\n    # now Get the physical tag of the boundary edges\n    boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n    # Generate a Dictionary of boundary tags and boundary coordinates\n    # Keys will be the boundary tags and values will be the list of coordinates\n    boundary_dict = {}\n\n    # refine the boundary points based on the number of boundary points needed\n    for i in range(boundary_coordinates.shape[0]):\n        p1 = boundary_coordinates[i, 0, :]\n        p2 = boundary_coordinates[i, 1, :]\n\n        if bd_sampling_method == \"uniform\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = np.linspace(\n                p1, p2, pow(2, boundary_point_refinement_level) + 1\n            )\n        elif bd_sampling_method == \"lhs\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n            new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n            new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n        else:\n            print(\n                f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n        # get the boundary tag\n        tag = boundary_tags[i]\n\n        if tag not in boundary_dict:\n            boundary_dict[tag] = new_points\n        else:\n            current_val = new_points\n            prev_val = boundary_dict[tag]\n            final = np.vstack([prev_val, current_val])\n            boundary_dict[tag] = final\n\n    # get unique\n    for tag in boundary_dict.keys():\n        val = boundary_dict[tag]\n        val = np.unique(val, axis=0)\n        boundary_dict[tag] = val\n\n    self.bd_dict = boundary_dict\n    # print the new boundary points  on each boundary tag (key) in a tabular format\n\n    total_bound_points = 0\n    print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n    print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n    for k, v in self.bd_dict.items():\n        print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n        total_bound_points += v.shape[0]\n\n    print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n    # Assign to class values\n    self.cell_points = cell_points\n\n    # generate testvtk\n    self.generate_vtk_for_test()\n\n    return cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.Geometry_2D.write_vtk","title":"<code>write_vtk(solution, output_path, filename, data_names)</code>","text":"<p>Writes the data to a VTK file.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>ndarray</code> <p>The solution data to be written</p> required <code>output_path</code> <code>str</code> <p>The output path for the VTK file</p> required <code>filename</code> <code>str</code> <p>The name of the output file</p> required <code>data_names</code> <code>list</code> <p>List of data names</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def write_vtk(\n    self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n):\n    \"\"\"\n    Writes the data to a VTK file.\n\n    Args:\n        solution: The solution data to be written\n        output_path: The output path for the VTK file\n        filename: The name of the output file\n        data_names: List of data names\n\n    Returns:\n        None\n    \"\"\"\n    # read the existing vtk into file\n    if self.mesh_generation_method == \"internal\":\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    data = []\n    with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n        for line in File:\n            data.append(line)\n\n    # get the output file name\n    output_file_name = Path(output_path) / filename\n\n    if solution.shape[1] != len(data_names):\n        print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n        print(\n            \"Num Columns in solution = \",\n            solution.shape[1],\n            \" Num of data names = \",\n            len(data_names),\n        )\n        raise ValueError(\"Number of data names and solution columns are not equal\")\n\n    # write the data to the output file\n    with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n        for line in data:\n            FN.write(line)\n            if \"POINT_DATA\" in line.strip():\n                break\n\n        for i in range(solution.shape[1]):\n            FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n            FN.write(\"LOOKUP_TABLE default\\n\")\n            np.savetxt(FN, solution[:, i])\n            FN.write(\"\\n\")\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/data/datahandler2d/#scirex.core.sciml.fastvpinns.data.datahandler2d.print_table","title":"<code>print_table(title, columns, col_1_values, col_2_values)</code>","text":"<p>This function prints a table with two columns to the console.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>str: Title of the table</p> required <code>columns</code> <code>list</code> <p>list: List of column names</p> required <code>col_1_values</code> <code>list</code> <p>list: List of values for column 1</p> required <code>col_2_values</code> <code>list</code> <p>list: List of values for column</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\utils\\print_utils.py</code> <pre><code>def print_table(title: str, columns: list, col_1_values: list, col_2_values: list):\n    \"\"\"\n    This function prints a table with two columns to the console.\n\n    Args:\n        title: str: Title of the table\n        columns: list: List of column names\n        col_1_values: list: List of values for column 1\n        col_2_values: list: List of values for column\n\n    Returns:\n        None\n    \"\"\"\n\n    # Create a console object\n    console = Console()\n\n    # Create a table with a title\n    table = Table(show_header=True, header_style=\"bold magenta\", title=title)\n\n    # Add columns to the table\n    for column in columns:\n        table.add_column(column)\n\n    # Add rows to the table\n    for val_1, val_2 in zip(col_1_values, col_2_values):\n        # check if val_2 is a float\n        if isinstance(val_2, float):\n            # add the row to the table\n            table.add_row(val_1, f\"{val_2:.4f}\")\n        else:\n            table.add_row(val_1, str(val_2))\n\n    # Print the table to the console\n    console.print(table)\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/","title":"Model","text":"<p>Neural Network Model Implementation for Variational Physics-Informed Neural Networks.</p> <p>This module implements the neural network architecture and training loop for solving PDEs using variational physics-informed neural networks (VPINNs). It provides a flexible framework for handling various PDEs through custom loss functions.</p> The implementation supports <ul> <li>Flexible neural network architectures</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations</li> <li>Automatic differentiation for gradients</li> </ul> Key classes <ul> <li>DenseModel: Neural network model for VPINN implementation</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel","title":"<code>DenseModel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for solving PDEs using variational formulation.</p> <p>This class implements a custom neural network architecture for solving partial differential equations using the variational form. It supports flexible layer configurations and various loss components.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>input_tensors_list</code> <p>List containing: [0]: input_tensor - Main computation points [1]: dirichlet_input - Boundary points [2]: dirichlet_actual - Boundary values</p> <code>orig_factor_matrices</code> <p>List containing: [0]: Shape function values [1]: x-derivative of shape functions [2]: y-derivative of shape functions</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32 ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The training process balances PDE residuals and boundary conditions through a weighted loss function. The implementation uses efficient tensor operations for computing variational residuals.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>class DenseModel(tf.keras.Model):\n    \"\"\"Neural network model for solving PDEs using variational formulation.\n\n    This class implements a custom neural network architecture for solving\n    partial differential equations using the variational form. It supports\n    flexible layer configurations and various loss components.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list: List containing:\n            [0]: input_tensor - Main computation points\n            [1]: dirichlet_input - Boundary points\n            [2]: dirichlet_actual - Boundary values\n        orig_factor_matrices: List containing:\n            [0]: Shape function values\n            [1]: x-derivative of shape functions\n            [2]: y-derivative of shape functions\n        tensor_dtype: TensorFlow data type for computations\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The training process balances PDE residuals and boundary conditions\n        through a weighted loss function. The implementation uses efficient\n        tensor operations for computing variational residuals.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        orig_factor_matrices: list,\n        force_function_list: list,\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n    ):\n        \"\"\"\n        Initialize the DenseModel class.\n\n        Args:\n            layer_dims (list): List of neurons per layer including input/output.\n            learning_rate_dict (dict): Learning rate configuration containing:\n                - initial_learning_rate: Starting learning rate\n                - use_lr_scheduler: Whether to use learning rate decay\n                - decay_steps: Steps between learning rate updates\n                - decay_rate: Factor for learning rate decay\n            params_dict (dict): Model parameters including:\n                - n_cells: Number of cells in the domain\n            loss_function: Custom loss function for PDE residuals\n            input_tensors_list: List containing:\n                [0]: input_tensor - Main computation points\n                [1]: dirichlet_input - Boundary points\n                [2]: dirichlet_actual - Boundary values\n            orig_factor_matrices: List containing:\n                [0]: Shape function values\n                [1]: x-derivative of shape functions\n                [2]: y-derivative of shape functions\n            force_function_list: List containing:\n                - forcing_function: Forcing function values\n            tensor_dtype: TensorFlow data type for computations\n            use_attention (bool): Whether to use attention mechanism, defaults to False.\n            activation (str): Activation function for hidden layers, defaults to \"tanh\".\n            hessian (bool): Whether to compute Hessian matrix, defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        super(DenseModel, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        # staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                TensorflowDense.create_layer(\n                    units=self.layer_dims[dim],\n                    activation=self.activation,\n                    dtype=self.tensor_dtype,\n                    kernel_initializer=\"glorot_uniform\",\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[-1],\n                activation=None,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    # def build(self, input_shape):\n    #     super(DenseModel, self).build(input_shape)\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"\n        The call method for the model.\n\n        Args:\n            inputs: The input tensor for the model.\n\n        Returns:\n            tf.Tensor: The output tensor from the model.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"\n        Get the configuration of the model.\n\n        Returns:\n            dict: The configuration of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"\n        The train step method for the model.\n\n        Args:\n            beta (int): The weight for the boundary loss, defaults to 10.\n            bilinear_params_dict (dict): The bilinear parameters dictionary, defaults to None.\n\n        Returns:\n            dict: The loss values for the model.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.__init__","title":"<code>__init__(layer_dims, learning_rate_dict, params_dict, loss_function, input_tensors_list, orig_factor_matrices, force_function_list, tensor_dtype, use_attention=False, activation='tanh', hessian=False)</code>","text":"<p>Initialize the DenseModel class.</p> <p>Parameters:</p> Name Type Description Default <code>layer_dims</code> <code>list</code> <p>List of neurons per layer including input/output.</p> required <code>learning_rate_dict</code> <code>dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> required <code>params_dict</code> <code>dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> required <code>loss_function</code> <p>Custom loss function for PDE residuals</p> required <code>input_tensors_list</code> <code>list</code> <p>List containing: [0]: input_tensor - Main computation points [1]: dirichlet_input - Boundary points [2]: dirichlet_actual - Boundary values</p> required <code>orig_factor_matrices</code> <code>list</code> <p>List containing: [0]: Shape function values [1]: x-derivative of shape functions [2]: y-derivative of shape functions</p> required <code>force_function_list</code> <code>list</code> <p>List containing: - forcing_function: Forcing function values</p> required <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> required <code>use_attention</code> <code>bool</code> <p>Whether to use attention mechanism, defaults to False.</p> <code>False</code> <code>activation</code> <code>str</code> <p>Activation function for hidden layers, defaults to \"tanh\".</p> <code>'tanh'</code> <code>hessian</code> <code>bool</code> <p>Whether to compute Hessian matrix, defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>def __init__(\n    self,\n    layer_dims: list,\n    learning_rate_dict: dict,\n    params_dict: dict,\n    loss_function,\n    input_tensors_list: list,\n    orig_factor_matrices: list,\n    force_function_list: list,\n    tensor_dtype,\n    use_attention=False,\n    activation=\"tanh\",\n    hessian=False,\n):\n    \"\"\"\n    Initialize the DenseModel class.\n\n    Args:\n        layer_dims (list): List of neurons per layer including input/output.\n        learning_rate_dict (dict): Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict (dict): Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list: List containing:\n            [0]: input_tensor - Main computation points\n            [1]: dirichlet_input - Boundary points\n            [2]: dirichlet_actual - Boundary values\n        orig_factor_matrices: List containing:\n            [0]: Shape function values\n            [1]: x-derivative of shape functions\n            [2]: y-derivative of shape functions\n        force_function_list: List containing:\n            - forcing_function: Forcing function values\n        tensor_dtype: TensorFlow data type for computations\n        use_attention (bool): Whether to use attention mechanism, defaults to False.\n        activation (str): Activation function for hidden layers, defaults to \"tanh\".\n        hessian (bool): Whether to compute Hessian matrix, defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    super(DenseModel, self).__init__()\n    self.layer_dims = layer_dims\n    self.use_attention = use_attention\n    self.activation = activation\n    self.layer_list = []\n    self.loss_function = loss_function\n    self.hessian = hessian\n\n    self.tensor_dtype = tensor_dtype\n\n    # if dtype is not a valid tensorflow dtype, raise an error\n    if not isinstance(self.tensor_dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    self.orig_factor_matrices = orig_factor_matrices\n    self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n    self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[1]\n    )\n    self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[2]\n    )\n\n    self.force_function_list = force_function_list\n\n    self.input_tensors_list = input_tensors_list\n    self.input_tensor = copy.deepcopy(input_tensors_list[0])\n    self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n    self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n    self.params_dict = params_dict\n\n    self.pre_multiplier_val = self.shape_function_mat_list\n    self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n    self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n    self.force_matrix = self.force_function_list\n\n    print(f\"{'-'*74}\")\n    print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n    print(f\"{'-'*74}\")\n    print(\n        f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n    )\n    print(\n        f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n    )\n    print(f\"{'-'*74}\")\n\n    self.n_cells = params_dict[\"n_cells\"]\n\n    ## ----------------------------------------------------------------- ##\n    ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # parse the learning rate dictionary\n    self.learning_rate_dict = learning_rate_dict\n    initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n    use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n    decay_steps = learning_rate_dict[\"decay_steps\"]\n    decay_rate = learning_rate_dict[\"decay_rate\"]\n    # staircase = learning_rate_dict[\"staircase\"]\n\n    if use_lr_scheduler:\n        learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n            initial_learning_rate, decay_steps, decay_rate, staircase=True\n        )\n    else:\n        learning_rate_fn = initial_learning_rate\n\n    self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n    ## ----------------------------------------------------------------- ##\n    ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # Build dense layers based on the input list\n    for dim in range(len(self.layer_dims) - 2):\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[dim],\n                activation=self.activation,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n    # Add a output layer with no activation\n    self.layer_list.append(\n        TensorflowDense.create_layer(\n            units=self.layer_dims[-1],\n            activation=None,\n            dtype=self.tensor_dtype,\n            kernel_initializer=\"glorot_uniform\",\n            bias_initializer=\"zeros\",\n        )\n    )\n\n    # Add attention layer if required\n    if self.use_attention:\n        self.attention_layer = layers.Attention()\n\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    self.build(input_shape=(None, self.layer_dims[0]))\n\n    # print the summary of the model\n    self.summary()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.call","title":"<code>call(inputs)</code>","text":"<p>The call method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input tensor for the model.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: The output tensor from the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"\n    The call method for the model.\n\n    Args:\n        inputs: The input tensor for the model.\n\n    Returns:\n        tf.Tensor: The output tensor from the model.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.get_config","title":"<code>get_config()</code>","text":"<p>Get the configuration of the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The configuration of the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"\n    Get the configuration of the model.\n\n    Returns:\n        dict: The configuration of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model/#scirex.core.sciml.fastvpinns.model.model.DenseModel.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>The train step method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <code>int</code> <p>The weight for the boundary loss, defaults to 10.</p> <code>10</code> <code>bilinear_params_dict</code> <code>dict</code> <p>The bilinear parameters dictionary, defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loss values for the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"\n    The train step method for the model.\n\n    Args:\n        beta (int): The weight for the boundary loss, defaults to 10.\n        bilinear_params_dict (dict): The bilinear parameters dictionary, defaults to None.\n\n    Returns:\n        dict: The loss values for the model.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values = self(self.input_tensor)\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/","title":"Model hard","text":"<p>Neural Network Model Implementation for FastVPINNs with Hard Constraints.</p> <p>This module implements a custom neural network model designed specifically for FastVPINNs methodology, incorporating hard constraint enforcement. It extends TensorFlow's Keras Model class to provide efficient PDE residual computation and gradient-based training.</p> The implementation supports <ul> <li>Flexible neural network architecture definition</li> <li>Hard constraint enforcement through constraint functions</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations for PDE residuals</li> <li>Custom gradient computation and training loops</li> </ul> Key classes <ul> <li>DenseModel_Hard: Main neural network model with hard constraints</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard","title":"<code>DenseModel_Hard</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model with hard constraint enforcement for FastVPINNs.</p> <p>This class implements a custom neural network architecture specifically designed for solving PDEs using the FastVPINNs methodology. It supports hard constraint enforcement through custom constraint functions and efficient tensor operations for PDE residual computation.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay - staircase: Whether to use staircase decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>hessian</code> <p>Whether to compute second derivatives</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> <code>layer_list</code> <p>List of neural network layers</p> Example <p>model = DenseModel_Hard( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32 ... ) history = model.fit(x_train, epochs=1000)</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>class DenseModel_Hard(tf.keras.Model):\n    \"\"\"Neural network model with hard constraint enforcement for FastVPINNs.\n\n    This class implements a custom neural network architecture specifically\n    designed for solving PDEs using the FastVPINNs methodology. It supports\n    hard constraint enforcement through custom constraint functions and\n    efficient tensor operations for PDE residual computation.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n            - staircase: Whether to use staircase decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        tensor_dtype: TensorFlow data type for computations\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        hessian: Whether to compute second derivatives\n        optimizer: Adam optimizer with optional learning rate schedule\n        layer_list: List of neural network layers\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel_Hard(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims,\n        learning_rate_dict,\n        params_dict,\n        loss_function,\n        input_tensors_list,\n        orig_factor_matrices,\n        force_function_list,\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n        hard_constraint_function=None,\n    ):\n        super(DenseModel_Hard, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n        if hard_constraint_function is None:\n            self.hard_constraint_function = lambda x, y: y\n        else:\n            self.hard_constraint_function = hard_constraint_function\n\n        self.tensor_dtype = tensor_dtype\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        self.gradients = None\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                TensorflowDense.create_layer(\n                    units=self.layer_dims[dim + 1],\n                    activation=self.activation,\n                    dtype=self.tensor_dtype,\n                    kernel_initializer=\"glorot_uniform\",\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[-1],\n                activation=None,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    # def build(self, input_shape):\n    #     super(DenseModel, self).build(input_shape)\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"This method is used to define the forward pass of the model.\n\n        Args:\n            inputs: Input tensor to the model\n\n        Returns:\n            Output tensor from the model\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        x = self.hard_constraint_function(inputs, x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"This method is used to get the configuration of the model.\n\n        Args:\n            None\n\n        Returns:\n            Configuration dictionary of the model\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"This method is used to define the training step of the mode.\n\n        Args:\n            beta: The penalty parameter for the hard constraints\n            bilinear_params_dict: The bilinear parameters dictionary\n\n        Returns:\n            Dictionary containing the loss values\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # tf.print(\"Residual : \", residual)\n            # tf.print(\"Residual Shape : \", residual.shape)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # convert predicted_values_dirichlet to tf.float64\n            # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n            # tf.print(\"Boundary Loss : \", boundary_loss)\n            # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n            # tf.print(\"Total PDE Loss : \", total_pde_loss)\n            # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n            boundary_loss = 0.0\n            # Compute Total Loss\n            total_loss = total_pde_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard.call","title":"<code>call(inputs)</code>","text":"<p>This method is used to define the forward pass of the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>Input tensor to the model</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Output tensor from the model</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"This method is used to define the forward pass of the model.\n\n    Args:\n        inputs: Input tensor to the model\n\n    Returns:\n        Output tensor from the model\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    x = self.hard_constraint_function(inputs, x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard.get_config","title":"<code>get_config()</code>","text":"<p>This method is used to get the configuration of the model.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Configuration dictionary of the model</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"This method is used to get the configuration of the model.\n\n    Args:\n        None\n\n    Returns:\n        Configuration dictionary of the model\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_hard/#scirex.core.sciml.fastvpinns.model.model_hard.DenseModel_Hard.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>This method is used to define the training step of the mode.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <p>The penalty parameter for the hard constraints</p> <code>10</code> <code>bilinear_params_dict</code> <p>The bilinear parameters dictionary</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the loss values</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_hard.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"This method is used to define the training step of the mode.\n\n    Args:\n        beta: The penalty parameter for the hard constraints\n        bilinear_params_dict: The bilinear parameters dictionary\n\n    Returns:\n        Dictionary containing the loss values\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values = self(self.input_tensor)\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # tf.print(\"Residual : \", residual)\n        # tf.print(\"Residual Shape : \", residual.shape)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # convert predicted_values_dirichlet to tf.float64\n        # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n        # tf.print(\"Boundary Loss : \", boundary_loss)\n        # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n        # tf.print(\"Total PDE Loss : \", total_pde_loss)\n        # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n        boundary_loss = 0.0\n        # Compute Total Loss\n        total_loss = total_pde_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/","title":"Model inverse","text":"<p>Neural Network Model Implementation for PDE Parameter Inverse Problems.</p> <p>This module implements the neural network architecture and training loop for solving inverse problems in PDEs using variational physics-informed neural  networks (VPINNs). It focuses on identifying constant parameters while solving the underlying PDE simultaneously.</p> The implementation supports <ul> <li>Parameter identification</li> <li>Sensor data incorporation</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations</li> </ul> Key classes <ul> <li>DenseModel_Inverse: Neural network model for inverse problems</li> </ul> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse","title":"<code>DenseModel_Inverse</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for PDE parameter identification.</p> <p>This class implements a custom neural network architecture for solving inverse problems in PDEs. It combines parameter identification with PDE solution while incorporating sensor data and boundary conditions.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay - staircase: Whether to use staircase decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>sensor_list</code> <p>List containing: [0]: sensor_points - Coordinates of sensor locations [1]: sensor_values - Measured values at sensors</p> <code>inverse_params_dict</code> <p>Dictionary of parameters to be identified, converted to trainable variables</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel_Inverse( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32, ...     sensor_list=[sensor_points, sensor_values], ...     inverse_params_dict={'eps': 0.1} ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The training process balances PDE residuals, boundary conditions, sensor data matching, and parameter identification through a weighted loss function.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>class DenseModel_Inverse(tf.keras.Model):\n    \"\"\"Neural network model for PDE parameter identification.\n\n    This class implements a custom neural network architecture for solving\n    inverse problems in PDEs. It combines parameter identification with\n    PDE solution while incorporating sensor data and boundary conditions.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n            - staircase: Whether to use staircase decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        tensor_dtype: TensorFlow data type for computations\n        sensor_list: List containing:\n            [0]: sensor_points - Coordinates of sensor locations\n            [1]: sensor_values - Measured values at sensors\n        inverse_params_dict: Dictionary of parameters to be identified,\n            converted to trainable variables\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel_Inverse(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32,\n        ...     sensor_list=[sensor_points, sensor_values],\n        ...     inverse_params_dict={'eps': 0.1}\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The training process balances PDE residuals, boundary conditions,\n        sensor data matching, and parameter identification through a\n        weighted loss function.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        orig_factor_matrices: list,\n        force_function_list: list,\n        sensor_list: list,  # for inverse problem\n        inverse_params_dict: dict,  # for inverse problem\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n    ):\n        super(DenseModel_Inverse, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        self.sensor_list = sensor_list\n        # obtain sensor values\n        self.sensor_points = sensor_list[0]\n        self.sensor_values = sensor_list[1]\n\n        # inverse params dict\n        self.inverse_params_dict = inverse_params_dict\n\n        # Conver all the values within inverse_params_dict to trainable variables\n        for key, value in self.inverse_params_dict.items():\n            self.inverse_params_dict[key] = tf.Variable(\n                value, dtype=self.tensor_dtype, trainable=True\n            )\n            tf.print(f\"Key : {key} , Value : {self.inverse_params_dict[key]}\")\n\n        # add the sensor points to the trainable variables of the model\n        self.trainable_variables.extend(self.inverse_params_dict.values())\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                layers.Dense(\n                    self.layer_dims[dim + 1],\n                    activation=self.activation,\n                    kernel_initializer=\"glorot_uniform\",\n                    dtype=self.tensor_dtype,\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            layers.Dense(\n                self.layer_dims[-1],\n                activation=None,\n                kernel_initializer=\"glorot_uniform\",\n                dtype=self.tensor_dtype,\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    def call(self, inputs):\n        \"\"\"\n        Applies the model to the input data.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The output of the model after applying all the layers.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self):\n        \"\"\"\n        Returns the configuration of the model.\n\n        This method is used to serialize the model configuration. It returns a dictionary\n        containing all the necessary information to recreate the model.\n\n        Returns:\n            dict: The configuration dictionary of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n                \"sensor_list\": self.sensor_list,\n                \"inverse_params_dict\": self.inverse_params_dict,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"\n        Performs a single training step on the model.\n\n        Args:\n            beta: The weight for the boundary condition loss.\n            bilinear_params_dict: The bilinear parameters dictionary.\n\n        Returns:\n            dict: A dictionary containing the loss values.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n\n            # predict the sensor values\n            predicted_sensor_values = self(self.sensor_points)\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n                inverse_params_dict=self.inverse_params_dict,\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # tf.print(\"Residual : \", residual)\n            # tf.print(\"Residual Shape : \", residual.shape)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # convert predicted_values_dirichlet to tf.float64\n            # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Sensor loss\n            sensor_loss = tf.reduce_mean(\n                tf.square(predicted_sensor_values - self.sensor_values), axis=0\n            )\n\n            # tf.print(\"Boundary Loss : \", boundary_loss)\n            # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n            # tf.print(\"Total PDE Loss : \", total_pde_loss)\n            # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n            \"inverse_params\": self.inverse_params_dict,\n            \"sensor_loss\": sensor_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse.call","title":"<code>call(inputs)</code>","text":"<p>Applies the model to the input data.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input data.</p> required <p>Returns:</p> Type Description <p>The output of the model after applying all the layers.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>def call(self, inputs):\n    \"\"\"\n    Applies the model to the input data.\n\n    Args:\n        inputs: The input data.\n\n    Returns:\n        The output of the model after applying all the layers.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse.get_config","title":"<code>get_config()</code>","text":"<p>Returns the configuration of the model.</p> <p>This method is used to serialize the model configuration. It returns a dictionary containing all the necessary information to recreate the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The configuration dictionary of the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>def get_config(self):\n    \"\"\"\n    Returns the configuration of the model.\n\n    This method is used to serialize the model configuration. It returns a dictionary\n    containing all the necessary information to recreate the model.\n\n    Returns:\n        dict: The configuration dictionary of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n            \"sensor_list\": self.sensor_list,\n            \"inverse_params_dict\": self.inverse_params_dict,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse/#scirex.core.sciml.fastvpinns.model.model_inverse.DenseModel_Inverse.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>Performs a single training step on the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <p>The weight for the boundary condition loss.</p> <code>10</code> <code>bilinear_params_dict</code> <p>The bilinear parameters dictionary.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the loss values.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"\n    Performs a single training step on the model.\n\n    Args:\n        beta: The weight for the boundary condition loss.\n        bilinear_params_dict: The bilinear parameters dictionary.\n\n    Returns:\n        dict: A dictionary containing the loss values.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n\n        # predict the sensor values\n        predicted_sensor_values = self(self.sensor_points)\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values = self(self.input_tensor)\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n            inverse_params_dict=self.inverse_params_dict,\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # tf.print(\"Residual : \", residual)\n        # tf.print(\"Residual Shape : \", residual.shape)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # convert predicted_values_dirichlet to tf.float64\n        # predicted_values_dirichlet = tf.cast(predicted_values_dirichlet, tf.float64)\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Sensor loss\n        sensor_loss = tf.reduce_mean(\n            tf.square(predicted_sensor_values - self.sensor_values), axis=0\n        )\n\n        # tf.print(\"Boundary Loss : \", boundary_loss)\n        # tf.print(\"Boundary Loss Shape : \", boundary_loss.shape)\n        # tf.print(\"Total PDE Loss : \", total_pde_loss)\n        # tf.print(\"Total PDE Loss Shape : \", total_pde_loss.shape)\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n        \"inverse_params\": self.inverse_params_dict,\n        \"sensor_loss\": sensor_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/","title":"Model inverse domain","text":"<p>Neural Network Model Implementation for Domain-Based PDE Inverse Problems.</p> <p>This module implements the neural network architecture and training loop for solving inverse problems in PDEs where parameters are constant over the domain. The implementation follows the FastVPINNs methodology for efficient training of variational physics-informed neural networks.</p> The implementation supports <ul> <li>Domain-based parameter identification</li> <li>Sensor data incorporation</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Attention mechanisms (optional)</li> <li>Efficient tensor operations</li> </ul> Key classes <ul> <li>DenseModel_Inverse_Domain: Neural network model for inverse problems</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of variational residuals in inverse problems.</p> Authors <ul> <li>Thivin Anandh (https://thivinanandh.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain","title":"<code>DenseModel_Inverse_Domain</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for domain-based PDE inverse problems.</p> <p>This class implements a custom neural network architecture specifically designed for solving inverse problems in PDEs where parameters are constant over the domain. It incorporates sensor data and boundary conditions in the training process.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>sensor_list</code> <p>List containing: - sensor_points: Coordinates of sensor locations - sensor_values: Measured values at sensors</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel_Inverse_Domain( ...     layer_dims=[2, 64, 64, 2],  # Last layer has 2 outputs ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32, ...     sensor_list=[sensor_points, sensor_values] ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The model outputs include both the solution and the identified parameter. The training process balances PDE residuals, boundary conditions, and sensor data matching.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>class DenseModel_Inverse_Domain(tf.keras.Model):\n    \"\"\"Neural network model for domain-based PDE inverse problems.\n\n    This class implements a custom neural network architecture specifically\n    designed for solving inverse problems in PDEs where parameters are\n    constant over the domain. It incorporates sensor data and boundary\n    conditions in the training process.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        tensor_dtype: TensorFlow data type for computations\n        sensor_list: List containing:\n            - sensor_points: Coordinates of sensor locations\n            - sensor_values: Measured values at sensors\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel_Inverse_Domain(\n        ...     layer_dims=[2, 64, 64, 2],  # Last layer has 2 outputs\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32,\n        ...     sensor_list=[sensor_points, sensor_values]\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The model outputs include both the solution and the identified\n        parameter. The training process balances PDE residuals, boundary\n        conditions, and sensor data matching.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        orig_factor_matrices: list,\n        force_function_list: list,\n        sensor_list: list,  # for inverse problem\n        tensor_dtype,\n        use_attention: bool = False,\n        activation: str = \"tanh\",\n        hessian: bool = False,\n    ):\n        \"\"\"\n        Constructor for the DenseModel_Inverse_Domain class.\n\n        Args:\n            layer_dims (list): List of neurons per layer including input/output\n            learning_rate_dict (dict): Learning rate configuration\n            params_dict (dict): Model parameters\n            loss_function: Custom loss function for PDE residuals\n            input_tensors_list (list): List of input tensors\n            orig_factor_matrices (list): List of factor matrices\n            force_function_list (list): List of force functions\n            sensor_list (list): List of sensor data\n            tensor_dtype: TensorFlow data type for computations\n            use_attention (bool): Whether to use attention mechanism\n            activation (str): Activation function for hidden layers\n            hessian (bool): Whether to compute Hessian\n\n        Returns:\n            None\n        \"\"\"\n        super(DenseModel_Inverse_Domain, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        self.sensor_list = sensor_list\n        # obtain sensor values\n        self.sensor_points = sensor_list[0]\n        self.sensor_values = sensor_list[1]\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.orig_factor_matrices = orig_factor_matrices\n        self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n        self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[1]\n        )\n        self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n            orig_factor_matrices[2]\n        )\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.pre_multiplier_val = self.shape_function_mat_list\n        self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n        self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n        )\n        print(\n            f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        # staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        # build the model using the input shape of the first layer in self.layer_dims\n        input_shape = (None, self.layer_dims[0])\n        # build the model\n        self.build(input_shape=input_shape)\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        # print model summary\n        self.summary()\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                layers.Dense(\n                    self.layer_dims[dim + 1],\n                    activation=self.activation,\n                    kernel_initializer=\"glorot_uniform\",\n                    dtype=self.tensor_dtype,\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            layers.Dense(\n                self.layer_dims[-1],\n                activation=None,\n                kernel_initializer=\"glorot_uniform\",\n                dtype=self.tensor_dtype,\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"\n        The call method for the model.\n\n        Args:\n            inputs: The input tensor to the model.\n\n        Returns:\n            tf.Tensor: The output tensor from the model.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"\n        Get the configuration of the model.\n\n        Returns:\n            dict: The configuration of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"orig_factor_matrices\": self.orig_factor_matrices,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n                \"sensor_list\": self.sensor_list,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(\n        self, beta=10, bilinear_params_dict=None\n    ) -&gt; dict:  # pragma: no cover\n        \"\"\"\n        The train step method for the model.\n\n        Args:\n            beta: The weight for the boundary loss\n            bilinear_params_dict: The bilinear parameters dictionary\n\n        Returns:\n            dict: The loss values for the model.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n            # reshape the predicted values to (, 1)\n            predicted_values_dirichlet = tf.reshape(\n                predicted_values_dirichlet[:, 0], [-1, 1]\n            )\n\n            # predict the sensor values\n            predicted_sensor_values = self(self.sensor_points)\n            # reshape the predicted values to (, 1)\n            predicted_sensor_values = tf.reshape(predicted_sensor_values[:, 0], [-1, 1])\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                predicted_values_actual = self(self.input_tensor)\n\n                predicted_values = predicted_values_actual[:, 0]\n                inverse_param_values = predicted_values_actual[:, 1]\n\n            # compute the gradients of the predicted values wrt the input which is (x, y)\n            # First column of the predicted values is the predicted value of the PDE\n            gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n            # obtain inverse param gradients\n            inverse_param_gradients = tape1.gradient(\n                inverse_param_values, self.input_tensor\n            )\n\n            # Split the gradients into x and y components and reshape them to (-1, 1)\n            # the reshaping is done for the tensorial operations purposes (refer Notebook)\n            pred_grad_x = tf.reshape(\n                gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n            pred_grad_y = tf.reshape(\n                gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            # First column of the predicted values is the predicted value of the PDE and reshape it to (N_cells, N_quadrature_points)\n            pred_val = tf.reshape(\n                predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            # reshape the second column of the predicted value and reshape it to (N_cells, N_quadrature_points)\n            inverse_param_values = tf.reshape(\n                inverse_param_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n            )  # shape : (N_cells , N_quadrature_points)\n\n            cells_residual = self.loss_function(\n                test_shape_val_mat=self.pre_multiplier_val,\n                test_grad_x_mat=self.pre_multiplier_grad_x,\n                test_grad_y_mat=self.pre_multiplier_grad_y,\n                pred_nn=pred_val,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n                inverse_params_list=[inverse_param_values],\n            )\n\n            residual = tf.reduce_sum(cells_residual)\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + residual\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Sensor loss\n            sensor_loss = tf.reduce_mean(\n                tf.square(predicted_sensor_values - self.sensor_values), axis=0\n            )\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n            \"sensor_loss\": sensor_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.__init__","title":"<code>__init__(layer_dims, learning_rate_dict, params_dict, loss_function, input_tensors_list, orig_factor_matrices, force_function_list, sensor_list, tensor_dtype, use_attention=False, activation='tanh', hessian=False)</code>","text":"<p>Constructor for the DenseModel_Inverse_Domain class.</p> <p>Parameters:</p> Name Type Description Default <code>layer_dims</code> <code>list</code> <p>List of neurons per layer including input/output</p> required <code>learning_rate_dict</code> <code>dict</code> <p>Learning rate configuration</p> required <code>params_dict</code> <code>dict</code> <p>Model parameters</p> required <code>loss_function</code> <p>Custom loss function for PDE residuals</p> required <code>input_tensors_list</code> <code>list</code> <p>List of input tensors</p> required <code>orig_factor_matrices</code> <code>list</code> <p>List of factor matrices</p> required <code>force_function_list</code> <code>list</code> <p>List of force functions</p> required <code>sensor_list</code> <code>list</code> <p>List of sensor data</p> required <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> required <code>use_attention</code> <code>bool</code> <p>Whether to use attention mechanism</p> <code>False</code> <code>activation</code> <code>str</code> <p>Activation function for hidden layers</p> <code>'tanh'</code> <code>hessian</code> <code>bool</code> <p>Whether to compute Hessian</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>def __init__(\n    self,\n    layer_dims: list,\n    learning_rate_dict: dict,\n    params_dict: dict,\n    loss_function,\n    input_tensors_list: list,\n    orig_factor_matrices: list,\n    force_function_list: list,\n    sensor_list: list,  # for inverse problem\n    tensor_dtype,\n    use_attention: bool = False,\n    activation: str = \"tanh\",\n    hessian: bool = False,\n):\n    \"\"\"\n    Constructor for the DenseModel_Inverse_Domain class.\n\n    Args:\n        layer_dims (list): List of neurons per layer including input/output\n        learning_rate_dict (dict): Learning rate configuration\n        params_dict (dict): Model parameters\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list (list): List of input tensors\n        orig_factor_matrices (list): List of factor matrices\n        force_function_list (list): List of force functions\n        sensor_list (list): List of sensor data\n        tensor_dtype: TensorFlow data type for computations\n        use_attention (bool): Whether to use attention mechanism\n        activation (str): Activation function for hidden layers\n        hessian (bool): Whether to compute Hessian\n\n    Returns:\n        None\n    \"\"\"\n    super(DenseModel_Inverse_Domain, self).__init__()\n    self.layer_dims = layer_dims\n    self.use_attention = use_attention\n    self.activation = activation\n    self.layer_list = []\n    self.loss_function = loss_function\n    self.hessian = hessian\n\n    self.tensor_dtype = tensor_dtype\n\n    self.sensor_list = sensor_list\n    # obtain sensor values\n    self.sensor_points = sensor_list[0]\n    self.sensor_values = sensor_list[1]\n\n    # if dtype is not a valid tensorflow dtype, raise an error\n    if not isinstance(self.tensor_dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    self.orig_factor_matrices = orig_factor_matrices\n    self.shape_function_mat_list = copy.deepcopy(orig_factor_matrices[0])\n    self.shape_function_grad_x_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[1]\n    )\n    self.shape_function_grad_y_factor_mat_list = copy.deepcopy(\n        orig_factor_matrices[2]\n    )\n\n    self.force_function_list = force_function_list\n\n    self.input_tensors_list = input_tensors_list\n    self.input_tensor = copy.deepcopy(input_tensors_list[0])\n    self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n    self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n    self.params_dict = params_dict\n\n    self.pre_multiplier_val = self.shape_function_mat_list\n    self.pre_multiplier_grad_x = self.shape_function_grad_x_factor_mat_list\n    self.pre_multiplier_grad_y = self.shape_function_grad_y_factor_mat_list\n\n    self.force_matrix = self.force_function_list\n\n    print(f\"{'-'*74}\")\n    print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n    print(f\"{'-'*74}\")\n    print(\n        f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n    )\n    print(\n        f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_x':&lt;25} | {str(self.pre_multiplier_grad_x.shape):&lt;25} | {self.pre_multiplier_grad_x.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_grad_y':&lt;25} | {str(self.pre_multiplier_grad_y.shape):&lt;25} | {self.pre_multiplier_grad_y.dtype}\"\n    )\n    print(\n        f\"| {'pre_multiplier_val':&lt;25} | {str(self.pre_multiplier_val.shape):&lt;25} | {self.pre_multiplier_val.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n    )\n    print(f\"{'-'*74}\")\n\n    self.n_cells = params_dict[\"n_cells\"]\n\n    ## ----------------------------------------------------------------- ##\n    ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # parse the learning rate dictionary\n    self.learning_rate_dict = learning_rate_dict\n    initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n    use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n    decay_steps = learning_rate_dict[\"decay_steps\"]\n    decay_rate = learning_rate_dict[\"decay_rate\"]\n    # staircase = learning_rate_dict[\"staircase\"]\n\n    if use_lr_scheduler:\n        learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n            initial_learning_rate, decay_steps, decay_rate, staircase=True\n        )\n    else:\n        learning_rate_fn = initial_learning_rate\n\n    self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n    # build the model using the input shape of the first layer in self.layer_dims\n    input_shape = (None, self.layer_dims[0])\n    # build the model\n    self.build(input_shape=input_shape)\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    # print model summary\n    self.summary()\n\n    ## ----------------------------------------------------------------- ##\n    ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # Build dense layers based on the input list\n    for dim in range(len(self.layer_dims) - 2):\n        self.layer_list.append(\n            layers.Dense(\n                self.layer_dims[dim + 1],\n                activation=self.activation,\n                kernel_initializer=\"glorot_uniform\",\n                dtype=self.tensor_dtype,\n                bias_initializer=\"zeros\",\n            )\n        )\n\n    # Add a output layer with no activation\n    self.layer_list.append(\n        layers.Dense(\n            self.layer_dims[-1],\n            activation=None,\n            kernel_initializer=\"glorot_uniform\",\n            dtype=self.tensor_dtype,\n            bias_initializer=\"zeros\",\n        )\n    )\n\n    # Add attention layer if required\n    if self.use_attention:\n        self.attention_layer = layers.Attention()\n\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    self.build(input_shape=(None, self.layer_dims[0]))\n\n    # print the summary of the model\n    self.summary()\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.call","title":"<code>call(inputs)</code>","text":"<p>The call method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input tensor to the model.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: The output tensor from the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"\n    The call method for the model.\n\n    Args:\n        inputs: The input tensor to the model.\n\n    Returns:\n        tf.Tensor: The output tensor from the model.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.get_config","title":"<code>get_config()</code>","text":"<p>Get the configuration of the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The configuration of the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"\n    Get the configuration of the model.\n\n    Returns:\n        dict: The configuration of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"orig_factor_matrices\": self.orig_factor_matrices,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n            \"sensor_list\": self.sensor_list,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/model/model_inverse_domain/#scirex.core.sciml.fastvpinns.model.model_inverse_domain.DenseModel_Inverse_Domain.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>The train step method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <p>The weight for the boundary loss</p> <code>10</code> <code>bilinear_params_dict</code> <p>The bilinear parameters dictionary</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loss values for the model.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\model\\model_inverse_domain.py</code> <pre><code>@tf.function\ndef train_step(\n    self, beta=10, bilinear_params_dict=None\n) -&gt; dict:  # pragma: no cover\n    \"\"\"\n    The train step method for the model.\n\n    Args:\n        beta: The weight for the boundary loss\n        bilinear_params_dict: The bilinear parameters dictionary\n\n    Returns:\n        dict: The loss values for the model.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n        # reshape the predicted values to (, 1)\n        predicted_values_dirichlet = tf.reshape(\n            predicted_values_dirichlet[:, 0], [-1, 1]\n        )\n\n        # predict the sensor values\n        predicted_sensor_values = self(self.sensor_points)\n        # reshape the predicted values to (, 1)\n        predicted_sensor_values = tf.reshape(predicted_sensor_values[:, 0], [-1, 1])\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n            # Compute the predicted values from the model\n            predicted_values_actual = self(self.input_tensor)\n\n            predicted_values = predicted_values_actual[:, 0]\n            inverse_param_values = predicted_values_actual[:, 1]\n\n        # compute the gradients of the predicted values wrt the input which is (x, y)\n        # First column of the predicted values is the predicted value of the PDE\n        gradients = tape1.gradient(predicted_values, self.input_tensor)\n\n        # obtain inverse param gradients\n        inverse_param_gradients = tape1.gradient(\n            inverse_param_values, self.input_tensor\n        )\n\n        # Split the gradients into x and y components and reshape them to (-1, 1)\n        # the reshaping is done for the tensorial operations purposes (refer Notebook)\n        pred_grad_x = tf.reshape(\n            gradients[:, 0], [self.n_cells, self.pre_multiplier_grad_x.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n        pred_grad_y = tf.reshape(\n            gradients[:, 1], [self.n_cells, self.pre_multiplier_grad_y.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        # First column of the predicted values is the predicted value of the PDE and reshape it to (N_cells, N_quadrature_points)\n        pred_val = tf.reshape(\n            predicted_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        # reshape the second column of the predicted value and reshape it to (N_cells, N_quadrature_points)\n        inverse_param_values = tf.reshape(\n            inverse_param_values, [self.n_cells, self.pre_multiplier_val.shape[-1]]\n        )  # shape : (N_cells , N_quadrature_points)\n\n        cells_residual = self.loss_function(\n            test_shape_val_mat=self.pre_multiplier_val,\n            test_grad_x_mat=self.pre_multiplier_grad_x,\n            test_grad_y_mat=self.pre_multiplier_grad_y,\n            pred_nn=pred_val,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n            inverse_params_list=[inverse_param_values],\n        )\n\n        residual = tf.reduce_sum(cells_residual)\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + residual\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Sensor loss\n        sensor_loss = tf.reduce_mean(\n            tf.square(predicted_sensor_values - self.sensor_values), axis=0\n        )\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss + 10 * sensor_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n        \"sensor_loss\": sensor_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d/","title":"cd2d","text":"<p>Loss Function Implementation for 2D Convection-Diffusion Problem.</p> <p>This module implements the loss function for solving 2D convection-diffusion  equations using neural networks. It focuses on computing residuals in the weak  form of the PDE with known coefficients.</p> Key functions <ul> <li>pde_loss_cd2d: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d/#scirex.core.sciml.fastvpinns.physics.cd2d.pde_loss_cd2d","title":"<code>pde_loss_cd2d(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params)</code>","text":"<p>Calculates residual for 2D convection-diffusion problem.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D convection-diffusion equations with known coefficients using efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient b_x: x-direction convection coefficient b_y: y-direction convection coefficient c: reaction coefficient</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9 - Reaction term: \u222bcuv d\u03a9 where \u03b5, b, and c are known coefficients.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\cd2d.py</code> <pre><code>def pde_loss_cd2d(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for 2D convection-diffusion problem.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D convection-diffusion equations with known coefficients using\n    efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            eps: Diffusion coefficient\n            b_x: x-direction convection coefficient\n            b_y: y-direction convection coefficient\n            c: reaction coefficient\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9\n        - Reaction term: \u222bcuv d\u03a9\n        where \u03b5, b, and c are known coefficients.\n    \"\"\"\n\n    # Loss Function : \u222bdu/dx. dv/dx  +  \u222bdu/dy. dv/dy - \u222bf.v\n\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = bilinear_params[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    # \u222bdu/dx. v d\u03a9\n    conv_x = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_x_nn))\n\n    # # \u222bdu/dy. v d\u03a9\n    conv_y = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_y_nn))\n\n    # # b(x) * \u222bdu/dx. v d\u03a9 + b(y) * \u222bdu/dy. v d\u03a9\n    conv = bilinear_params[\"b_x\"] * conv_x + bilinear_params[\"b_y\"] * conv_y\n\n    # reaction term\n    # \u222bc.u.v d\u03a9\n    reaction = bilinear_params[\"c\"] * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = (pde_diffusion + conv + reaction) - forcing_function\n\n    # Perform Reduce mean along the axis 0\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse/","title":"cd2d_inverse","text":"<p>Loss Function Implementation for Convection-Diffusion 2D Inverse Problems.</p> <p>This module implements the loss function for solving inverse problems in 2D convection-diffusion equations with constant coefficients using neural networks. It focuses on computing residuals in the weak form of the PDE for parameter identification.</p> Key functions <ul> <li>pde_loss_cd2d: Computes domain-based PDE loss for constant coefficients</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse/#scirex.core.sciml.fastvpinns.physics.cd2d_inverse.pde_loss_cd2d","title":"<code>pde_loss_cd2d(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params_dict, inverse_param_dict)</code>","text":"<p>Calculates residual for convection-diffusion inverse problem with constant coefficients.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D convection-diffusion inverse problems. Handles constant coefficient identification through efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params_dict</code> <code>dict</code> <p>Dictionary containing: b_x: x-direction convection coefficient b_y: y-direction convection coefficient c: reaction coefficient</p> required <code>inverse_param_dict</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient to be identified</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9 - Reaction term: \u222bcuv d\u03a9 where \u03b5 is the constant diffusion coefficient to be identified.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\cd2d_inverse.py</code> <pre><code>def pde_loss_cd2d(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params_dict: dict,\n    inverse_param_dict: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for convection-diffusion inverse problem with constant coefficients.\n\n    Implements the FastVPINNs methodology for computing variational residuals in 2D\n    convection-diffusion inverse problems. Handles constant coefficient identification\n    through efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params_dict: Dictionary containing:\n            b_x: x-direction convection coefficient\n            b_y: y-direction convection coefficient\n            c: reaction coefficient\n        inverse_param_dict: Dictionary containing:\n            eps: Diffusion coefficient to be identified\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9\n        - Reaction term: \u222bcuv d\u03a9\n        where \u03b5 is the constant diffusion coefficient to be identified.\n    \"\"\"\n\n    # Loss Function : \u222bdu/dx. dv/dx  +  \u222bdu/dy. dv/dy - \u222bf.v\n\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = inverse_param_dict[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    # \u222bdu/dx. v d\u03a9\n    conv_x = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_x_nn))\n\n    # # \u222bdu/dy. v d\u03a9\n    conv_y = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_y_nn))\n\n    # # b(x) * \u222bdu/dx. v d\u03a9 + b(y) * \u222bdu/dy. v d\u03a9\n    conv = bilinear_params_dict[\"b_x\"] * conv_x + bilinear_params_dict[\"b_y\"] * conv_y\n\n    # reaction term\n    # \u222bc.u.v d\u03a9\n    reaction = bilinear_params_dict[\"c\"] * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = (pde_diffusion + conv + reaction) - forcing_function\n\n    # Perform Reduce mean along the axis 0\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse_domain/","title":"cd2d_inverse_domain","text":"<p>Loss Function Implementation for Convection-Diffusion 2D Inverse Problems.</p> <p>This module implements the loss function for solving inverse problems in 2D convection-diffusion equations using neural networks. It focuses on computing residuals in the weak form of the PDE for parameter identification.</p> Key functions <ul> <li>pde_loss_cd2d_inverse_domain: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries  DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/cd2d_inverse_domain/#scirex.core.sciml.fastvpinns.physics.cd2d_inverse_domain.pde_loss_cd2d_inverse_domain","title":"<code>pde_loss_cd2d_inverse_domain(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params, inverse_params_list)</code>","text":"<p>Computes domain-based loss for 2D convection-diffusion inverse problem.</p> <p>Implements the weak form residual calculation for parameter identification in 2D convection-diffusion equations. The loss includes diffusion, convection, and reaction terms.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: - b_x: x-direction convection coefficient - b_y: y-direction convection coefficient - c: reaction coefficient</p> required <code>inverse_params_list</code> <code>list</code> <p>List containing: - diffusion coefficient neural network</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Notes <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9 - Reaction term: \u222bcuv d\u03a9 where \u03b5 is the diffusion coefficient to be identified.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\cd2d_inverse_domain.py</code> <pre><code>def pde_loss_cd2d_inverse_domain(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n    inverse_params_list: list,\n) -&gt; tf.Tensor:\n    \"\"\"Computes domain-based loss for 2D convection-diffusion inverse problem.\n\n    Implements the weak form residual calculation for parameter identification\n    in 2D convection-diffusion equations. The loss includes diffusion,\n    convection, and reaction terms.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            - b_x: x-direction convection coefficient\n            - b_y: y-direction convection coefficient\n            - c: reaction coefficient\n        inverse_params_list: List containing:\n            - diffusion coefficient neural network\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Notes:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        - Convection term: \u222b(b\u00b7\u2207u)v d\u03a9\n        - Reaction term: \u222bcuv d\u03a9\n        where \u03b5 is the diffusion coefficient to be identified.\n    \"\"\"\n\n    # The first values in the inverse_params_list is the number of inverse problems\n    diffusion_coeff_NN = inverse_params_list[0]\n\n    # \u222b\u03b5.du/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(\n        tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn * diffusion_coeff_NN)\n    )\n\n    # \u222b\u03b5.du/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(\n        tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn * diffusion_coeff_NN)\n    )\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    # Here our eps is a variable which is to be learned, Which is already premultiplied with the predicted gradient of the neural network\n    pde_diffusion = pde_diffusion_x + pde_diffusion_y\n\n    # \u222bdu/dx. v d\u03a9\n    conv_x = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_x_nn))\n\n    # # \u222bdu/dy. v d\u03a9\n    conv_y = tf.transpose(tf.linalg.matvec(test_shape_val_mat, pred_grad_y_nn))\n\n    # # b(x) * \u222bdu/dx. v d\u03a9 + b(y) * \u222bdu/dy. v d\u03a9\n    conv = bilinear_params[\"b_x\"] * conv_x + bilinear_params[\"b_y\"] * conv_y\n\n    # reaction term\n    # \u222bc.u.v d\u03a9\n    reaction = bilinear_params[\"c\"] * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = (pde_diffusion + conv + reaction) - forcing_function\n\n    # Perform Reduce mean along the axis 0\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/helmholtz2d/","title":"helmholtz2d","text":"<p>Loss Function Implementation for 2D Helmholtz Problem.</p> <p>This module implements the loss function for solving the 2D Helmholtz equation using neural networks. It focuses on computing residuals in the weak form  of the PDE with wave number parameter.</p> Key functions <ul> <li>pde_loss_helmholtz: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/helmholtz2d/#scirex.core.sciml.fastvpinns.physics.helmholtz2d.pde_loss_helmholtz","title":"<code>pde_loss_helmholtz(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params)</code>","text":"<p>Calculates residual for 2D Helmholtz equation.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D Helmholtz equation (-\u0394u - k\u00b2u = f) using efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient (typically 1.0) k: Wave number parameter</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: -\u222b\u2207u\u00b7\u2207v d\u03a9 - Wave term: \u222bk\u00b2uv d\u03a9 Implementation handles high wave numbers through efficient tensor operations.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\helmholtz2d.py</code> <pre><code>def pde_loss_helmholtz(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for 2D Helmholtz equation.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D Helmholtz equation (-\u0394u - k\u00b2u = f) using efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            eps: Diffusion coefficient (typically 1.0)\n            k: Wave number parameter\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: -\u222b\u2207u\u00b7\u2207v d\u03a9\n        - Wave term: \u222bk\u00b2uv d\u03a9\n        Implementation handles high wave numbers through efficient\n        tensor operations.\n    \"\"\"\n    #  \u222b (du/dx. dv/dx ) d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    #  \u222b (du/dy. dv/dy ) d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = bilinear_params[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    # \\int(k^2 (u).v) dw\n    helmholtz_additional = (bilinear_params[\"k\"] ** 2) * tf.transpose(\n        tf.linalg.matvec(test_shape_val_mat, pred_nn)\n    )\n\n    residual_matrix = -1.0 * (pde_diffusion) + helmholtz_additional - forcing_function\n\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/helmholtz2d/#helmholtz-equation-loss-calculation-module","title":"Helmholtz Equation Loss Calculation Module","text":""},{"location":"api/core/sciml/fastvpinns/physics/poisson2d/","title":"poisson2d","text":"<p>Implementation of Tensor-Based Loss Calculation for 2D Poisson Equation.</p> <p>This module implements an efficient tensor-based approach for calculating variational residuals in 2D Poisson problems. The implementation leverages TensorFlow's tensor operations for fast computation of weak form terms.</p> Key functions <ul> <li>pde_loss_poisson: Computes domain-based PDE loss</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/poisson2d/#scirex.core.sciml.fastvpinns.physics.poisson2d.pde_loss_poisson","title":"<code>pde_loss_poisson(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params)</code>","text":"<p>Calculates residual for 2D Poisson equation.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D Poisson equation (-\u2207\u00b7(\u03b5\u2207u) = f) using efficient tensor operations.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 The implementation uses efficient tensor operations for computing the variational residual.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\poisson2d.py</code> <pre><code>def pde_loss_poisson(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for 2D Poisson equation.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D Poisson equation (-\u2207\u00b7(\u03b5\u2207u) = f) using efficient tensor operations.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Dictionary containing:\n            eps: Diffusion coefficient\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        The implementation uses efficient tensor operations for\n        computing the variational residual.\n    \"\"\"\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = bilinear_params[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    residual_matrix = pde_diffusion - forcing_function\n\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fastvpinns/physics/poisson_2d_inverse/","title":"poissson2d Inverse","text":"<p>Loss Function Implementation for 2D Poisson Inverse Problem.</p> <p>This module implements the loss function for solving the inverse Poisson equation with constant coefficient using neural networks. It focuses on computing residuals in the weak form of the PDE for diffusion coefficient identification.</p> Key functions <ul> <li>pde_loss_poisson_inverse: Computes domain-based PDE loss for   constant coefficient identification</li> </ul> Note <p>The implementation is based on the FastVPINNs methodology [1] for efficient computation of Variational residuals of PDEs.</p> References <p>[1] FastVPINNs: Tensor-Driven Acceleration of VPINNs for Complex Geometries     DOI: https://arxiv.org/abs/2404.12063</p>"},{"location":"api/core/sciml/fastvpinns/physics/poisson_2d_inverse/#scirex.core.sciml.fastvpinns.physics.poisson2d_inverse.pde_loss_poisson_inverse","title":"<code>pde_loss_poisson_inverse(test_shape_val_mat, test_grad_x_mat, test_grad_y_mat, pred_nn, pred_grad_x_nn, pred_grad_y_nn, forcing_function, bilinear_params, inverse_params_dict)</code>","text":"<p>Calculates residual for Poisson inverse problem with constant coefficient.</p> <p>Implements the FastVPINNs methodology for computing variational residuals in 2D Poisson inverse problems (-\u2207\u00b7(\u03b5\u2207u) = f) with unknown constant diffusion coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>test_shape_val_mat</code> <code>Tensor</code> <p>Test function values at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_x_mat</code> <code>Tensor</code> <p>Test function x-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>test_grad_y_mat</code> <code>Tensor</code> <p>Test function y-derivatives at quadrature points Shape: (n_elements, n_test_functions, n_quad_points)</p> required <code>pred_nn</code> <code>Tensor</code> <p>Neural network solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_x_nn</code> <code>Tensor</code> <p>x-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>pred_grad_y_nn</code> <code>Tensor</code> <p>y-derivative of NN solution at quadrature points Shape: (n_elements, n_quad_points)</p> required <code>forcing_function</code> <code>callable</code> <p>Right-hand side forcing term</p> required <code>bilinear_params</code> <code>dict</code> <p>Additional bilinear form parameters (if any)</p> required <code>inverse_params_dict</code> <code>dict</code> <p>Dictionary containing: eps: Diffusion coefficient to be identified</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Cell-wise residuals averaged over test functions Shape: (n_cells,)</p> Note <p>The weak form includes: - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9 where \u03b5 is the constant diffusion coefficient to be identified.</p> Source code in <code>scirex\\core\\sciml\\fastvpinns\\physics\\poisson2d_inverse.py</code> <pre><code>def pde_loss_poisson_inverse(\n    test_shape_val_mat: tf.Tensor,\n    test_grad_x_mat: tf.Tensor,\n    test_grad_y_mat: tf.Tensor,\n    pred_nn: tf.Tensor,\n    pred_grad_x_nn: tf.Tensor,\n    pred_grad_y_nn: tf.Tensor,\n    forcing_function: callable,\n    bilinear_params: dict,\n    inverse_params_dict: dict,\n) -&gt; tf.Tensor:\n    \"\"\"Calculates residual for Poisson inverse problem with constant coefficient.\n\n    Implements the FastVPINNs methodology for computing variational residuals\n    in 2D Poisson inverse problems (-\u2207\u00b7(\u03b5\u2207u) = f) with unknown constant\n    diffusion coefficient.\n\n    Args:\n        test_shape_val_mat: Test function values at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_x_mat: Test function x-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        test_grad_y_mat: Test function y-derivatives at quadrature points\n            Shape: (n_elements, n_test_functions, n_quad_points)\n        pred_nn: Neural network solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_x_nn: x-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        pred_grad_y_nn: y-derivative of NN solution at quadrature points\n            Shape: (n_elements, n_quad_points)\n        forcing_function: Right-hand side forcing term\n        bilinear_params: Additional bilinear form parameters (if any)\n        inverse_params_dict: Dictionary containing:\n            eps: Diffusion coefficient to be identified\n\n    Returns:\n        Cell-wise residuals averaged over test functions\n            Shape: (n_cells,)\n\n    Note:\n        The weak form includes:\n        - Diffusion term: \u222b\u03b5\u2207u\u00b7\u2207v d\u03a9\n        where \u03b5 is the constant diffusion coefficient to be identified.\n    \"\"\"\n    # \u222bdu/dx. dv/dx d\u03a9\n    pde_diffusion_x = tf.transpose(tf.linalg.matvec(test_grad_x_mat, pred_grad_x_nn))\n\n    # \u222bdu/dy. dv/dy d\u03a9\n    pde_diffusion_y = tf.transpose(tf.linalg.matvec(test_grad_y_mat, pred_grad_y_nn))\n\n    # eps * \u222b (du/dx. dv/dx + du/dy. dv/dy) d\u03a9\n    pde_diffusion = inverse_params_dict[\"eps\"] * (pde_diffusion_x + pde_diffusion_y)\n\n    residual_matrix = pde_diffusion - forcing_function\n\n    residual_cells = tf.reduce_mean(tf.square(residual_matrix), axis=0)\n\n    return residual_cells\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/","title":"Chebyshev","text":"<p>Module: basis_2d_qn_chebyshev_2.py</p> <p>This module implements a specialized basis function class for 2D finite elements using Chebyshev polynomials.  It provides functionality for computing basis functions and their derivatives in two dimensions, primarily used  in variational physics-informed neural networks (VPINNs) with domain decomposition.</p> <p>Classes:</p> Name Description <code>Basis2DQNChebyshev2</code> <p>Main class implementing 2D basis functions using Chebyshev polynomials</p> Dependencies <ul> <li>numpy: For numerical computations and array operations</li> <li>scipy.special: For Jacobi polynomial calculations and evaluations</li> <li>.basis_function_2d: For base class BasisFunction2D implementation</li> </ul> Key Features <ul> <li>Implementation of 2D element basis functions using Chebyshev polynomials</li> <li>Computation of function values and derivatives up to second order</li> <li>Tensor product construction of 2D basis functions from 1D components</li> <li>Specialized handling of Jacobi polynomials for test functions</li> <li>Support for variable number of shape functions through initialization</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> Version Info <p>27/Dec/2024: Initial version: Thivin Anandh D</p> References <ul> <li>hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Chebyshev_2/#scirex.core.sciml.fe.basis_2d_qn_chebyshev_2.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/","title":"jacobi","text":"<p>Module: basis_2d_QN_Jacobi.py</p> <p>This module implements a specialized basis function class for 2D QN finite elements using Jacobi polynomials.   It provides functionality for computing basis functions and their derivatives in two dimensions, primarily used   in variational physics-informed neural networks (VPINNs) with domain decomposition.</p> <p>Classes:      Basis2DQNJacobi: Main class implementing 2D basis functions using Jacobi polynomials</p> <p>Dependencies:      - numpy: For numerical computations      - scipy.special: For Jacobi polynomial calculations      - .basis_function_2d: For base class implementation</p> <p>Key Features:      - Implementation of 2D QN element basis functions using Jacobi polynomials      - Computation of function values and derivatives up to second order      - Tensor product construction of 2D basis functions from 1D components      - Specialized handling of Jacobi polynomials for test functions      - Support for variable number of shape functions</p> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> <p>Version Info:      27/Dec/2024: Initial version: Thivin Anandh D</p> <p>References:      - hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition: https://github.com/ehsankharazmi/hp-VPINNs/</p>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Jacobi/#scirex.core.sciml.fe.basis_2d_qn_jacobi.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/","title":"Legendre","text":"<p>Module: basis_2d_QN_Legendre.py</p> <p>This module implements a specialized basis function class for 2D Quad elements using Legendre polynomials.  It provides functionality for computing basis functions and their derivatives in two dimensions, primarily used  in variational physics-informed neural networks (VPINNs) with domain decomposition.</p> <p>Classes:</p> Name Description <code>Basis2DQNLegendre</code> <p>Main class implementing 2D basis functions using Legendre polynomials</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>scipy.special: For Jacobi polynomial calculations</li> <li>.basis_function_2d: For base class implementation</li> </ul> Key Features <ul> <li>Implementation of 2D Q1 element basis functions using Legendre polynomials</li> <li>Computation of function values and derivatives up to second order</li> <li>Tensor product construction of 2D basis functions from 1D components</li> <li>Specialized handling of Jacobi polynomials for test functions</li> <li>Support for variable number of shape functions</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> <p>Version Info:     27/Dec/2024: Initial version: Thivin Anandh D</p> References <ul> <li>hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre/#scirex.core.sciml.fe.basis_2d_qn_legendre.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/","title":"Legendre_Special","text":"<p>Module: basis_2d_QN_Legendre_Special.py</p> <p>This module implements a specialized basis function class for 2D Quad elements using Legendre polynomials.  It provides functionality for computing basis functions and their derivatives in two dimensions, with a  special formulation based on differences of consecutive Legendre polynomials.</p> <p>Classes:</p> Name Description <code>Basis2DQNLegendreSpecial</code> <p>Main class implementing 2D basis functions using special Legendre polynomials</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>scipy.special: For Legendre polynomial calculations</li> <li>matplotlib.pyplot: For visualization support</li> <li>.basis_function_2d: For base class implementation</li> </ul> Key Features <ul> <li>Implementation of 2D Quad element basis functions using Legendre polynomials</li> <li>Special formulation using differences of consecutive polynomials</li> <li>Computation of function values and derivatives up to second order</li> <li>Tensor product construction of 2D basis functions from 1D components</li> <li>Support for variable number of shape functions</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> <p>Version Info:     27/Dec/2024: Initial version: Thivin Anandh D References:     None</p>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_2d_QN_Legendre_Special/#scirex.core.sciml.fe.basis_2d_qn_legendre_special.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/","title":"Function 2D","text":"<p>Module: basis_function_2d.py</p> <p>This module provides the abstract base class for all 2D finite element basis functions  used in the FE2D code. It defines the interface for computing basis functions and their  derivatives in reference coordinates.</p> <p>Classes:</p> Name Description <code>BasisFunction2D</code> <p>Abstract base class for 2D finite element basis functions</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Abstract interface for 2D basis function evaluation</li> <li>Support for first and second order derivatives</li> <li>Reference coordinate system (xi, eta) implementation</li> <li>Unified interface for different polynomial bases</li> <li>Common structure for Legendre, Jacobi, and Chebyshev implementations</li> </ul> Authors <p>Thivin Anandh (http://thivinanandh.github.io/) </p> Version Info <p>27/Dec/2024: Initial version: Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D","title":"<code>BasisFunction2D</code>","text":"<p>An abstract base class defining the interface for two-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 2D basis functions (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines the required methods for function evaluation and derivatives.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Number of shape functions in the element. Typically a perfect square for tensor-product bases.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates basis functions at given reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of basis functions at (xi, eta)</p> <code>gradx</code> <p>Computes x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of x-derivatives at (xi, eta)</p> <code>grady</code> <p>Computes y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of y-derivatives at (xi, eta)</p> <code>gradxx</code> <p>Computes second x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second x-derivatives at (xi, eta)</p> <code>gradxy</code> <p>Computes mixed derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of mixed derivatives at (xi, eta)</p> <code>gradyy</code> <p>Computes second y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second y-derivatives at (xi, eta)</p> Notes <ul> <li>All coordinate inputs (xi, eta) should be in the reference element range</li> <li>Subclasses must implement all abstract methods</li> <li>Used as base class for specific polynomial implementations:<ul> <li>Legendre polynomials (normal and special variants)</li> <li>Jacobi polynomials</li> <li>Chebyshev polynomials</li> </ul> </li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>class BasisFunction2D:\n    \"\"\"\n    An abstract base class defining the interface for two-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 2D basis functions\n    (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines\n    the required methods for function evaluation and derivatives.\n\n    Attributes:\n        num_shape_functions (int): Number of shape functions in the element.\n            Typically a perfect square for tensor-product bases.\n\n    Methods:\n        value(xi, eta): Evaluates basis functions at given reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of basis functions at (xi, eta)\n\n        gradx(xi, eta): Computes x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of x-derivatives at (xi, eta)\n\n        grady(xi, eta): Computes y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of y-derivatives at (xi, eta)\n\n        gradxx(xi, eta): Computes second x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second x-derivatives at (xi, eta)\n\n        gradxy(xi, eta): Computes mixed derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of mixed derivatives at (xi, eta)\n\n        gradyy(xi, eta): Computes second y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second y-derivatives at (xi, eta)\n\n    Notes:\n        - All coordinate inputs (xi, eta) should be in the reference element range\n        - Subclasses must implement all abstract methods\n        - Used as base class for specific polynomial implementations:\n            - Legendre polynomials (normal and special variants)\n            - Jacobi polynomials\n            - Chebyshev polynomials\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (float): The xi coordinate.\n            eta (float): The eta coordinate.\n\n        Returns:\n            float: The value of the basis function at ( xi, eta).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradx","title":"<code>gradx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradxx","title":"<code>gradxx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradxy","title":"<code>gradxy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.grady","title":"<code>grady(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.gradyy","title":"<code>gradyy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_2d/#scirex.core.sciml.fe.basis_function_2d.BasisFunction2D.value","title":"<code>value(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>float</code> <p>The xi coordinate.</p> required <code>eta</code> <code>float</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>The value of the basis function at ( xi, eta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (float): The xi coordinate.\n        eta (float): The eta coordinate.\n\n    Returns:\n        float: The value of the basis function at ( xi, eta).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/","title":"Function 3D","text":"<p>Module: basis_function_3d.py</p> <p>This module provides the abstract base class for all 3D finite element basis functions.  It defines the interface for computing basis functions and their derivatives in three-dimensional  reference coordinates.</p> <p>Classes:</p> Name Description <code>BasisFunction3D</code> <p>Abstract base class for 3D finite element basis functions</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Abstract interface for 3D basis function evaluation</li> <li>Support for first and second order derivatives</li> <li>Reference coordinate system (xi, eta, zeta) implementation</li> <li>Unified interface for different polynomial bases</li> <li>Systematic derivative computation in three dimensions</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version: Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D","title":"<code>BasisFunction3D</code>","text":"<p>An abstract base class defining the interface for three-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 3D basis functions used in finite element computations. It defines the required methods for function evaluation and derivatives in three dimensions.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>The number of shape functions in the 3D element. Must be specified during initialization.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates the basis function at given coordinates Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Value of basis function at (xi, eta, zeta)</p> <code>gradx</code> <p>Computes derivative w.r.t. xi Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Partial derivative w.r.t. xi</p> <code>grady</code> <p>Computes derivative w.r.t. eta Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Partial derivative w.r.t. eta</p> <code>gradxx</code> <p>Computes second derivative w.r.t. xi Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Second partial derivative w.r.t. xi</p> <code>gradxy</code> <p>Computes mixed derivative w.r.t. xi and eta Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Mixed partial derivative w.r.t. xi and eta</p> <code>gradyy</code> <p>Computes second derivative w.r.t. eta Args:     xi (np.ndarray): First reference coordinate     eta (np.ndarray): Second reference coordinate     zeta (np.ndarray): Third reference coordinate Returns:     float: Second partial derivative w.r.t. eta</p> Notes <ul> <li>All coordinate inputs (xi, eta, zeta) should be in the reference element range</li> <li>All methods are abstract and must be implemented by derived classes</li> <li>Implementation should ensure proper handling of 3D tensor-product bases</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>class BasisFunction3D:  # pragma: no cover\n    \"\"\"\n    An abstract base class defining the interface for three-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 3D basis functions\n    used in finite element computations. It defines the required methods for function\n    evaluation and derivatives in three dimensions.\n\n    Attributes:\n        num_shape_functions (int): The number of shape functions in the 3D element.\n            Must be specified during initialization.\n\n    Methods:\n        value(xi, eta, zeta): Evaluates the basis function at given coordinates\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Value of basis function at (xi, eta, zeta)\n\n        gradx(xi, eta, zeta): Computes derivative w.r.t. xi\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Partial derivative w.r.t. xi\n\n        grady(xi, eta, zeta): Computes derivative w.r.t. eta\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Partial derivative w.r.t. eta\n\n        gradxx(xi, eta, zeta): Computes second derivative w.r.t. xi\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Second partial derivative w.r.t. xi\n\n        gradxy(xi, eta, zeta): Computes mixed derivative w.r.t. xi and eta\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Mixed partial derivative w.r.t. xi and eta\n\n        gradyy(xi, eta, zeta): Computes second derivative w.r.t. eta\n            Args:\n                xi (np.ndarray): First reference coordinate\n                eta (np.ndarray): Second reference coordinate\n                zeta (np.ndarray): Third reference coordinate\n            Returns:\n                float: Second partial derivative w.r.t. eta\n\n    Notes:\n        - All coordinate inputs (xi, eta, zeta) should be in the reference element range\n        - All methods are abstract and must be implemented by derived classes\n        - Implementation should ensure proper handling of 3D tensor-product bases\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi, eta, zeta):\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The value of the basis function at (xi, eta, zeta).\n        \"\"\"\n\n    @abstractmethod\n    def gradx(self, xi, eta, zeta):\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n\n    @abstractmethod\n    def grady(self, xi, eta, zeta):\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n\n    @abstractmethod\n    def gradxx(self, xi, eta, zeta):\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n\n    @abstractmethod\n    def gradxy(self, xi, eta, zeta):\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n\n    @abstractmethod\n    def gradyy(self, xi, eta, zeta):\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradx","title":"<code>gradx(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi, eta, zeta):\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradxx","title":"<code>gradxx(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi, eta, zeta):\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradxy","title":"<code>gradxy(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi, eta, zeta):\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.grady","title":"<code>grady(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi, eta, zeta):\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.gradyy","title":"<code>gradyy(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi, eta, zeta):\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/basis_function_3d/#scirex.core.sciml.fe.basis_function_3d.BasisFunction3D.value","title":"<code>value(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The value of the basis function at (xi, eta, zeta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_3d.py</code> <pre><code>@abstractmethod\ndef value(self, xi, eta, zeta):\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: The value of the basis function at (xi, eta, zeta).\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/","title":"FE2D_Cell","text":"<p>Module: FE2D_Cell.py</p> <p>This module provides functionality for setting up and managing finite element  calculations for individual 2D cells, including basis functions, quadrature  rules, and transformations.</p> <p>Classes:</p> Name Description <code>FE2D_Cell</code> <p>Main class for managing cell-level FE computations</p> Dependencies <ul> <li>basis_function_2d: Base classes for 2D basis functions</li> <li>quadratureformulas_quad2d: Quadrature rules for 2D elements</li> <li>fe2d_setup_main: Setup utilities for 2D FE calculations</li> <li>numpy: Numerical computations</li> </ul> Key Features <ul> <li>Cell-level finite element value storage</li> <li>Basis function evaluation at quadrature points</li> <li>Reference to physical domain transformations</li> <li>Gradient and derivative computations</li> <li>Quadrature rule implementation</li> <li>Forcing function integration</li> <li>Support for different element types and orders</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> Notes <p>The implementation includes optimization for gradient calculations where grad_x_orig and grad_y_orig store multiplication factors for reference gradients to improve computational efficiency.</p>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D","title":"<code>BasisFunction2D</code>","text":"<p>An abstract base class defining the interface for two-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 2D basis functions (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines the required methods for function evaluation and derivatives.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Number of shape functions in the element. Typically a perfect square for tensor-product bases.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates basis functions at given reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of basis functions at (xi, eta)</p> <code>gradx</code> <p>Computes x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of x-derivatives at (xi, eta)</p> <code>grady</code> <p>Computes y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of y-derivatives at (xi, eta)</p> <code>gradxx</code> <p>Computes second x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second x-derivatives at (xi, eta)</p> <code>gradxy</code> <p>Computes mixed derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of mixed derivatives at (xi, eta)</p> <code>gradyy</code> <p>Computes second y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second y-derivatives at (xi, eta)</p> Notes <ul> <li>All coordinate inputs (xi, eta) should be in the reference element range</li> <li>Subclasses must implement all abstract methods</li> <li>Used as base class for specific polynomial implementations:<ul> <li>Legendre polynomials (normal and special variants)</li> <li>Jacobi polynomials</li> <li>Chebyshev polynomials</li> </ul> </li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>class BasisFunction2D:\n    \"\"\"\n    An abstract base class defining the interface for two-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 2D basis functions\n    (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines\n    the required methods for function evaluation and derivatives.\n\n    Attributes:\n        num_shape_functions (int): Number of shape functions in the element.\n            Typically a perfect square for tensor-product bases.\n\n    Methods:\n        value(xi, eta): Evaluates basis functions at given reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of basis functions at (xi, eta)\n\n        gradx(xi, eta): Computes x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of x-derivatives at (xi, eta)\n\n        grady(xi, eta): Computes y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of y-derivatives at (xi, eta)\n\n        gradxx(xi, eta): Computes second x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second x-derivatives at (xi, eta)\n\n        gradxy(xi, eta): Computes mixed derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of mixed derivatives at (xi, eta)\n\n        gradyy(xi, eta): Computes second y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second y-derivatives at (xi, eta)\n\n    Notes:\n        - All coordinate inputs (xi, eta) should be in the reference element range\n        - Subclasses must implement all abstract methods\n        - Used as base class for specific polynomial implementations:\n            - Legendre polynomials (normal and special variants)\n            - Jacobi polynomials\n            - Chebyshev polynomials\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (float): The xi coordinate.\n            eta (float): The eta coordinate.\n\n        Returns:\n            float: The value of the basis function at ( xi, eta).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradx","title":"<code>gradx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradxx","title":"<code>gradxx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradxy","title":"<code>gradxy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.grady","title":"<code>grady(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.gradyy","title":"<code>gradyy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.BasisFunction2D.value","title":"<code>value(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>float</code> <p>The xi coordinate.</p> required <code>eta</code> <code>float</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>The value of the basis function at ( xi, eta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (float): The xi coordinate.\n        eta (float): The eta coordinate.\n\n    Returns:\n        float: The value of the basis function at ( xi, eta).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain","title":"<code>FE2DSetupMain</code>","text":"<p>Main configuration class for 2D finite element analysis setup.</p> <p>This class handles the configuration and initialization of finite element analysis components, including basis functions, quadrature rules, and geometric transformations.</p> <p>Attributes:</p> Name Type Description <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the element</p> Example <p>setup = FE2DSetupMain( ...     cell_type='quadrilateral', ...     fe_order=2, ...     fe_type='legendre', ...     quad_order=3, ...     quad_type='gauss' ... ) basis = setup.assign_basis_function() weights, xi, eta = setup.assign_quadrature_rules()</p> Notes <ul> <li>Supports only quadrilateral elements currently</li> <li>Validates all input parameters for correctness</li> <li>Provides different polynomial basis options</li> <li>Handles both affine and bilinear transformations</li> <li>Quadrature order must be &gt;= 3 for accuracy</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>class FE2DSetupMain:\n    \"\"\"\n    Main configuration class for 2D finite element analysis setup.\n\n    This class handles the configuration and initialization of finite element\n    analysis components, including basis functions, quadrature rules, and\n    geometric transformations.\n\n    Attributes:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n        n_nodes (int): Number of nodes in the element\n\n    Example:\n        &gt;&gt;&gt; setup = FE2DSetupMain(\n        ...     cell_type='quadrilateral',\n        ...     fe_order=2,\n        ...     fe_type='legendre',\n        ...     quad_order=3,\n        ...     quad_type='gauss'\n        ... )\n        &gt;&gt;&gt; basis = setup.assign_basis_function()\n        &gt;&gt;&gt; weights, xi, eta = setup.assign_quadrature_rules()\n\n    Notes:\n        - Supports only quadrilateral elements currently\n        - Validates all input parameters for correctness\n        - Provides different polynomial basis options\n        - Handles both affine and bilinear transformations\n        - Quadrature order must be &gt;= 3 for accuracy\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n    ):\n        \"\"\"\n        Constructor for the FE2DSetupMain class.\n\n        Args:\n            cell_type (str): Type of finite element ('quadrilateral')\n            fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n            fe_type (str): Type of basis functions\n                ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n            quad_order (int): Order of quadrature rule (&gt;= 2)\n            quad_type (str): Type of quadrature formula\n\n        Raises:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.assign_basis_function()\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function based on the cell type and the fe_order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function object for the given configuration.\n\n        Raises:\n            ValueError: If the fe order is invalid or the cell type is invalid.\n        \"\"\"\n        # check for fe order lower bound and higher bound\n        if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n        if self.cell_type == \"quadrilateral\":\n            self.n_nodes = 4\n\n            # --- LEGENDRE --- #\n            if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n                # jacobi is added for backward compatibility with prev pushes\n                # generally, jacobi is referred to as Legendre basis on previous iterations\n                return Basis2DQNLegendre(self.fe_order**2)\n\n            elif self.fe_type == \"legendre_special\":\n                return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n            # ----- CHEBYSHEV ---- #\n            elif self.fe_type == \"chebyshev_2\":\n                return Basis2DQNChebyshev2(self.fe_order**2)\n\n            # ----- PLain jacobi ---- #\n            elif self.fe_type == \"jacobi_plain\":\n                return Basis2DQNJacobi(self.fe_order**2)\n\n            else:\n                print(\n                    f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\n                    'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n                )\n\n        print(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_quadrature_rules(self):\n        \"\"\"\n        Assigns the quadrature rule based on the quad_order.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n        Raises:\n            ValueError: If the quad_order is invalid\n            ValueError: If the cell type is invalid\n            ValueError: If the quad_order is not between 1 and 9999\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if self.quad_order &lt; 3:\n                raise ValueError(\"Quad order should be greater than 2.\")\n            elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n                weights, xi, eta = Quadratureformulas_Quad2D(\n                    self.quad_order, self.quad_type\n                ).get_quad_values()\n                return weights, xi, eta\n            else:\n                print(\n                    f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_fe_transformation(\n        self, fe_transformation_type: str, cell_coordinates: np.ndarray\n    ) -&gt; FETransforamtion2D:\n        \"\"\"\n        Assigns the fe transformation based on the cell type.\n\n        Args:\n            fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n            cell_coordinates (np.ndarray): The cell coordinates\n\n        Returns:\n            FETransforamtion2D: The fe transformation object for the given configuration.\n\n        Raises:\n            ValueError: If the cell type is invalid\n            ValueError: If the fe transformation type is invalid\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if fe_transformation_type == \"affine\":\n                return QuadAffin(cell_coordinates)\n            elif fe_transformation_type == \"bilinear\":\n                return QuadBilinear(cell_coordinates)\n            else:\n                raise ValueError(\n                    f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n                )\n\n        else:\n            raise ValueError(\n                f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.__init__","title":"<code>__init__(cell_type, fe_order, fe_type, quad_order, quad_type)</code>","text":"<p>Constructor for the FE2DSetupMain class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> required <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> required <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def __init__(\n    self,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n):\n    \"\"\"\n    Constructor for the FE2DSetupMain class.\n\n    Args:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n\n    Raises:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function based on the cell type and the fe_order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the fe order is invalid or the cell type is invalid.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function based on the cell type and the fe_order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function object for the given configuration.\n\n    Raises:\n        ValueError: If the fe order is invalid or the cell type is invalid.\n    \"\"\"\n    # check for fe order lower bound and higher bound\n    if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n        print(\n            f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n    if self.cell_type == \"quadrilateral\":\n        self.n_nodes = 4\n\n        # --- LEGENDRE --- #\n        if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n            # jacobi is added for backward compatibility with prev pushes\n            # generally, jacobi is referred to as Legendre basis on previous iterations\n            return Basis2DQNLegendre(self.fe_order**2)\n\n        elif self.fe_type == \"legendre_special\":\n            return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n        # ----- CHEBYSHEV ---- #\n        elif self.fe_type == \"chebyshev_2\":\n            return Basis2DQNChebyshev2(self.fe_order**2)\n\n        # ----- PLain jacobi ---- #\n        elif self.fe_type == \"jacobi_plain\":\n            return Basis2DQNJacobi(self.fe_order**2)\n\n        else:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n            )\n\n    print(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.assign_fe_transformation","title":"<code>assign_fe_transformation(fe_transformation_type, cell_coordinates)</code>","text":"<p>Assigns the fe transformation based on the cell type.</p> <p>Parameters:</p> Name Type Description Default <code>fe_transformation_type</code> <code>str</code> <p>Type of fe transformation ('affine', 'bilinear')</p> required <code>cell_coordinates</code> <code>ndarray</code> <p>The cell coordinates</p> required <p>Returns:</p> Name Type Description <code>FETransforamtion2D</code> <code>FETransforamtion2D</code> <p>The fe transformation object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the fe transformation type is invalid</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_fe_transformation(\n    self, fe_transformation_type: str, cell_coordinates: np.ndarray\n) -&gt; FETransforamtion2D:\n    \"\"\"\n    Assigns the fe transformation based on the cell type.\n\n    Args:\n        fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n        cell_coordinates (np.ndarray): The cell coordinates\n\n    Returns:\n        FETransforamtion2D: The fe transformation object for the given configuration.\n\n    Raises:\n        ValueError: If the cell type is invalid\n        ValueError: If the fe transformation type is invalid\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if fe_transformation_type == \"affine\":\n            return QuadAffin(cell_coordinates)\n        elif fe_transformation_type == \"bilinear\":\n            return QuadBilinear(cell_coordinates)\n        else:\n            raise ValueError(\n                f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n\n    else:\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2DSetupMain.assign_quadrature_rules","title":"<code>assign_quadrature_rules()</code>","text":"<p>Assigns the quadrature rule based on the quad_order.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quad_order is invalid</p> <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the quad_order is not between 1 and 9999</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_quadrature_rules(self):\n    \"\"\"\n    Assigns the quadrature rule based on the quad_order.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n    Raises:\n        ValueError: If the quad_order is invalid\n        ValueError: If the cell type is invalid\n        ValueError: If the quad_order is not between 1 and 9999\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if self.quad_order &lt; 3:\n            raise ValueError(\"Quad order should be greater than 2.\")\n        elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n            weights, xi, eta = Quadratureformulas_Quad2D(\n                self.quad_order, self.quad_type\n            ).get_quad_values()\n            return weights, xi, eta\n        else:\n            print(\n                f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n    raise ValueError(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell","title":"<code>FE2D_Cell</code>","text":"<p>A class for managing finite element computations at the cell level.</p> <p>This class handles the storage and computation of finite element values, including basis functions, quadrature rules, and transformations for a single cell in a 2D mesh.</p> <p>Attributes:</p> Name Type Description <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation</code> <code>str</code> <p>Type of geometric transformation</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>basis_function</code> <code>BasisFunction2D</code> <p>Basis function implementation</p> <code>quad_xi</code> <code>ndarray</code> <p>Xi coordinates of quadrature points</p> <code>quad_eta</code> <code>ndarray</code> <p>Eta coordinates of quadrature points</p> <code>quad_weight</code> <code>ndarray</code> <p>Quadrature weights</p> <code>jacobian</code> <code>ndarray</code> <p>Transformation Jacobian</p> <code>basis_at_quad</code> <code>ndarray</code> <p>Basis values at quadrature points</p> <code>basis_gradx_at_quad</code> <code>ndarray</code> <p>X-derivatives at quadrature points</p> <code>basis_grady_at_quad</code> <code>ndarray</code> <p>Y-derivatives at quadrature points</p> <code>quad_actual_coordinates</code> <code>ndarray</code> <p>Physical quadrature point coordinates</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) cell = FE2D_Cell( ...     cell_coordinates=coords, ...     cell_type='quad', ...     fe_order=2, ...     fe_type='lagrange', ...     quad_order=3, ...     quad_type='gauss', ...     fe_transformation_type='bilinear', ...     forcing_function=lambda x, y: x*y ... ) cell.basis_at_quad  # Get basis values at quadrature points</p> Notes <ul> <li>All gradient and derivative values are stored in the reference domain</li> <li>Jacobian and quadrature weights are combined for efficiency</li> <li>Forcing function values are typically computed in the fespace class</li> <li>Supports multiple types of transformations and element types</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>class FE2D_Cell:\n    \"\"\"\n    A class for managing finite element computations at the cell level.\n\n    This class handles the storage and computation of finite element values,\n    including basis functions, quadrature rules, and transformations for a\n    single cell in a 2D mesh.\n\n    Attributes:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n        basis_function (BasisFunction2D): Basis function implementation\n        quad_xi (np.ndarray): Xi coordinates of quadrature points\n        quad_eta (np.ndarray): Eta coordinates of quadrature points\n        quad_weight (np.ndarray): Quadrature weights\n        jacobian (np.ndarray): Transformation Jacobian\n        basis_at_quad (np.ndarray): Basis values at quadrature points\n        basis_gradx_at_quad (np.ndarray): X-derivatives at quadrature points\n        basis_grady_at_quad (np.ndarray): Y-derivatives at quadrature points\n        quad_actual_coordinates (np.ndarray): Physical quadrature point coordinates\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; cell = FE2D_Cell(\n        ...     cell_coordinates=coords,\n        ...     cell_type='quad',\n        ...     fe_order=2,\n        ...     fe_type='lagrange',\n        ...     quad_order=3,\n        ...     quad_type='gauss',\n        ...     fe_transformation_type='bilinear',\n        ...     forcing_function=lambda x, y: x*y\n        ... )\n        &gt;&gt;&gt; cell.basis_at_quad  # Get basis values at quadrature points\n\n    Notes:\n        - All gradient and derivative values are stored in the reference domain\n        - Jacobian and quadrature weights are combined for efficiency\n        - Forcing function values are typically computed in the fespace class\n        - Supports multiple types of transformations and element types\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_coordinates: np.ndarray,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        forcing_function,\n    ):\n        \"\"\"\n        Constructor for the FE2D_Cell class.\n\n        Args:\n            cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n            cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n            fe_order (int): Order of the finite element approximation\n            fe_type (str): Type of finite element basis\n            quad_order (int): Order of quadrature rule\n            quad_type (str): Type of quadrature formula\n            fe_transformation_type (str): Type of geometric transformation\n            forcing_function (callable): Source term function\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_coordinates = cell_coordinates\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.fe_transformation = fe_transformation_type\n        self.forcing_function = forcing_function\n\n        # Basis function Class\n        self.basis_function = None\n\n        # Quadrature Values\n        self.quad_xi = None\n        self.quad_eta = None\n        self.quad_weight = None\n        self.jacobian = None\n        self.mult = None\n\n        # FE Values\n        self.basis_at_quad = None\n        self.basis_gradx_at_quad = None\n        self.basis_grady_at_quad = None\n        self.basis_gradxy_at_quad = None\n        self.basis_gradxx_at_quad = None\n        self.basis_gradyy_at_quad = None\n\n        # Quadrature Coordinates\n        self.quad_actual_coordinates = None\n\n        # Forcing function values at the quadrature points\n        self.forcing_at_quad = None\n\n        # FE Transformation Class\n        self.fetransformation = None\n\n        # get instance of the FE_setup class\n        self.fe_setup = FE2DSetupMain(\n            cell_type=self.cell_type,\n            fe_order=self.fe_order,\n            fe_type=self.fe_type,\n            quad_order=self.quad_order,\n            quad_type=self.quad_type,\n        )\n\n        # Call the function to assign the basis function\n        self.assign_basis_function()\n\n        # Assign the quadrature points and weights\n        self.assign_quadrature()\n\n        # Assign the FE Transformation\n        self.assign_fe_transformation()\n\n        # calculate mult -&gt; quadrature weights * Jacobian\n        self.assign_quad_weights_and_jacobian()\n\n        # Calculate the basis function values at the quadrature points\n        self.assign_basis_values_at_quadrature_points()\n\n        # calculate the actual coordinates of the quadrature points\n        self.assign_quadrature_coordinates()\n\n        # Calculate the forcing function values at the actual quadrature points\n        # NOTE : The function is just for printing the shape of the force matrix, the\n        # actual calculation is performed on the fespace class\n        self.assign_forcing_term(self.forcing_function)\n\n        # # print the values\n        # print(\"============================================================================\")\n        # print(\"Cell Co-ord : \", self.cell_coordinates)\n        # print(\"Basis function values at the quadrature points: \\n\", self.basis_at_quad / self.mult)\n        # print(\"Basis function gradx at the quadrature points: \\n\", self.basis_gradx_at_quad)\n        # print(\"Basis function grady at the quadrature points: \\n\", self.basis_grady_at_quad)\n        # print(\"Forcing function values at the quadrature points: \\n\", self.forcing_at_quad)\n\n        # grad_x = np.array([5,6,7,8])\n        # grad_y = np.array([1,2,3,4])\n\n        # pde = np.matmul(self.basis_gradx_at_quad, grad_x.reshape(-1,1)) + np.matmul(self.basis_grady_at_quad, grad_y.reshape(-1,1))\n        # print(\"PDE values at the quadrature points: \\n\", pde)\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function class based on the cell type and the FE order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function class for the given cell type and FE order.\n        \"\"\"\n        self.basis_function = self.fe_setup.assign_basis_function()\n\n    def assign_quadrature(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_weight, self.quad_xi, self.quad_eta = (\n            self.fe_setup.assign_quadrature_rules()\n        )\n\n    def assign_fe_transformation(self) -&gt; None:\n        \"\"\"\n        Assigns the FE Transformation class based on the cell type and the FE order.\n\n        This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n        It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.fetransformation = self.fe_setup.assign_fe_transformation(\n            self.fe_transformation, self.cell_coordinates\n        )\n        # Sets cell co-ordinates for the FE Transformation\n        self.fetransformation.set_cell()\n\n        # obtains the Jacobian of the transformation\n        self.jacobian = self.fetransformation.get_jacobian(\n            self.quad_xi, self.quad_eta\n        ).reshape(-1, 1)\n\n    def assign_basis_values_at_quadrature_points(self) -&gt; None:\n        \"\"\"\n        Assigns the basis function values at the quadrature points.\n\n        This method calculates the values of the basis functions and their gradients at the quadrature points.\n        The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n        `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n        `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.basis_at_quad = []\n        self.basis_gradx_at_quad = []\n        self.basis_grady_at_quad = []\n        self.basis_gradxy_at_quad = []\n        self.basis_gradxx_at_quad = []\n        self.basis_gradyy_at_quad = []\n\n        self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n        # For Gradients we need to perform a transformation to the original cell\n        grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n        grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n        grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n            grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n        )\n\n        self.basis_gradx_at_quad = grad_x_orig\n        self.basis_grady_at_quad = grad_y_orig\n\n        self.basis_gradx_at_quad_ref = grad_x_ref\n        self.basis_grady_at_quad_ref = grad_y_ref\n\n        # get the double derivatives of the basis functions ( ref co-ordinates )\n        grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n        grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n        grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n        # get the double derivatives of the basis functions ( orig co-ordinates )\n        grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n            self.fetransformation.get_orig_from_ref_second_derivative(\n                grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n            )\n        )\n\n        # = the value\n        self.basis_gradxy_at_quad = grad_xy_orig\n        self.basis_gradxx_at_quad = grad_xx_orig\n        self.basis_gradyy_at_quad = grad_yy_orig\n\n        # Multiply each row with the quadrature weights\n        # Basis at Quad - n_test * N_quad\n        self.basis_at_quad = self.basis_at_quad * self.mult\n        self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n        self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n        self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n        self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n        self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n\n    def assign_quad_weights_and_jacobian(self) -&gt; None:\n        \"\"\"\n        Assigns the quadrature weights and the Jacobian of the transformation.\n\n        This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n        for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n        and stored in the `mult` attribute of the class.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.mult = self.quad_weight * self.jacobian.flatten()\n\n    def assign_quadrature_coordinates(self) -&gt; None:\n        \"\"\"\n        Assigns the actual coordinates of the quadrature points.\n\n        This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n        The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n        The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        actual_co_ord = []\n        for xi, eta in zip(self.quad_xi, self.quad_eta):\n            actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n        self.quad_actual_coordinates = np.array(actual_co_ord)\n\n    def assign_forcing_term(self, forcing_function) -&gt; None:\n        \"\"\"\n        Assigns the forcing function values at the quadrature points.\n\n        This function computes the values of the forcing function at the quadrature points\n        and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n        Args:\n            forcing_function (callable): The forcing function to be integrated\n\n        Returns:\n            None\n\n        Notes:\n            - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n            - This function is for backward compatibility with old code and currently assigns\n              the values as zeros. The actual calculation is performed in the fespace class.\n        \"\"\"\n        # get number of shape functions\n        n_shape_functions = self.basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n        # the actual calculation is performed in the fespace class\n\n        # for i in range(n_shape_functions):\n        #     val = 0\n        #     for q in range(self.basis_at_quad.shape[1]):\n        #         x = self.quad_actual_coordinates[q, 0]\n        #         y = self.quad_actual_coordinates[q, 1]\n        #         # print(\"f_values[q] = \",f_values[q])\n\n        #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n        #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n        #         # print(\"val = \", val)\n\n        #     f_integral[i] = val\n\n        self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.__init__","title":"<code>__init__(cell_coordinates, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, forcing_function)</code>","text":"<p>Constructor for the FE2D_Cell class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_coordinates</code> <code>ndarray</code> <p>Physical coordinates of the cell vertices</p> required <code>cell_type</code> <code>str</code> <p>Type of the cell (e.g., 'quad', 'triangle')</p> required <code>fe_order</code> <code>int</code> <p>Order of the finite element approximation</p> required <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> required <code>forcing_function</code> <code>callable</code> <p>Source term function</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def __init__(\n    self,\n    cell_coordinates: np.ndarray,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    forcing_function,\n):\n    \"\"\"\n    Constructor for the FE2D_Cell class.\n\n    Args:\n        cell_coordinates (np.ndarray): Physical coordinates of the cell vertices\n        cell_type (str): Type of the cell (e.g., 'quad', 'triangle')\n        fe_order (int): Order of the finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        forcing_function (callable): Source term function\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_coordinates = cell_coordinates\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.fe_transformation = fe_transformation_type\n    self.forcing_function = forcing_function\n\n    # Basis function Class\n    self.basis_function = None\n\n    # Quadrature Values\n    self.quad_xi = None\n    self.quad_eta = None\n    self.quad_weight = None\n    self.jacobian = None\n    self.mult = None\n\n    # FE Values\n    self.basis_at_quad = None\n    self.basis_gradx_at_quad = None\n    self.basis_grady_at_quad = None\n    self.basis_gradxy_at_quad = None\n    self.basis_gradxx_at_quad = None\n    self.basis_gradyy_at_quad = None\n\n    # Quadrature Coordinates\n    self.quad_actual_coordinates = None\n\n    # Forcing function values at the quadrature points\n    self.forcing_at_quad = None\n\n    # FE Transformation Class\n    self.fetransformation = None\n\n    # get instance of the FE_setup class\n    self.fe_setup = FE2DSetupMain(\n        cell_type=self.cell_type,\n        fe_order=self.fe_order,\n        fe_type=self.fe_type,\n        quad_order=self.quad_order,\n        quad_type=self.quad_type,\n    )\n\n    # Call the function to assign the basis function\n    self.assign_basis_function()\n\n    # Assign the quadrature points and weights\n    self.assign_quadrature()\n\n    # Assign the FE Transformation\n    self.assign_fe_transformation()\n\n    # calculate mult -&gt; quadrature weights * Jacobian\n    self.assign_quad_weights_and_jacobian()\n\n    # Calculate the basis function values at the quadrature points\n    self.assign_basis_values_at_quadrature_points()\n\n    # calculate the actual coordinates of the quadrature points\n    self.assign_quadrature_coordinates()\n\n    # Calculate the forcing function values at the actual quadrature points\n    # NOTE : The function is just for printing the shape of the force matrix, the\n    # actual calculation is performed on the fespace class\n    self.assign_forcing_term(self.forcing_function)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function class based on the cell type and the FE order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function class for the given cell type and FE order.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function class based on the cell type and the FE order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function class for the given cell type and FE order.\n    \"\"\"\n    self.basis_function = self.fe_setup.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_basis_values_at_quadrature_points","title":"<code>assign_basis_values_at_quadrature_points()</code>","text":"<p>Assigns the basis function values at the quadrature points.</p> <p>This method calculates the values of the basis functions and their gradients at the quadrature points. The basis function values are stored in <code>self.basis_at_quad</code>, while the gradients are stored in <code>self.basis_gradx_at_quad</code>, <code>self.basis_grady_at_quad</code>, <code>self.basis_gradxy_at_quad</code>, <code>self.basis_gradxx_at_quad</code>, and <code>self.basis_gradyy_at_quad</code>.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_basis_values_at_quadrature_points(self) -&gt; None:\n    \"\"\"\n    Assigns the basis function values at the quadrature points.\n\n    This method calculates the values of the basis functions and their gradients at the quadrature points.\n    The basis function values are stored in `self.basis_at_quad`, while the gradients are stored in\n    `self.basis_gradx_at_quad`, `self.basis_grady_at_quad`, `self.basis_gradxy_at_quad`,\n    `self.basis_gradxx_at_quad`, and `self.basis_gradyy_at_quad`.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.basis_at_quad = []\n    self.basis_gradx_at_quad = []\n    self.basis_grady_at_quad = []\n    self.basis_gradxy_at_quad = []\n    self.basis_gradxx_at_quad = []\n    self.basis_gradyy_at_quad = []\n\n    self.basis_at_quad = self.basis_function.value(self.quad_xi, self.quad_eta)\n\n    # For Gradients we need to perform a transformation to the original cell\n    grad_x_ref = self.basis_function.gradx(self.quad_xi, self.quad_eta)\n    grad_y_ref = self.basis_function.grady(self.quad_xi, self.quad_eta)\n\n    grad_x_orig, grad_y_orig = self.fetransformation.get_orig_from_ref_derivative(\n        grad_x_ref, grad_y_ref, self.quad_xi, self.quad_eta\n    )\n\n    self.basis_gradx_at_quad = grad_x_orig\n    self.basis_grady_at_quad = grad_y_orig\n\n    self.basis_gradx_at_quad_ref = grad_x_ref\n    self.basis_grady_at_quad_ref = grad_y_ref\n\n    # get the double derivatives of the basis functions ( ref co-ordinates )\n    grad_xx_ref = self.basis_function.gradxx(self.quad_xi, self.quad_eta)\n    grad_xy_ref = self.basis_function.gradxy(self.quad_xi, self.quad_eta)\n    grad_yy_ref = self.basis_function.gradyy(self.quad_xi, self.quad_eta)\n\n    # get the double derivatives of the basis functions ( orig co-ordinates )\n    grad_xx_orig, grad_xy_orig, grad_yy_orig = (\n        self.fetransformation.get_orig_from_ref_second_derivative(\n            grad_xx_ref, grad_xy_ref, grad_yy_ref, self.quad_xi, self.quad_eta\n        )\n    )\n\n    # = the value\n    self.basis_gradxy_at_quad = grad_xy_orig\n    self.basis_gradxx_at_quad = grad_xx_orig\n    self.basis_gradyy_at_quad = grad_yy_orig\n\n    # Multiply each row with the quadrature weights\n    # Basis at Quad - n_test * N_quad\n    self.basis_at_quad = self.basis_at_quad * self.mult\n    self.basis_gradx_at_quad = self.basis_gradx_at_quad * self.mult\n    self.basis_grady_at_quad = self.basis_grady_at_quad * self.mult\n    self.basis_gradxy_at_quad = self.basis_gradxy_at_quad * self.mult\n    self.basis_gradxx_at_quad = self.basis_gradxx_at_quad * self.mult\n    self.basis_gradyy_at_quad = self.basis_gradyy_at_quad * self.mult\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_fe_transformation","title":"<code>assign_fe_transformation()</code>","text":"<p>Assigns the FE Transformation class based on the cell type and the FE order.</p> <p>This method assigns the appropriate FE Transformation class based on the cell type and the FE order. It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_fe_transformation(self) -&gt; None:\n    \"\"\"\n    Assigns the FE Transformation class based on the cell type and the FE order.\n\n    This method assigns the appropriate FE Transformation class based on the cell type and the FE order.\n    It sets the cell coordinates for the FE Transformation and obtains the Jacobian of the transformation.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.fetransformation = self.fe_setup.assign_fe_transformation(\n        self.fe_transformation, self.cell_coordinates\n    )\n    # Sets cell co-ordinates for the FE Transformation\n    self.fetransformation.set_cell()\n\n    # obtains the Jacobian of the transformation\n    self.jacobian = self.fetransformation.get_jacobian(\n        self.quad_xi, self.quad_eta\n    ).reshape(-1, 1)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_forcing_term","title":"<code>assign_forcing_term(forcing_function)</code>","text":"<p>Assigns the forcing function values at the quadrature points.</p> <p>This function computes the values of the forcing function at the quadrature points and assigns them to the <code>forcing_at_quad</code> attribute of the FE2D_Cell object.</p> <p>Parameters:</p> Name Type Description Default <code>forcing_function</code> <code>callable</code> <p>The forcing function to be integrated</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Notes <ul> <li>The final shape of <code>forcing_at_quad</code> will be N_shape_functions x 1.</li> <li>This function is for backward compatibility with old code and currently assigns   the values as zeros. The actual calculation is performed in the fespace class.</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_forcing_term(self, forcing_function) -&gt; None:\n    \"\"\"\n    Assigns the forcing function values at the quadrature points.\n\n    This function computes the values of the forcing function at the quadrature points\n    and assigns them to the `forcing_at_quad` attribute of the FE2D_Cell object.\n\n    Args:\n        forcing_function (callable): The forcing function to be integrated\n\n    Returns:\n        None\n\n    Notes:\n        - The final shape of `forcing_at_quad` will be N_shape_functions x 1.\n        - This function is for backward compatibility with old code and currently assigns\n          the values as zeros. The actual calculation is performed in the fespace class.\n    \"\"\"\n    # get number of shape functions\n    n_shape_functions = self.basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    # The above code is for backward compatibility with old code. this function will just assign the values as zeros\n    # the actual calculation is performed in the fespace class\n\n    # for i in range(n_shape_functions):\n    #     val = 0\n    #     for q in range(self.basis_at_quad.shape[1]):\n    #         x = self.quad_actual_coordinates[q, 0]\n    #         y = self.quad_actual_coordinates[q, 1]\n    #         # print(\"f_values[q] = \",f_values[q])\n\n    #         # the JAcobian and the quadrature weights are pre multiplied to the basis functions\n    #         val +=  ( self.basis_at_quad[i, q] ) * self.forcing_function(x, y)\n    #         # print(\"val = \", val)\n\n    #     f_integral[i] = val\n\n    self.forcing_at_quad = f_integral\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_quad_weights_and_jacobian","title":"<code>assign_quad_weights_and_jacobian()</code>","text":"<p>Assigns the quadrature weights and the Jacobian of the transformation.</p> <p>This method calculates and assigns the quadrature weights and the Jacobian of the transformation for the current cell. The quadrature weights are multiplied by the flattened Jacobian array and stored in the <code>mult</code> attribute of the class.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quad_weights_and_jacobian(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature weights and the Jacobian of the transformation.\n\n    This method calculates and assigns the quadrature weights and the Jacobian of the transformation\n    for the current cell. The quadrature weights are multiplied by the flattened Jacobian array\n    and stored in the `mult` attribute of the class.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.mult = self.quad_weight * self.jacobian.flatten()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_quadrature","title":"<code>assign_quadrature()</code>","text":"<p>Assigns the quadrature points and weights based on the cell type and the quadrature order.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature(self) -&gt; None:\n    \"\"\"\n    Assigns the quadrature points and weights based on the cell type and the quadrature order.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_weight, self.quad_xi, self.quad_eta = (\n        self.fe_setup.assign_quadrature_rules()\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FE2D_Cell.assign_quadrature_coordinates","title":"<code>assign_quadrature_coordinates()</code>","text":"<p>Assigns the actual coordinates of the quadrature points.</p> <p>This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values. The Xi and Eta values are obtained from the <code>quad_xi</code> and <code>quad_eta</code> attributes of the class. The calculated coordinates are stored in the <code>quad_actual_coordinates</code> attribute as a NumPy array.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_cell.py</code> <pre><code>def assign_quadrature_coordinates(self) -&gt; None:\n    \"\"\"\n    Assigns the actual coordinates of the quadrature points.\n\n    This method calculates the actual coordinates of the quadrature points based on the given Xi and Eta values.\n    The Xi and Eta values are obtained from the `quad_xi` and `quad_eta` attributes of the class.\n    The calculated coordinates are stored in the `quad_actual_coordinates` attribute as a NumPy array.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    actual_co_ord = []\n    for xi, eta in zip(self.quad_xi, self.quad_eta):\n        actual_co_ord.append(self.fetransformation.get_original_from_ref(xi, eta))\n\n    self.quad_actual_coordinates = np.array(actual_co_ord)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D","title":"<code>FETransforamtion2D</code>","text":"<p>A base class for 2D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 2D finite element analysis. Implementations must provide specific transformation rules for different element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes.</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes.</p> Example <p>class QuadTransform(FETransformation2D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>class FETransforamtion2D:\n    \"\"\"\n    A base class for 2D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 2D finite element analysis. Implementations must provide specific\n    transformation rules for different element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n\n        get_jacobian(xi, eta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n\n    Example:\n        &gt;&gt;&gt; class QuadTransform(FETransformation2D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n        ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransforamtion2D class.\n        \"\"\"\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        :return: None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransforamtion2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransforamtion2D class.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.FETransforamtion2D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas","title":"<code>Quadratureformulas</code>","text":"<p>Abstract base class for numerical quadrature formulas.</p> <p>This class defines the interface that all quadrature implementations must follow. It provides the basic structure for implementing various quadrature rules while ensuring consistent access to quadrature data.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of the quadrature rule</p> <code>quad_type</code> <p>Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points</p> Example <p>class MyQuadrature(Quadratureformulas): ...     def init(self): ...         super().init(quad_order=3, ...                         quad_type='custom', ...                         num_quad_points=9) ...     def get_quad_values(self): ...         # Implementation ...         pass ...     def get_num_quad_points(self): ...         return self.num_quad_points</p> Note <p>This is an abstract base class. Concrete implementations must override: - get_quad_values() - get_num_quad_points()</p> <p>The implementation should ensure proper initialization of: - Quadrature points - Quadrature weights - Number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>class Quadratureformulas:\n    \"\"\"Abstract base class for numerical quadrature formulas.\n\n    This class defines the interface that all quadrature implementations must\n    follow. It provides the basic structure for implementing various quadrature\n    rules while ensuring consistent access to quadrature data.\n\n    Attributes:\n        quad_order: Order of the quadrature rule\n        quad_type: Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Example:\n        &gt;&gt;&gt; class MyQuadrature(Quadratureformulas):\n        ...     def __init__(self):\n        ...         super().__init__(quad_order=3,\n        ...                         quad_type='custom',\n        ...                         num_quad_points=9)\n        ...     def get_quad_values(self):\n        ...         # Implementation\n        ...         pass\n        ...     def get_num_quad_points(self):\n        ...         return self.num_quad_points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - get_quad_values()\n        - get_num_quad_points()\n\n        The implementation should ensure proper initialization of:\n        - Quadrature points\n        - Quadrature weights\n        - Number of quadrature points\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n            num_quad_points: Total number of quadrature points\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.num_quad_points = num_quad_points\n\n    @abstractmethod\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            weights: Weights for each quadrature point\n            xi: x-coordinates of quadrature points in reference element\n            eta: y-coordinates of quadrature points in reference element\n        \"\"\"\n\n    @abstractmethod\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            num_quad_points: Total number of quadrature points\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas.__init__","title":"<code>__init__(quad_order, quad_type, num_quad_points)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <code>num_quad_points</code> <code>int</code> <p>Total number of quadrature points</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.num_quad_points = num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas.get_num_quad_points","title":"<code>get_num_quad_points()</code>  <code>abstractmethod</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>num_quad_points</code> <p>Total number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        num_quad_points: Total number of quadrature points\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas.get_quad_values","title":"<code>get_quad_values()</code>  <code>abstractmethod</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>weights</code> <p>Weights for each quadrature point</p> <code>xi</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta</code> <p>y-coordinates of quadrature points in reference element</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        weights: Weights for each quadrature point\n        xi: x-coordinates of quadrature points in reference element\n        eta: y-coordinates of quadrature points in reference element\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D","title":"<code>Quadratureformulas_Quad2D</code>","text":"<p>               Bases: <code>Quadratureformulas</code></p> <p>Implements quadrature formulas for 2D quadrilateral elements.</p> <p>This class provides methods to compute quadrature points and weights for 2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi quadrature schemes. The implementation uses tensor products of 1D rules.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of quadrature rule</p> <code>quad_type</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points (quad_order^2)</p> <code>xi_quad</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta_quad</code> <p>y-coordinates of quadrature points in reference element</p> <code>quad_weights</code> <p>Weights for each quadrature point</p> Example <p>quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre') weights, xi, eta = quad.get_quad_values() n_points = quad.get_num_quad_points()</p> Note <ul> <li>Gauss-Legendre points are optimal for polynomial integrands</li> <li>Gauss-Jacobi points include element vertices (useful for certain FEM applications)</li> <li>All computations are performed in the reference element [-1,1]\u00d7[-1,1]</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>class Quadratureformulas_Quad2D(Quadratureformulas):\n    \"\"\"Implements quadrature formulas for 2D quadrilateral elements.\n\n    This class provides methods to compute quadrature points and weights for\n    2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi\n    quadrature schemes. The implementation uses tensor products of 1D rules.\n\n    Attributes:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points (quad_order^2)\n        xi_quad: x-coordinates of quadrature points in reference element\n        eta_quad: y-coordinates of quadrature points in reference element\n        quad_weights: Weights for each quadrature point\n\n    Example:\n        &gt;&gt;&gt; quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre')\n        &gt;&gt;&gt; weights, xi, eta = quad.get_quad_values()\n        &gt;&gt;&gt; n_points = quad.get_num_quad_points()\n\n    Note:\n        - Gauss-Legendre points are optimal for polynomial integrands\n        - Gauss-Jacobi points include element vertices (useful for certain FEM applications)\n        - All computations are performed in the reference element [-1,1]\u00d7[-1,1]\n\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the quadrature type is not supported.\n        \"\"\"\n        # initialize the super class\n        super().__init__(\n            quad_order=quad_order,\n            quad_type=quad_type,\n            num_quad_points=quad_order * quad_order,\n        )\n\n        # Calculate the Gauss-Legendre quadrature points and weights for 1D\n        # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n        quad_type = self.quad_type\n\n        if quad_type == \"gauss-legendre\":\n            # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n            # if quad_order == 2:\n            #     nodes_1d = np.array([-1, 1])\n            #     weights_1d = np.array([1, 1])\n            # else:\n            nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n                quad_order\n            )  # Interior points\n            # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n            # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        elif quad_type == \"gauss-jacobi\":\n\n            def GaussJacobiWeights(Q: int, a, b):\n                [X, W] = roots_jacobi(Q, a, b)\n                return [X, W]\n\n            def jacobi_wrapper(n, a, b, x):\n\n                x = np.array(x, dtype=np.float64)\n\n                return jacobi(n, a, b)(x)\n\n            # Weight coefficients\n            def GaussLobattoJacobiWeights(Q: int, a, b):\n                W = []\n                X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n                if a == 0 and b == 0:\n                    W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                    Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                    Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n                else:\n                    W = (\n                        2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                        )\n                    )\n                    Wl = (\n                        (b + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                        )\n                    )\n                    Wr = (\n                        (a + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                        )\n                    )\n                W = np.append(W, Wr)\n                W = np.append(Wl, W)\n                X = np.append(X, 1)\n                X = np.append(-1, X)\n                return [X, W]\n\n            # get quadrature points and weights in 1D\n            x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(x, x)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (w[:, np.newaxis] * w).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        else:\n            print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n            print(\n                f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quadrature type not supported.\")\n\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format\n        \"\"\"\n        return self.quad_weights, self.xi_quad, self.eta_quad\n\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            int: The number of quadrature points\n        \"\"\"\n        return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D.__init__","title":"<code>__init__(quad_order, quad_type)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quadrature type is not supported.</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the quadrature type is not supported.\n    \"\"\"\n    # initialize the super class\n    super().__init__(\n        quad_order=quad_order,\n        quad_type=quad_type,\n        num_quad_points=quad_order * quad_order,\n    )\n\n    # Calculate the Gauss-Legendre quadrature points and weights for 1D\n    # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n    quad_type = self.quad_type\n\n    if quad_type == \"gauss-legendre\":\n        # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n        # if quad_order == 2:\n        #     nodes_1d = np.array([-1, 1])\n        #     weights_1d = np.array([1, 1])\n        # else:\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n            quad_order\n        )  # Interior points\n        # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n        # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    elif quad_type == \"gauss-jacobi\":\n\n        def GaussJacobiWeights(Q: int, a, b):\n            [X, W] = roots_jacobi(Q, a, b)\n            return [X, W]\n\n        def jacobi_wrapper(n, a, b, x):\n\n            x = np.array(x, dtype=np.float64)\n\n            return jacobi(n, a, b)(x)\n\n        # Weight coefficients\n        def GaussLobattoJacobiWeights(Q: int, a, b):\n            W = []\n            X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n            if a == 0 and b == 0:\n                W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n            else:\n                W = (\n                    2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                    )\n                )\n                Wl = (\n                    (b + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                    )\n                )\n                Wr = (\n                    (a + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                    )\n                )\n            W = np.append(W, Wr)\n            W = np.append(Wl, W)\n            X = np.append(X, 1)\n            X = np.append(-1, X)\n            return [X, W]\n\n        # get quadrature points and weights in 1D\n        x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(x, x)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (w[:, np.newaxis] * w).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    else:\n        print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n        print(\n            f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Quadrature type not supported.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D.get_num_quad_points","title":"<code>get_num_quad_points()</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of quadrature points\n    \"\"\"\n    return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_cell/#scirex.core.sciml.fe.fe2d_cell.Quadratureformulas_Quad2D.get_quad_values","title":"<code>get_quad_values()</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format\n    \"\"\"\n    return self.quad_weights, self.xi_quad, self.eta_quad\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/","title":"fe2d_setup_main","text":"<p>Module: fe2d_setup_main.py</p> <p>This module provides the main setup and configuration functionality for 2D  finite element analysis, handling basis function assignment, quadrature rules,  and transformations.</p> <p>Classes:</p> Name Description <code>FE2DSetupMain</code> <p>Core class for configuring FE2D computations</p> Dependencies <ul> <li>basis_function_2d: Base classes for 2D basis functions</li> <li>quadratureformulas_quad2d: Quadrature rule implementations</li> <li>fe_transformation_2d: Geometric transformation handlers</li> </ul> Key Features <ul> <li>Flexible basis function selection</li> <li>Multiple polynomial basis options<ul> <li>Legendre polynomials</li> <li>Special Legendre polynomials</li> <li>Chebyshev polynomials</li> <li>Jacobi polynomials</li> </ul> </li> <li>Configurable quadrature rules</li> <li>Support for different element transformations</li> <li>Automatic validation of parameters</li> <li>Element type specific handling</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> Notes <p>Currently supports quadrilateral elements with various polynomial  basis options and transformation types. The implementation focuses  on flexibility and extensibility for different element types.</p>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2","title":"<code>Basis2DQNChebyshev2</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials through Jacobi polynomial representations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives. The implementation follows the methodology described in hp-VPINNs research by Ehsan Kharazmi et al.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>value</code> <p>Computes values of all basis functions at given points</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from normalized Jacobi polynomials</li> <li>Special cases are handled for first few polynomial degrees in derivatives</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Notes <ul> <li>num_shape_functions must be a perfect square</li> <li>All coordinate inputs (xi, eta) should be in the range [-1, 1]</li> <li>Implementation optimized for vectorized operations on multiple points</li> <li>Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/</li> </ul> References <p>Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks With Domain Decomposition\"</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>class Basis2DQNChebyshev2(BasisFunction2D):\n    \"\"\"A specialized implementation of two-dimensional basis functions using Chebyshev polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Chebyshev polynomials\n    through Jacobi polynomial representations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives. The implementation follows the methodology described in\n    hp-VPINNs research by Ehsan Kharazmi et al.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        value(xi, eta): Computes values of all basis functions at given points\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from normalized Jacobi polynomials\n        - Special cases are handled for first few polynomial degrees in derivatives\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNChebyshev2(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n\n    Notes:\n        - num_shape_functions must be a perfect square\n        - All coordinate inputs (xi, eta) should be in the range [-1, 1]\n        - Implementation optimized for vectorized operations on multiple points\n        - Based on hp-VPINNs methodology: https://github.com/ehsankharazmi/hp-VPINNs/\n\n    References:\n        Kharazmi, E., et al. \"hp-VPINNs: Variational Physics-Informed Neural Networks\n        With Domain Decomposition\"\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates Jacobi polynomial at specified points.\n\n        Computes values of nth degree Jacobi polynomial with parameters (a,b)\n        at given points x.\n\n        Args:\n            n: Degree of Jacobi polynomial. Must be non-negative integer.\n            a: First parameter of Jacobi polynomial\n            b: Second parameter of Jacobi polynomial\n            x: Points at which to evaluate polynomial\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of Jacobi polynomial at input points\n                Shape: Same as input x\n\n        Notes:\n            Wrapper around scipy.special.jacobi that ensures float64 precision\n            and proper array handling.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-component test functions.\n\n        Evaluates the x-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            x: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-component test functions.\n\n        Evaluates the y-direction test functions constructed as differences\n        of normalized Jacobi polynomials.\n\n        Args:\n            n_test: Number of test functions to compute\n            y: Points at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of test functions at input points\n                Shape: (n_test, n_points)\n\n        Notes:\n            Test functions are constructed as differences of normalized Jacobi\n            polynomials following hp-VPINNs methodology.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n + 1, -1 / 2, -1 / 2, 1\n            ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes first and second derivatives of test functions.\n\n        Calculates derivatives of test functions constructed from Jacobi\n        polynomials, handling special cases for n=1,2 separately.\n\n        Args:\n            n_test: Number of test functions\n            x: Points at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            tuple(np.ndarray, np.ndarray): First and second derivatives\n                First element: First derivatives, shape (n_test, n_points)\n                Second element: Second derivatives, shape (n_test, n_points)\n\n        Notes:\n            Special cases for n=1,2 ensure proper derivative calculations\n            following hp-VPINNs methodology.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = (\n                    ((n + 1) / 2)\n                    * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = (\n                    ((n + 2) * (n + 1) / (2 * 2))\n                    * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                    / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                    n, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n - 1) / 2\n                ) * self.jacobi_wrapper(\n                    n - 2, 1 / 2, 1 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                    (n) * (n - 1) / (2 * 2)\n                ) * self.jacobi_wrapper(\n                    n - 3, 3 / 2, 3 / 2, x\n                ) / self.jacobi_wrapper(\n                    n - 1, -1 / 2, -1 / 2, 1\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Evaluates basis functions at given coordinates.\n\n        Computes values of all basis functions at specified (xi,eta) points\n        using tensor product of 1D test functions.\n\n        Args:\n            xi: x-coordinates at which to evaluate functions\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate functions\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of all basis functions\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Basis functions are constructed as products of 1D test functions\n            in x and y directions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes x-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes y-derivatives of basis functions.\n\n        Evaluates partial derivatives with respect to y of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of y-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with values in x-direction and y-derivatives\n            of test functions in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second x-derivatives of test functions in\n            x-direction and y derivative values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Computes second x-derivatives of basis functions.\n\n        Evaluates second partial derivatives with respect to x of all basis\n        functions at given coordinates.\n\n        Args:\n            xi: x-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n            eta: y-coordinates at which to evaluate derivatives\n                Shape: (n_points,)\n\n        Returns:\n            np.ndarray: Values of second x-derivatives\n                Shape: (num_shape_functions, n_points)\n\n        Notes:\n            Uses product rule with second y-derivatives of test functions in\n            x-direction and values in y-direction.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Computes first and second derivatives of test functions.</p> <p>Calculates derivatives of test functions constructed from Jacobi polynomials, handling special cases for n=1,2 separately.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>First and second derivatives First element: First derivatives, shape (n_test, n_points) Second element: Second derivatives, shape (n_test, n_points)</p> Notes <p>Special cases for n=1,2 ensure proper derivative calculations following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes first and second derivatives of test functions.\n\n    Calculates derivatives of test functions constructed from Jacobi\n    polynomials, handling special cases for n=1,2 separately.\n\n    Args:\n        n_test: Number of test functions\n        x: Points at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        tuple(np.ndarray, np.ndarray): First and second derivatives\n            First element: First derivatives, shape (n_test, n_points)\n            Second element: Second derivatives, shape (n_test, n_points)\n\n    Notes:\n        Special cases for n=1,2 ensure proper derivative calculations\n        following hp-VPINNs methodology.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = (\n                ((n + 1) / 2)\n                * self.jacobi_wrapper(n, 1 / 2, 1 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = (\n                ((n + 2) * (n + 1) / (2 * 2))\n                * self.jacobi_wrapper(n - 1, 3 / 2, 3 / 2, x)\n                / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1)\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 1) / 2) * self.jacobi_wrapper(\n                n, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n - 1) / 2\n            ) * self.jacobi_wrapper(\n                n - 2, 1 / 2, 1 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d2test = ((n + 2) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, 1) - (\n                (n) * (n - 1) / (2 * 2)\n            ) * self.jacobi_wrapper(\n                n - 3, 3 / 2, 3 / 2, x\n            ) / self.jacobi_wrapper(\n                n - 1, -1 / 2, -1 / 2, 1\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>Computes x-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second x-derivatives of test functions in x-direction and y derivative values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second x-derivatives of test functions in\n        x-direction and y derivative values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.grady","title":"<code>grady(xi, eta)</code>","text":"<p>Computes y-derivatives of basis functions.</p> <p>Evaluates partial derivatives with respect to y of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of y-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with values in x-direction and y-derivatives of test functions in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-derivatives of basis functions.\n\n    Evaluates partial derivatives with respect to y of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of y-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with values in x-direction and y-derivatives\n        of test functions in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>Computes second x-derivatives of basis functions.</p> <p>Evaluates second partial derivatives with respect to x of all basis functions at given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate derivatives Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of second x-derivatives Shape: (num_shape_functions, n_points)</p> Notes <p>Uses product rule with second y-derivatives of test functions in x-direction and values in y-direction.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes second x-derivatives of basis functions.\n\n    Evaluates second partial derivatives with respect to x of all basis\n    functions at given coordinates.\n\n    Args:\n        xi: x-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate derivatives\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of second x-derivatives\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Uses product rule with second y-derivatives of test functions in\n        x-direction and values in y-direction.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluates Jacobi polynomial at specified points.</p> <p>Computes values of nth degree Jacobi polynomial with parameters (a,b) at given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of Jacobi polynomial. Must be non-negative integer.</p> required <code>a</code> <code>int</code> <p>First parameter of Jacobi polynomial</p> required <code>b</code> <code>int</code> <p>Second parameter of Jacobi polynomial</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate polynomial Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of Jacobi polynomial at input points Shape: Same as input x</p> Notes <p>Wrapper around scipy.special.jacobi that ensures float64 precision and proper array handling.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates Jacobi polynomial at specified points.\n\n    Computes values of nth degree Jacobi polynomial with parameters (a,b)\n    at given points x.\n\n    Args:\n        n: Degree of Jacobi polynomial. Must be non-negative integer.\n        a: First parameter of Jacobi polynomial\n        b: Second parameter of Jacobi polynomial\n        x: Points at which to evaluate polynomial\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of Jacobi polynomial at input points\n            Shape: Same as input x\n\n    Notes:\n        Wrapper around scipy.special.jacobi that ensures float64 precision\n        and proper array handling.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Computes x-component test functions.</p> <p>Evaluates the x-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes x-component test functions.\n\n    Evaluates the x-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        x: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, x) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Computes y-component test functions.</p> <p>Evaluates the y-direction test functions constructed as differences of normalized Jacobi polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions to compute</p> required <code>y</code> <code>ndarray</code> <p>Points at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of test functions at input points Shape: (n_test, n_points)</p> Notes <p>Test functions are constructed as differences of normalized Jacobi polynomials following hp-VPINNs methodology.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes y-component test functions.\n\n    Evaluates the y-direction test functions constructed as differences\n    of normalized Jacobi polynomials.\n\n    Args:\n        n_test: Number of test functions to compute\n        y: Points at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of test functions at input points\n            Shape: (n_test, n_points)\n\n    Notes:\n        Test functions are constructed as differences of normalized Jacobi\n        polynomials following hp-VPINNs methodology.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n + 1, -1 / 2, -1 / 2, 1\n        ) - self.jacobi_wrapper(n - 1, -1 / 2, -1 / 2, y) / self.jacobi_wrapper(\n            n - 1, -1 / 2, -1 / 2, 1\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNChebyshev2.value","title":"<code>value(xi, eta)</code>","text":"<p>Evaluates basis functions at given coordinates.</p> <p>Computes values of all basis functions at specified (xi,eta) points using tensor product of 1D test functions.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate functions Shape: (n_points,)</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate functions Shape: (n_points,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of all basis functions Shape: (num_shape_functions, n_points)</p> Notes <p>Basis functions are constructed as products of 1D test functions in x and y directions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_chebyshev_2.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluates basis functions at given coordinates.\n\n    Computes values of all basis functions at specified (xi,eta) points\n    using tensor product of 1D test functions.\n\n    Args:\n        xi: x-coordinates at which to evaluate functions\n            Shape: (n_points,)\n        eta: y-coordinates at which to evaluate functions\n            Shape: (n_points,)\n\n    Returns:\n        np.ndarray: Values of all basis functions\n            Shape: (num_shape_functions, n_points)\n\n    Notes:\n        Basis functions are constructed as products of 1D test functions\n        in x and y directions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi","title":"<code>Basis2DQNJacobi</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials with efficient derivative computations.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and first/second order derivatives. The implementation follows the methodology described in hp-VPINNs research.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>djacobi</code> <p>Computes kth derivative of Jacobi polynomial</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first derivatives of test functions</p> <code>ddtest_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions are derived from Jacobi polynomials with parameters (0,0)</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>class Basis2DQNJacobi(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Jacobi polynomials for QN elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Jacobi polynomials\n    with efficient derivative computations.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and first/second order derivatives. The implementation follows the methodology\n    described in hp-VPINNs research.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        djacobi(n, a, b, x, k): Computes kth derivative of Jacobi polynomial\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first derivatives of test functions\n        ddtest_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions are derived from Jacobi polynomials with parameters (0,0)\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNJacobi(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n        \"\"\"\n\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    # Derivative of the Jacobi polynomials\n    def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (float): First parameter of the Jacobi polynomial.\n            b (float): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n            k (int): Order of the derivative.\n\n        Returns:\n            np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n        Raises:\n            ValueError: If the derivative order is not 1 or 2\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        if k == 1:\n            return jacobi(n, a, b).deriv()(x)\n        if k == 2:\n            return jacobi(n, a, b).deriv(2)(x)\n        else:\n            print(f\"Invalid derivative order {k} in {__name__}.\")\n            raise ValueError(\"Derivative order should be 1 or 2.\")\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, x)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n - 1, 0, 0, y)\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 1)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        for n in range(1, n_test + 1):\n            d1test = self.djacobi(n - 1, 0, 0, x, 2)\n            d1test_total.append(d1test)\n        return np.asarray(d1test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.ddtest_fcn","title":"<code>ddtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def ddtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 2)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.djacobi","title":"<code>djacobi(n, a, b, x, k)</code>","text":"<p>Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <code>k</code> <code>int</code> <p>Order of the derivative.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the derivative order is not 1 or 2</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def djacobi(self, n: int, a: int, b: int, x: np.ndarray, k: int) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the k-th derivative of the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n        k (int): Order of the derivative.\n\n    Returns:\n        np.ndarray: Values of the k-th derivative of the Jacobi polynomial at the given points x.\n\n    Raises:\n        ValueError: If the derivative order is not 1 or 2\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    if k == 1:\n        return jacobi(n, a, b).deriv()(x)\n    if k == 2:\n        return jacobi(n, a, b).deriv(2)(x)\n    else:\n        print(f\"Invalid derivative order {k} in {__name__}.\")\n        raise ValueError(\"Derivative order should be 1 or 2.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    for n in range(1, n_test + 1):\n        d1test = self.djacobi(n - 1, 0, 0, x, 1)\n        d1test_total.append(d1test)\n    return np.asarray(d1test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.ddtest_fcn(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.ddtest_fcn(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree <code>n</code> with parameters <code>a</code> and <code>b</code> at the given points <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>float</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>float</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points <code>x</code>.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree `n` with parameters `a` and `b` at the given points `x`.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (float): First parameter of the Jacobi polynomial.\n        b (float): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points `x`.\n    \"\"\"\n\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, x)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n - 1, 0, 0, y)\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNJacobi.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_jacobi.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre","title":"<code>Basis2DQNLegendre</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions, specifically designed for use in variational physics-informed neural networks (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials implemented through Jacobi polynomial representations with parameters (0,0).</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>jacobi_wrapper</code> <p>Evaluates Jacobi polynomial at given points</p> <code>test_fcnx</code> <p>Computes x-component test functions</p> <code>test_fcny</code> <p>Computes y-component test functions</p> <code>dtest_fcn</code> <p>Computes first and second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed as tensor products of 1D test functions</li> <li>Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters</li> <li>Special cases handled for n=1,2 in derivative calculations</li> <li>All computations maintain double precision (float64)</li> <li>Efficient vectorized operations using numpy arrays</li> </ul> Example <pre><code>basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>class Basis2DQNLegendre(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions, specifically designed for use in variational physics-informed neural networks\n    (VPINNs) with domain decomposition. The basis functions are constructed using Legendre polynomials\n    implemented through Jacobi polynomial representations with parameters (0,0).\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        jacobi_wrapper(n, a, b, x): Evaluates Jacobi polynomial at given points\n        test_fcnx(n_test, x): Computes x-component test functions\n        test_fcny(n_test, y): Computes y-component test functions\n        dtest_fcn(n_test, x): Computes first and second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed as tensor products of 1D test functions\n        - Test functions use Legendre polynomials via Jacobi polynomials with (0,0) parameters\n        - Special cases handled for n=1,2 in derivative calculations\n        - All computations maintain double precision (float64)\n        - Efficient vectorized operations using numpy arrays\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendre(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n        Args:\n            n (int): Degree of the Jacobi polynomial.\n            a (int): First parameter of the Jacobi polynomial.\n            b (int): Second parameter of the Jacobi polynomial.\n            x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n        Returns:\n            np.ndarray: Values of the Jacobi polynomial at the given points.\n        \"\"\"\n        x = np.array(x, dtype=np.float64)\n        return jacobi(n, a, b)(x)\n\n    ## Helper Function\n    def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n                n - 1, 0, 0, x\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the y-component of the test functions.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n                n - 1, 0, 0, y\n            )\n            test_total.append(test)\n        return np.asarray(test_total, np.float64)\n\n    def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n        Args:\n            n_test (int): Number of test functions.\n            x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the test functions.\n        \"\"\"\n        d1test_total = []\n        d2test_total = []\n        for n in range(1, n_test + 1):\n            if n == 1:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            elif n == 2:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                )\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n            else:\n                d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                    (n) / 2\n                ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n                d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                    n - 1, 2, 2, x\n                ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n                d1test_total.append(d1test)\n                d2test_total.append(d2test)\n        return np.asarray(d1test_total), np.asarray(d2test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the x-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * test_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the y-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xx-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n        test_y = self.test_fcny(num_shape_func_in_1d, eta)\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_grad_x[i, :] * test_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the xy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n        grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                grad_test_x[i, :] * grad_test_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n            eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n        Returns:\n            np.ndarray: Values of the yy-derivatives of the basis functions.\n        \"\"\"\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n        test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n        grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n        values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n        for i in range(num_shape_func_in_1d):\n            values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n                test_x[i, :] * grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.dtest_fcn","title":"<code>dtest_fcn(n_test, x)</code>","text":"<p>Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def dtest_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-derivatives of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the test functions.\n    \"\"\"\n    d1test_total = []\n    d2test_total = []\n    for n in range(1, n_test + 1):\n        if n == 1:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        elif n == 2:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            )\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n        else:\n            d1test = ((n + 2) / 2) * self.jacobi_wrapper(n, 1, 1, x) - (\n                (n) / 2\n            ) * self.jacobi_wrapper(n - 2, 1, 1, x)\n            d2test = ((n + 2) * (n + 3) / (2 * 2)) * self.jacobi_wrapper(\n                n - 1, 2, 2, x\n            ) - ((n) * (n + 1) / (2 * 2)) * self.jacobi_wrapper(n - 3, 2, 2, x)\n            d1test_total.append(d1test)\n            d2test_total.append(d2test)\n    return np.asarray(d1test_total), np.asarray(d2test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the x-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xx-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_grad_x = self.dtest_fcn(num_shape_func_in_1d, xi)[1]\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_grad_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the xy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    grad_test_x = self.dtest_fcn(num_shape_func_in_1d, xi)[0]\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            grad_test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the y-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_test_y = self.dtest_fcn(num_shape_func_in_1d, eta)[0]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the yy-derivatives of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    grad_grad_y = self.dtest_fcn(num_shape_func_in_1d, eta)[1]\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.jacobi_wrapper","title":"<code>jacobi_wrapper(n, a, b, x)</code>","text":"<p>Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree of the Jacobi polynomial.</p> required <code>a</code> <code>int</code> <p>First parameter of the Jacobi polynomial.</p> required <code>b</code> <code>int</code> <p>Second parameter of the Jacobi polynomial.</p> required <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the Jacobi polynomial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the Jacobi polynomial at the given points.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def jacobi_wrapper(self, n: int, a: int, b: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate the Jacobi polynomial of degree n with parameters a and b at the given points x.\n\n    Args:\n        n (int): Degree of the Jacobi polynomial.\n        a (int): First parameter of the Jacobi polynomial.\n        b (int): Second parameter of the Jacobi polynomial.\n        x (np.ndarray): Points at which to evaluate the Jacobi polynomial.\n\n    Returns:\n        np.ndarray: Values of the Jacobi polynomial at the given points.\n    \"\"\"\n    x = np.array(x, dtype=np.float64)\n    return jacobi(n, a, b)(x)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.test_fcnx","title":"<code>test_fcnx(n_test, x)</code>","text":"<p>Compute the x-component of the test functions for a given number of test functions and x-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>x</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the x-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcnx(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the x-component of the test functions for a given number of test functions and x-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        x (np.ndarray): x-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the x-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, x) - self.jacobi_wrapper(\n            n - 1, 0, 0, x\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.test_fcny","title":"<code>test_fcny(n_test, y)</code>","text":"<p>Compute the y-component of the test functions for a given number of test functions and y-coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>Number of test functions.</p> required <code>y</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the y-component of the test functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def test_fcny(self, n_test: int, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the y-component of the test functions for a given number of test functions and y-coordinates.\n\n    Args:\n        n_test (int): Number of test functions.\n        y (np.ndarray): y-coordinates at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: Values of the y-component of the test functions.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        test = self.jacobi_wrapper(n + 1, 0, 0, y) - self.jacobi_wrapper(\n            n - 1, 0, 0, y\n        )\n        test_total.append(test)\n    return np.asarray(test_total, np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendre.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>x-coordinates at which to evaluate the basis functions.</p> required <code>eta</code> <code>ndarray</code> <p>y-coordinates at which to evaluate the basis functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): x-coordinates at which to evaluate the basis functions.\n        eta (np.ndarray): y-coordinates at which to evaluate the basis functions.\n\n    Returns:\n        np.ndarray: Values of the basis functions.\n    \"\"\"\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n    test_x = self.test_fcnx(num_shape_func_in_1d, xi)\n    test_y = self.test_fcny(num_shape_func_in_1d, eta)\n    values = np.zeros((self.num_shape_functions, len(xi)), dtype=np.float64)\n\n    for i in range(num_shape_func_in_1d):\n        values[num_shape_func_in_1d * i : num_shape_func_in_1d * (i + 1), :] = (\n            test_x[i, :] * test_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial","title":"<code>Basis2DQNLegendreSpecial</code>","text":"<p>               Bases: <code>BasisFunction2D</code></p> <p>A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.</p> <p>This class provides a complete implementation for computing basis functions and their derivatives in two dimensions. The basis functions are constructed using a special formulation based on differences of consecutive Legendre polynomials.</p> <p>The class inherits from BasisFunction2D and implements all required methods for computing function values and derivatives up to second order.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Total number of shape functions in the 2D element. Must be a perfect square as it represents tensor product of 1D functions.</p> <p>Methods:</p> Name Description <code>test_fcn</code> <p>Computes test functions using Legendre polynomial differences</p> <code>test_grad_fcn</code> <p>Computes first derivatives of test functions</p> <code>test_grad_grad_fcn</code> <p>Computes second derivatives of test functions</p> <code>value</code> <p>Computes values of all basis functions</p> <code>gradx</code> <p>Computes x-derivatives of all basis functions</p> <code>grady</code> <p>Computes y-derivatives of all basis functions</p> <code>gradxx</code> <p>Computes second x-derivatives of all basis functions</p> <code>gradyy</code> <p>Computes second y-derivatives of all basis functions</p> <code>gradxy</code> <p>Computes mixed xy-derivatives of all basis functions</p> Implementation Details <ul> <li>Basis functions are constructed using differences of consecutive Legendre polynomials</li> <li>Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial</li> <li>All computations maintain numerical precision using numpy arrays</li> <li>Efficient vectorized operations for multiple point evaluations</li> <li>Tensor product construction for 2D basis functions</li> </ul> Example <pre><code>basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\nxi = np.linspace(-1, 1, 100)\neta = np.linspace(-1, 1, 100)\nvalues = basis.value(xi, eta)\nx_derivatives = basis.gradx(xi, eta)\n</code></pre> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>class Basis2DQNLegendreSpecial(BasisFunction2D):\n    \"\"\"\n    A specialized implementation of two-dimensional basis functions using Legendre polynomials for Q1 elements.\n\n    This class provides a complete implementation for computing basis functions and their derivatives\n    in two dimensions. The basis functions are constructed using a special formulation based on\n    differences of consecutive Legendre polynomials.\n\n    The class inherits from BasisFunction2D and implements all required methods for computing\n    function values and derivatives up to second order.\n\n    Attributes:\n        num_shape_functions (int): Total number of shape functions in the 2D element.\n            Must be a perfect square as it represents tensor product of 1D functions.\n\n    Methods:\n        test_fcn(n_test, x): Computes test functions using Legendre polynomial differences\n        test_grad_fcn(n_test, x): Computes first derivatives of test functions\n        test_grad_grad_fcn(n_test, x): Computes second derivatives of test functions\n        value(xi, eta): Computes values of all basis functions\n        gradx(xi, eta): Computes x-derivatives of all basis functions\n        grady(xi, eta): Computes y-derivatives of all basis functions\n        gradxx(xi, eta): Computes second x-derivatives of all basis functions\n        gradyy(xi, eta): Computes second y-derivatives of all basis functions\n        gradxy(xi, eta): Computes mixed xy-derivatives of all basis functions\n\n    Implementation Details:\n        - Basis functions are constructed using differences of consecutive Legendre polynomials\n        - Test functions are created using Pn+1(x) - Pn-1(x) where Pn is the nth Legendre polynomial\n        - All computations maintain numerical precision using numpy arrays\n        - Efficient vectorized operations for multiple point evaluations\n        - Tensor product construction for 2D basis functions\n\n    Example:\n        ```python\n        basis = Basis2DQNLegendreSpecial(num_shape_functions=16)  # Creates 4x4 basis functions\n        xi = np.linspace(-1, 1, 100)\n        eta = np.linspace(-1, 1, 100)\n        values = basis.value(xi, eta)\n        x_derivatives = basis.gradx(xi, eta)\n        ```\n    \"\"\"\n\n    def __init__(self, num_shape_functions: int):\n        super().__init__(num_shape_functions)\n\n    def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the test function values for a given number of tests and input values.\n\n        Args:\n            n_test (int): The number of test functions to calculate.\n            x (np.ndarray): The input values at which to evaluate the test functions.\n\n        Returns:\n            np.ndarray: An array containing the results of the test functions at the given input values.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1)\n            obj2 = legendre(n - 1)\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the test function at a given point.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv()\n            obj2 = legendre(n - 1).deriv()\n            test = obj1(x) - obj2(x)\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n        Args:\n            n_test (int): The number of test cases to evaluate.\n            x (np.ndarray): The input value at which to evaluate the function.\n\n        Returns:\n            np.ndarray: An array containing the results of the test cases.\n        \"\"\"\n        test_total = []\n        for n in range(1, n_test + 1):\n            obj1 = legendre(n + 1).deriv(2)\n            obj2 = legendre(n - 1).deriv(2)\n            test = obj1(x) - obj2(x)\n\n            test_total.append(test)\n        return np.asarray(test_total)\n\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The values of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The x-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The y-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xx-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_grad_x[i, :] * test_function_y\n            )\n\n        return values\n\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The xy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_grad_x[i, :] * test_function_grad_y\n            )\n\n        return values\n\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinates.\n            eta (np.ndarray): The eta coordinates.\n\n        Returns:\n            np.ndarray: The yy-derivatives of the basis functions.\n        \"\"\"\n        values = np.zeros((self.num_shape_functions, len(xi)))\n\n        num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n        test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n        test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n        # Generate an outer product of the test functions to generate the basis functions\n        for i in range(num_shape_func_in_1d):\n            values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n                test_function_x[i, :] * test_function_grad_grad_y\n            )\n\n        return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradx","title":"<code>gradx(xi, eta)</code>","text":"<p>This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the x-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The x-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradxx","title":"<code>gradxx(xi, eta)</code>","text":"<p>This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xx-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xx-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xx-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_grad_x = self.test_grad_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_grad_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradxy","title":"<code>gradxy(xi, eta)</code>","text":"<p>This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The xy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the xy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The xy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_grad_x = self.test_grad_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_grad_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.grady","title":"<code>grady(xi, eta)</code>","text":"<p>This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the y-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The y-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_y = self.test_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.gradyy","title":"<code>gradyy(xi, eta)</code>","text":"<p>This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The yy-derivatives of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the yy-derivatives of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The yy-derivatives of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_grad_grad_y = self.test_grad_grad_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_grad_grad_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.test_fcn","title":"<code>test_fcn(n_test, x)</code>","text":"<p>Calculate the test function values for a given number of tests and input values.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test functions to calculate.</p> required <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the test functions.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test functions at the given input values.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the test function values for a given number of tests and input values.\n\n    Args:\n        n_test (int): The number of test functions to calculate.\n        x (np.ndarray): The input values at which to evaluate the test functions.\n\n    Returns:\n        np.ndarray: An array containing the results of the test functions at the given input values.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1)\n        obj2 = legendre(n - 1)\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.test_grad_fcn","title":"<code>test_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the test function at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the test function at a given point.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv()\n        obj2 = legendre(n - 1).deriv()\n        test = obj1(x) - obj2(x)\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.test_grad_grad_fcn","title":"<code>test_grad_grad_fcn(n_test, x)</code>","text":"<p>Calculate the gradient of the second derivative of a function using Legendre polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>n_test</code> <code>int</code> <p>The number of test cases to evaluate.</p> required <code>x</code> <code>ndarray</code> <p>The input value at which to evaluate the function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the results of the test cases.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def test_grad_grad_fcn(self, n_test: int, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the gradient of the second derivative of a function using Legendre polynomials.\n\n    Args:\n        n_test (int): The number of test cases to evaluate.\n        x (np.ndarray): The input value at which to evaluate the function.\n\n    Returns:\n        np.ndarray: An array containing the results of the test cases.\n    \"\"\"\n    test_total = []\n    for n in range(1, n_test + 1):\n        obj1 = legendre(n + 1).deriv(2)\n        obj2 = legendre(n - 1).deriv(2)\n        test = obj1(x) - obj2(x)\n\n        test_total.append(test)\n    return np.asarray(test_total)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Basis2DQNLegendreSpecial.value","title":"<code>value(xi, eta)</code>","text":"<p>This method returns the values of the basis functions at the given (xi, eta) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinates.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The values of the basis functions.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_2d_qn_legendre_special.py</code> <pre><code>def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the values of the basis functions at the given (xi, eta) coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinates.\n        eta (np.ndarray): The eta coordinates.\n\n    Returns:\n        np.ndarray: The values of the basis functions.\n    \"\"\"\n    values = np.zeros((self.num_shape_functions, len(xi)))\n\n    num_shape_func_in_1d = int(np.sqrt(self.num_shape_functions))\n\n    test_function_x = self.test_fcn(num_shape_func_in_1d, xi)\n    test_function_y = self.test_fcn(num_shape_func_in_1d, eta)\n\n    # Generate an outer product of the test functions to generate the basis functions\n    for i in range(num_shape_func_in_1d):\n        values[i * num_shape_func_in_1d : (i + 1) * num_shape_func_in_1d, :] = (\n            test_function_x[i, :] * test_function_y\n        )\n\n    return values\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D","title":"<code>BasisFunction2D</code>","text":"<p>An abstract base class defining the interface for two-dimensional finite element basis functions.</p> <p>This class serves as a template for implementing various types of 2D basis functions (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines the required methods for function evaluation and derivatives.</p> <p>Attributes:</p> Name Type Description <code>num_shape_functions</code> <code>int</code> <p>Number of shape functions in the element. Typically a perfect square for tensor-product bases.</p> <p>Methods:</p> Name Description <code>value</code> <p>Evaluates basis functions at given reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of basis functions at (xi, eta)</p> <code>gradx</code> <p>Computes x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of x-derivatives at (xi, eta)</p> <code>grady</code> <p>Computes y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of y-derivatives at (xi, eta)</p> <code>gradxx</code> <p>Computes second x-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second x-derivatives at (xi, eta)</p> <code>gradxy</code> <p>Computes mixed derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of mixed derivatives at (xi, eta)</p> <code>gradyy</code> <p>Computes second y-derivatives at reference coordinates Args:     xi (float): First reference coordinate     eta (float): Second reference coordinate Returns:     float: Values of second y-derivatives at (xi, eta)</p> Notes <ul> <li>All coordinate inputs (xi, eta) should be in the reference element range</li> <li>Subclasses must implement all abstract methods</li> <li>Used as base class for specific polynomial implementations:<ul> <li>Legendre polynomials (normal and special variants)</li> <li>Jacobi polynomials</li> <li>Chebyshev polynomials</li> </ul> </li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>class BasisFunction2D:\n    \"\"\"\n    An abstract base class defining the interface for two-dimensional finite element basis functions.\n\n    This class serves as a template for implementing various types of 2D basis functions\n    (Legendre, Jacobi, Chebyshev, etc.) used in finite element computations. It defines\n    the required methods for function evaluation and derivatives.\n\n    Attributes:\n        num_shape_functions (int): Number of shape functions in the element.\n            Typically a perfect square for tensor-product bases.\n\n    Methods:\n        value(xi, eta): Evaluates basis functions at given reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of basis functions at (xi, eta)\n\n        gradx(xi, eta): Computes x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of x-derivatives at (xi, eta)\n\n        grady(xi, eta): Computes y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of y-derivatives at (xi, eta)\n\n        gradxx(xi, eta): Computes second x-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second x-derivatives at (xi, eta)\n\n        gradxy(xi, eta): Computes mixed derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of mixed derivatives at (xi, eta)\n\n        gradyy(xi, eta): Computes second y-derivatives at reference coordinates\n            Args:\n                xi (float): First reference coordinate\n                eta (float): Second reference coordinate\n            Returns:\n                float: Values of second y-derivatives at (xi, eta)\n\n    Notes:\n        - All coordinate inputs (xi, eta) should be in the reference element range\n        - Subclasses must implement all abstract methods\n        - Used as base class for specific polynomial implementations:\n            - Legendre polynomials (normal and special variants)\n            - Jacobi polynomials\n            - Chebyshev polynomials\n    \"\"\"\n\n    def __init__(self, num_shape_functions):\n        self.num_shape_functions = num_shape_functions\n\n    @abstractmethod\n    def value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Evaluates the basis function at the given xi and eta coordinates.\n\n        Args:\n            xi (float): The xi coordinate.\n            eta (float): The eta coordinate.\n\n        Returns:\n            float: The value of the basis function at ( xi, eta).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to xi.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to xi.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Computes the second partial derivative of the basis function with respect to eta.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The second partial derivative of the basis function with respect to eta.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradx","title":"<code>gradx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradxx","title":"<code>gradxx(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to xi.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to xi.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxx(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to xi.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to xi.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradxy","title":"<code>gradxy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the mixed partial derivative of the basis function with respect to xi and eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradxy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the mixed partial derivative of the basis function with respect to xi and eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The mixed partial derivative of the basis function with respect to xi and eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.grady","title":"<code>grady(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef grady(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.gradyy","title":"<code>gradyy(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Computes the second partial derivative of the basis function with respect to eta.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The second partial derivative of the basis function with respect to eta.</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef gradyy(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the second partial derivative of the basis function with respect to eta.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The second partial derivative of the basis function with respect to eta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.BasisFunction2D.value","title":"<code>value(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>Evaluates the basis function at the given xi and eta coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>float</code> <p>The xi coordinate.</p> required <code>eta</code> <code>float</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>The value of the basis function at ( xi, eta).</p> Source code in <code>scirex\\core\\sciml\\fe\\basis_function_2d.py</code> <pre><code>@abstractmethod\ndef value(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Evaluates the basis function at the given xi and eta coordinates.\n\n    Args:\n        xi (float): The xi coordinate.\n        eta (float): The eta coordinate.\n\n    Returns:\n        float: The value of the basis function at ( xi, eta).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain","title":"<code>FE2DSetupMain</code>","text":"<p>Main configuration class for 2D finite element analysis setup.</p> <p>This class handles the configuration and initialization of finite element analysis components, including basis functions, quadrature rules, and geometric transformations.</p> <p>Attributes:</p> Name Type Description <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the element</p> Example <p>setup = FE2DSetupMain( ...     cell_type='quadrilateral', ...     fe_order=2, ...     fe_type='legendre', ...     quad_order=3, ...     quad_type='gauss' ... ) basis = setup.assign_basis_function() weights, xi, eta = setup.assign_quadrature_rules()</p> Notes <ul> <li>Supports only quadrilateral elements currently</li> <li>Validates all input parameters for correctness</li> <li>Provides different polynomial basis options</li> <li>Handles both affine and bilinear transformations</li> <li>Quadrature order must be &gt;= 3 for accuracy</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>class FE2DSetupMain:\n    \"\"\"\n    Main configuration class for 2D finite element analysis setup.\n\n    This class handles the configuration and initialization of finite element\n    analysis components, including basis functions, quadrature rules, and\n    geometric transformations.\n\n    Attributes:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n        n_nodes (int): Number of nodes in the element\n\n    Example:\n        &gt;&gt;&gt; setup = FE2DSetupMain(\n        ...     cell_type='quadrilateral',\n        ...     fe_order=2,\n        ...     fe_type='legendre',\n        ...     quad_order=3,\n        ...     quad_type='gauss'\n        ... )\n        &gt;&gt;&gt; basis = setup.assign_basis_function()\n        &gt;&gt;&gt; weights, xi, eta = setup.assign_quadrature_rules()\n\n    Notes:\n        - Supports only quadrilateral elements currently\n        - Validates all input parameters for correctness\n        - Provides different polynomial basis options\n        - Handles both affine and bilinear transformations\n        - Quadrature order must be &gt;= 3 for accuracy\n    \"\"\"\n\n    def __init__(\n        self,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n    ):\n        \"\"\"\n        Constructor for the FE2DSetupMain class.\n\n        Args:\n            cell_type (str): Type of finite element ('quadrilateral')\n            fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n            fe_type (str): Type of basis functions\n                ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n            quad_order (int): Order of quadrature rule (&gt;= 2)\n            quad_type (str): Type of quadrature formula\n\n        Raises:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.assign_basis_function()\n\n    def assign_basis_function(self) -&gt; BasisFunction2D:\n        \"\"\"\n        Assigns the basis function based on the cell type and the fe_order.\n\n        Args:\n            None\n\n        Returns:\n            BasisFunction2D: The basis function object for the given configuration.\n\n        Raises:\n            ValueError: If the fe order is invalid or the cell type is invalid.\n        \"\"\"\n        # check for fe order lower bound and higher bound\n        if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n        if self.cell_type == \"quadrilateral\":\n            self.n_nodes = 4\n\n            # --- LEGENDRE --- #\n            if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n                # jacobi is added for backward compatibility with prev pushes\n                # generally, jacobi is referred to as Legendre basis on previous iterations\n                return Basis2DQNLegendre(self.fe_order**2)\n\n            elif self.fe_type == \"legendre_special\":\n                return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n            # ----- CHEBYSHEV ---- #\n            elif self.fe_type == \"chebyshev_2\":\n                return Basis2DQNChebyshev2(self.fe_order**2)\n\n            # ----- PLain jacobi ---- #\n            elif self.fe_type == \"jacobi_plain\":\n                return Basis2DQNJacobi(self.fe_order**2)\n\n            else:\n                print(\n                    f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\n                    'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n                )\n\n        print(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_quadrature_rules(self):\n        \"\"\"\n        Assigns the quadrature rule based on the quad_order.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n        Raises:\n            ValueError: If the quad_order is invalid\n            ValueError: If the cell type is invalid\n            ValueError: If the quad_order is not between 1 and 9999\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if self.quad_order &lt; 3:\n                raise ValueError(\"Quad order should be greater than 2.\")\n            elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n                weights, xi, eta = Quadratureformulas_Quad2D(\n                    self.quad_order, self.quad_type\n                ).get_quad_values()\n                return weights, xi, eta\n            else:\n                print(\n                    f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n\n    def assign_fe_transformation(\n        self, fe_transformation_type: str, cell_coordinates: np.ndarray\n    ) -&gt; FETransforamtion2D:\n        \"\"\"\n        Assigns the fe transformation based on the cell type.\n\n        Args:\n            fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n            cell_coordinates (np.ndarray): The cell coordinates\n\n        Returns:\n            FETransforamtion2D: The fe transformation object for the given configuration.\n\n        Raises:\n            ValueError: If the cell type is invalid\n            ValueError: If the fe transformation type is invalid\n        \"\"\"\n        if self.cell_type == \"quadrilateral\":\n            if fe_transformation_type == \"affine\":\n                return QuadAffin(cell_coordinates)\n            elif fe_transformation_type == \"bilinear\":\n                return QuadBilinear(cell_coordinates)\n            else:\n                raise ValueError(\n                    f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n                )\n\n        else:\n            raise ValueError(\n                f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.__init__","title":"<code>__init__(cell_type, fe_order, fe_type, quad_order, quad_type)</code>","text":"<p>Constructor for the FE2DSetupMain class.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type</code> <code>str</code> <p>Type of finite element ('quadrilateral')</p> required <code>fe_order</code> <code>int</code> <p>Order of finite element approximation (1 &lt; order &lt; 1e3)</p> required <code>fe_type</code> <code>str</code> <p>Type of basis functions ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')</p> required <code>quad_order</code> <code>int</code> <p>Order of quadrature rule (&gt;= 2)</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def __init__(\n    self,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n):\n    \"\"\"\n    Constructor for the FE2DSetupMain class.\n\n    Args:\n        cell_type (str): Type of finite element ('quadrilateral')\n        fe_order (int): Order of finite element approximation (1 &lt; order &lt; 1e3)\n        fe_type (str): Type of basis functions\n            ('legendre', 'legendre_special', 'chebyshev_2', 'jacobi_plain')\n        quad_order (int): Order of quadrature rule (&gt;= 2)\n        quad_type (str): Type of quadrature formula\n\n    Raises:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.assign_basis_function()\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.assign_basis_function","title":"<code>assign_basis_function()</code>","text":"<p>Assigns the basis function based on the cell type and the fe_order.</p> <p>Returns:</p> Name Type Description <code>BasisFunction2D</code> <code>BasisFunction2D</code> <p>The basis function object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the fe order is invalid or the cell type is invalid.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_basis_function(self) -&gt; BasisFunction2D:\n    \"\"\"\n    Assigns the basis function based on the cell type and the fe_order.\n\n    Args:\n        None\n\n    Returns:\n        BasisFunction2D: The basis function object for the given configuration.\n\n    Raises:\n        ValueError: If the fe order is invalid or the cell type is invalid.\n    \"\"\"\n    # check for fe order lower bound and higher bound\n    if self.fe_order &lt;= 1 or self.fe_order &gt;= 1e3:\n        print(\n            f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"fe order should be greater than 1 and less than 1e4.\")\n\n    if self.cell_type == \"quadrilateral\":\n        self.n_nodes = 4\n\n        # --- LEGENDRE --- #\n        if self.fe_type == \"legendre\" or self.fe_type == \"jacobi\":\n            # jacobi is added for backward compatibility with prev pushes\n            # generally, jacobi is referred to as Legendre basis on previous iterations\n            return Basis2DQNLegendre(self.fe_order**2)\n\n        elif self.fe_type == \"legendre_special\":\n            return Basis2DQNLegendreSpecial(self.fe_order**2)\n\n        # ----- CHEBYSHEV ---- #\n        elif self.fe_type == \"chebyshev_2\":\n            return Basis2DQNChebyshev2(self.fe_order**2)\n\n        # ----- PLain jacobi ---- #\n        elif self.fe_type == \"jacobi_plain\":\n            return Basis2DQNJacobi(self.fe_order**2)\n\n        else:\n            print(\n                f\"Invalid fe order {self.fe_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                'fe order should be one of the : \"legendre\" , \"jacobi\", \"legendre_special\", \"chebyshev_2\", \"jacobi_plain\"'\n            )\n\n    print(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.assign_fe_transformation","title":"<code>assign_fe_transformation(fe_transformation_type, cell_coordinates)</code>","text":"<p>Assigns the fe transformation based on the cell type.</p> <p>Parameters:</p> Name Type Description Default <code>fe_transformation_type</code> <code>str</code> <p>Type of fe transformation ('affine', 'bilinear')</p> required <code>cell_coordinates</code> <code>ndarray</code> <p>The cell coordinates</p> required <p>Returns:</p> Name Type Description <code>FETransforamtion2D</code> <code>FETransforamtion2D</code> <p>The fe transformation object for the given configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the fe transformation type is invalid</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_fe_transformation(\n    self, fe_transformation_type: str, cell_coordinates: np.ndarray\n) -&gt; FETransforamtion2D:\n    \"\"\"\n    Assigns the fe transformation based on the cell type.\n\n    Args:\n        fe_transformation_type (str): Type of fe transformation ('affine', 'bilinear')\n        cell_coordinates (np.ndarray): The cell coordinates\n\n    Returns:\n        FETransforamtion2D: The fe transformation object for the given configuration.\n\n    Raises:\n        ValueError: If the cell type is invalid\n        ValueError: If the fe transformation type is invalid\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if fe_transformation_type == \"affine\":\n            return QuadAffin(cell_coordinates)\n        elif fe_transformation_type == \"bilinear\":\n            return QuadBilinear(cell_coordinates)\n        else:\n            raise ValueError(\n                f\"Invalid fe transformation type {fe_transformation_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n\n    else:\n        raise ValueError(\n            f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FE2DSetupMain.assign_quadrature_rules","title":"<code>assign_quadrature_rules()</code>","text":"<p>Assigns the quadrature rule based on the quad_order.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quad_order is invalid</p> <code>ValueError</code> <p>If the cell type is invalid</p> <code>ValueError</code> <p>If the quad_order is not between 1 and 9999</p> Source code in <code>scirex\\core\\sciml\\fe\\fe2d_setup_main.py</code> <pre><code>def assign_quadrature_rules(self):\n    \"\"\"\n    Assigns the quadrature rule based on the quad_order.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format.\n\n    Raises:\n        ValueError: If the quad_order is invalid\n        ValueError: If the cell type is invalid\n        ValueError: If the quad_order is not between 1 and 9999\n    \"\"\"\n    if self.cell_type == \"quadrilateral\":\n        if self.quad_order &lt; 3:\n            raise ValueError(\"Quad order should be greater than 2.\")\n        elif self.quad_order &gt;= 2 and self.quad_order &lt;= 9999:\n            weights, xi, eta = Quadratureformulas_Quad2D(\n                self.quad_order, self.quad_type\n            ).get_quad_values()\n            return weights, xi, eta\n        else:\n            print(\n                f\"Invalid quad order {self.quad_order} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quad order should be between 1 and 9999.\")\n\n    raise ValueError(\n        f\"Invalid cell type {self.cell_type} in {self.__class__.__name__} from {__name__}.\"\n    )\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D","title":"<code>FETransforamtion2D</code>","text":"<p>A base class for 2D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 2D finite element analysis. Implementations must provide specific transformation rules for different element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes.</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes.</p> Example <p>class QuadTransform(FETransformation2D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>class FETransforamtion2D:\n    \"\"\"\n    A base class for 2D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 2D finite element analysis. Implementations must provide specific\n    transformation rules for different element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n\n        get_jacobian(xi, eta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n\n    Example:\n        &gt;&gt;&gt; class QuadTransform(FETransformation2D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n        ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransforamtion2D class.\n        \"\"\"\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        :return: None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransforamtion2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransforamtion2D class.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.FETransforamtion2D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas","title":"<code>Quadratureformulas</code>","text":"<p>Abstract base class for numerical quadrature formulas.</p> <p>This class defines the interface that all quadrature implementations must follow. It provides the basic structure for implementing various quadrature rules while ensuring consistent access to quadrature data.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of the quadrature rule</p> <code>quad_type</code> <p>Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points</p> Example <p>class MyQuadrature(Quadratureformulas): ...     def init(self): ...         super().init(quad_order=3, ...                         quad_type='custom', ...                         num_quad_points=9) ...     def get_quad_values(self): ...         # Implementation ...         pass ...     def get_num_quad_points(self): ...         return self.num_quad_points</p> Note <p>This is an abstract base class. Concrete implementations must override: - get_quad_values() - get_num_quad_points()</p> <p>The implementation should ensure proper initialization of: - Quadrature points - Quadrature weights - Number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>class Quadratureformulas:\n    \"\"\"Abstract base class for numerical quadrature formulas.\n\n    This class defines the interface that all quadrature implementations must\n    follow. It provides the basic structure for implementing various quadrature\n    rules while ensuring consistent access to quadrature data.\n\n    Attributes:\n        quad_order: Order of the quadrature rule\n        quad_type: Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Example:\n        &gt;&gt;&gt; class MyQuadrature(Quadratureformulas):\n        ...     def __init__(self):\n        ...         super().__init__(quad_order=3,\n        ...                         quad_type='custom',\n        ...                         num_quad_points=9)\n        ...     def get_quad_values(self):\n        ...         # Implementation\n        ...         pass\n        ...     def get_num_quad_points(self):\n        ...         return self.num_quad_points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - get_quad_values()\n        - get_num_quad_points()\n\n        The implementation should ensure proper initialization of:\n        - Quadrature points\n        - Quadrature weights\n        - Number of quadrature points\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n            num_quad_points: Total number of quadrature points\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.num_quad_points = num_quad_points\n\n    @abstractmethod\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            weights: Weights for each quadrature point\n            xi: x-coordinates of quadrature points in reference element\n            eta: y-coordinates of quadrature points in reference element\n        \"\"\"\n\n    @abstractmethod\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            num_quad_points: Total number of quadrature points\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas.__init__","title":"<code>__init__(quad_order, quad_type, num_quad_points)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <code>num_quad_points</code> <code>int</code> <p>Total number of quadrature points</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.num_quad_points = num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas.get_num_quad_points","title":"<code>get_num_quad_points()</code>  <code>abstractmethod</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>num_quad_points</code> <p>Total number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        num_quad_points: Total number of quadrature points\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas.get_quad_values","title":"<code>get_quad_values()</code>  <code>abstractmethod</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>weights</code> <p>Weights for each quadrature point</p> <code>xi</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta</code> <p>y-coordinates of quadrature points in reference element</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        weights: Weights for each quadrature point\n        xi: x-coordinates of quadrature points in reference element\n        eta: y-coordinates of quadrature points in reference element\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D","title":"<code>Quadratureformulas_Quad2D</code>","text":"<p>               Bases: <code>Quadratureformulas</code></p> <p>Implements quadrature formulas for 2D quadrilateral elements.</p> <p>This class provides methods to compute quadrature points and weights for 2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi quadrature schemes. The implementation uses tensor products of 1D rules.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of quadrature rule</p> <code>quad_type</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points (quad_order^2)</p> <code>xi_quad</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta_quad</code> <p>y-coordinates of quadrature points in reference element</p> <code>quad_weights</code> <p>Weights for each quadrature point</p> Example <p>quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre') weights, xi, eta = quad.get_quad_values() n_points = quad.get_num_quad_points()</p> Note <ul> <li>Gauss-Legendre points are optimal for polynomial integrands</li> <li>Gauss-Jacobi points include element vertices (useful for certain FEM applications)</li> <li>All computations are performed in the reference element [-1,1]\u00d7[-1,1]</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>class Quadratureformulas_Quad2D(Quadratureformulas):\n    \"\"\"Implements quadrature formulas for 2D quadrilateral elements.\n\n    This class provides methods to compute quadrature points and weights for\n    2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi\n    quadrature schemes. The implementation uses tensor products of 1D rules.\n\n    Attributes:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points (quad_order^2)\n        xi_quad: x-coordinates of quadrature points in reference element\n        eta_quad: y-coordinates of quadrature points in reference element\n        quad_weights: Weights for each quadrature point\n\n    Example:\n        &gt;&gt;&gt; quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre')\n        &gt;&gt;&gt; weights, xi, eta = quad.get_quad_values()\n        &gt;&gt;&gt; n_points = quad.get_num_quad_points()\n\n    Note:\n        - Gauss-Legendre points are optimal for polynomial integrands\n        - Gauss-Jacobi points include element vertices (useful for certain FEM applications)\n        - All computations are performed in the reference element [-1,1]\u00d7[-1,1]\n\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the quadrature type is not supported.\n        \"\"\"\n        # initialize the super class\n        super().__init__(\n            quad_order=quad_order,\n            quad_type=quad_type,\n            num_quad_points=quad_order * quad_order,\n        )\n\n        # Calculate the Gauss-Legendre quadrature points and weights for 1D\n        # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n        quad_type = self.quad_type\n\n        if quad_type == \"gauss-legendre\":\n            # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n            # if quad_order == 2:\n            #     nodes_1d = np.array([-1, 1])\n            #     weights_1d = np.array([1, 1])\n            # else:\n            nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n                quad_order\n            )  # Interior points\n            # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n            # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        elif quad_type == \"gauss-jacobi\":\n\n            def GaussJacobiWeights(Q: int, a, b):\n                [X, W] = roots_jacobi(Q, a, b)\n                return [X, W]\n\n            def jacobi_wrapper(n, a, b, x):\n\n                x = np.array(x, dtype=np.float64)\n\n                return jacobi(n, a, b)(x)\n\n            # Weight coefficients\n            def GaussLobattoJacobiWeights(Q: int, a, b):\n                W = []\n                X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n                if a == 0 and b == 0:\n                    W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                    Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                    Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n                else:\n                    W = (\n                        2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                        )\n                    )\n                    Wl = (\n                        (b + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                        )\n                    )\n                    Wr = (\n                        (a + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                        )\n                    )\n                W = np.append(W, Wr)\n                W = np.append(Wl, W)\n                X = np.append(X, 1)\n                X = np.append(-1, X)\n                return [X, W]\n\n            # get quadrature points and weights in 1D\n            x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(x, x)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (w[:, np.newaxis] * w).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        else:\n            print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n            print(\n                f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quadrature type not supported.\")\n\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format\n        \"\"\"\n        return self.quad_weights, self.xi_quad, self.eta_quad\n\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            int: The number of quadrature points\n        \"\"\"\n        return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D.__init__","title":"<code>__init__(quad_order, quad_type)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quadrature type is not supported.</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the quadrature type is not supported.\n    \"\"\"\n    # initialize the super class\n    super().__init__(\n        quad_order=quad_order,\n        quad_type=quad_type,\n        num_quad_points=quad_order * quad_order,\n    )\n\n    # Calculate the Gauss-Legendre quadrature points and weights for 1D\n    # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n    quad_type = self.quad_type\n\n    if quad_type == \"gauss-legendre\":\n        # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n        # if quad_order == 2:\n        #     nodes_1d = np.array([-1, 1])\n        #     weights_1d = np.array([1, 1])\n        # else:\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n            quad_order\n        )  # Interior points\n        # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n        # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    elif quad_type == \"gauss-jacobi\":\n\n        def GaussJacobiWeights(Q: int, a, b):\n            [X, W] = roots_jacobi(Q, a, b)\n            return [X, W]\n\n        def jacobi_wrapper(n, a, b, x):\n\n            x = np.array(x, dtype=np.float64)\n\n            return jacobi(n, a, b)(x)\n\n        # Weight coefficients\n        def GaussLobattoJacobiWeights(Q: int, a, b):\n            W = []\n            X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n            if a == 0 and b == 0:\n                W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n            else:\n                W = (\n                    2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                    )\n                )\n                Wl = (\n                    (b + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                    )\n                )\n                Wr = (\n                    (a + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                    )\n                )\n            W = np.append(W, Wr)\n            W = np.append(Wl, W)\n            X = np.append(X, 1)\n            X = np.append(-1, X)\n            return [X, W]\n\n        # get quadrature points and weights in 1D\n        x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(x, x)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (w[:, np.newaxis] * w).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    else:\n        print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n        print(\n            f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Quadrature type not supported.\")\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D.get_num_quad_points","title":"<code>get_num_quad_points()</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of quadrature points\n    \"\"\"\n    return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/fe2d_setup_main/#scirex.core.sciml.fe.fe2d_setup_main.Quadratureformulas_Quad2D.get_quad_values","title":"<code>get_quad_values()</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format\n    \"\"\"\n    return self.quad_weights, self.xi_quad, self.eta_quad\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/","title":"FE_transformation_2d","text":"<p>Module: fe_transformation_2d.py</p> <p>This module provides the abstract base class for all 2D finite element transformations.  It defines the interface for mapping between reference and physical coordinates in  two-dimensional finite element analysis.</p> <p>Classes:</p> Name Description <code>FETransformation2D</code> <p>Abstract base class for 2D finite element transformations</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> <li>quad_affine: For affine transformation implementations</li> <li>quad_bilinear: For bilinear transformation implementations</li> </ul> Key Features <ul> <li>Abstract interface for coordinate transformations</li> <li>Reference to physical domain mapping</li> <li>Jacobian matrix computation</li> <li>Support for different element geometries</li> <li>Cell geometry specification interface</li> <li>Systematic transformation validation</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D","title":"<code>FETransforamtion2D</code>","text":"<p>A base class for 2D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 2D finite element analysis. Implementations must provide specific transformation rules for different element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes.</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes.</p> Example <p>class QuadTransform(FETransformation2D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray: ...         # Implementation for quad element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>class FETransforamtion2D:\n    \"\"\"\n    A base class for 2D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 2D finite element analysis. Implementations must provide specific\n    transformation rules for different element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n\n        get_jacobian(xi, eta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n\n    Example:\n        &gt;&gt;&gt; class QuadTransform(FETransformation2D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi:np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n        ...     def get_jacobian(self, xi: np.ndarray, eta:np.ndarray) -&gt; np.ndarray:\n        ...         # Implementation for quad element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransforamtion2D class.\n        \"\"\"\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        :return: None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransforamtion2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransforamtion2D class.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.FETransforamtion2D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_2d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_2d/#scirex.core.sciml.fe.fe_transformation_2d.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/","title":"FE_transformation_3d","text":"<p>Module: fe_transformation_3d.py</p> <p>This module provides the abstract base class for all 3D finite element transformations. It defines the interface for mapping between reference and physical coordinates in  three-dimensional finite element analysis.</p> <p>Classes:</p> Name Description <code>FETransformation3D</code> <p>Abstract base class for 3D finite element transformations</p> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Abstract interface for 3D coordinate transformations</li> <li>Reference to physical domain mapping</li> <li>3D Jacobian matrix computation</li> <li>Support for different 3D element geometries</li> <li>Cell geometry specification interface</li> <li>Systematic transformation validation</li> <li>Three-dimensional coordinate mapping (xi, eta, zeta)</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> References <p>None</p>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D","title":"<code>FETransforamtion3D</code>","text":"<p>A base class for 3D finite element transformations.</p> <p>This abstract class defines the interface for mapping between reference and physical coordinates in 3D finite element analysis. Implementations must provide specific transformation rules for different three-dimensional element types.</p> <p>Methods:</p> Name Description <code>set_cell</code> <p>Sets the physical coordinates of the element vertices. Must be implemented by derived classes.</p> <code>get_original_from_ref</code> <p>Maps coordinates from reference to physical domain. Must be implemented by derived classes. Args: xi, eta, zeta - Reference coordinates Returns: (x, y, z) physical coordinates</p> <code>get_jacobian</code> <p>Computes the Jacobian matrix of the transformation. Must be implemented by derived classes. Args: xi, eta, zeta - Reference coordinates Returns: determinant of the Jacobian at all the quadrature points</p> Example <p>class HexTransform(FETransformation3D): ...     def set_cell(self, vertices): ...         self.vertices = vertices ...     def get_original_from_ref(self, xi, eta, zeta): ...         # Implementation for hexahedral element ...         pass ...     def get_jacobian(self, xi, eta, zeta): ...         # Implementation for hexahedral element ...         pass</p> Notes <ul> <li>Reference domain is typically [-1,1] \u00d7 [-1,1] \u00d7 [-1,1]</li> <li>Transformations must be invertible</li> <li>Implementations should handle element distortion</li> <li>Jacobian is used for both mapping and integration</li> <li>Coordinate order is consistently (xi, eta, zeta) -&gt; (x, y, z)</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>class FETransforamtion3D:  # pragma: no cover\n    \"\"\"\n    A base class for 3D finite element transformations.\n\n    This abstract class defines the interface for mapping between reference and physical\n    coordinates in 3D finite element analysis. Implementations must provide specific\n    transformation rules for different three-dimensional element types.\n\n    Attributes:\n        None\n\n    Methods:\n        set_cell():\n            Sets the physical coordinates of the element vertices.\n            Must be implemented by derived classes.\n\n        get_original_from_ref(xi, eta, zeta):\n            Maps coordinates from reference to physical domain.\n            Must be implemented by derived classes.\n            Args: xi, eta, zeta - Reference coordinates\n            Returns: (x, y, z) physical coordinates\n\n        get_jacobian(xi, eta, zeta):\n            Computes the Jacobian matrix of the transformation.\n            Must be implemented by derived classes.\n            Args: xi, eta, zeta - Reference coordinates\n            Returns: determinant of the Jacobian at all the quadrature points\n\n    Example:\n        &gt;&gt;&gt; class HexTransform(FETransformation3D):\n        ...     def set_cell(self, vertices):\n        ...         self.vertices = vertices\n        ...     def get_original_from_ref(self, xi, eta, zeta):\n        ...         # Implementation for hexahedral element\n        ...         pass\n        ...     def get_jacobian(self, xi, eta, zeta):\n        ...         # Implementation for hexahedral element\n        ...         pass\n\n    Notes:\n        - Reference domain is typically [-1,1] \u00d7 [-1,1] \u00d7 [-1,1]\n        - Transformations must be invertible\n        - Implementations should handle element distortion\n        - Jacobian is used for both mapping and integration\n        - Coordinate order is consistently (xi, eta, zeta) -&gt; (x, y, z)\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the FETransformation3D class.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_cell(self):\n        \"\"\"\n        Set the cell co-ordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(\n        self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_original_from_ref(\n        self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original co-ordinates from the reference co-ordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original co-ordinates from the reference co-ordinates.\n        \"\"\"\n\n    @abstractmethod\n    def get_jacobian(\n        self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n            zeta (np.ndarray): The zeta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the FETransformation3D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for the FETransformation3D class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.get_jacobian","title":"<code>get_jacobian(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>@abstractmethod\ndef get_jacobian(\n    self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta, zeta)</code>  <code>abstractmethod</code>","text":"<p>This method returns the original co-ordinates from the reference co-ordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <code>zeta</code> <code>ndarray</code> <p>The zeta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original co-ordinates from the reference co-ordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>@abstractmethod\ndef get_original_from_ref(\n    self, xi: np.ndarray, eta: np.ndarray, zeta: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original co-ordinates from the reference co-ordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n        zeta (np.ndarray): The zeta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original co-ordinates from the reference co-ordinates.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fe_transformation_3d/#scirex.core.sciml.fe.fe_transformation_3d.FETransforamtion3D.set_cell","title":"<code>set_cell()</code>  <code>abstractmethod</code>","text":"<p>Set the cell co-ordinates, which will be used to calculate the Jacobian and actual values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fe_transformation_3d.py</code> <pre><code>@abstractmethod\ndef set_cell(self):\n    \"\"\"\n    Set the cell co-ordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/","title":"fespace","text":"<p>Module: fespace.py</p> <p>This module provides abstract base functionality for finite element space  implementations, defining core interfaces for fe computations and analysis.</p> <p>Classes:</p> Name Description <code>Fespace</code> <p>Abstract base class for finite element space implementations</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>abc: For abstract base class functionality</li> </ul> Key Features <ul> <li>Mesh handling and cell management</li> <li>Shape function evaluation and manipulation</li> <li>Boundary condition implementation<ul> <li>Dirichlet boundary handling</li> <li>Boundary function management</li> </ul> </li> <li>Quadrature point management</li> <li>Forcing function integration</li> <li>Sensor data handling for inverse problems</li> <li>Reference and physical space transformations</li> <li>Gradient computation in both spaces</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p> Notes <p>This module serves as the foundation for specific finite element space implementations. It defines the minimum interface required for fe computations while allowing flexibility in concrete implementations.</p>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace","title":"<code>Fespace</code>","text":"<p>Abstract base class defining the interface for finite element spaces.</p> <p>This class provides the foundation for implementing finite element spaces, including mesh handling, element operations, and solution computations.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <p>Mesh object containing geometric information</p> <code>cells</code> <code>ndarray</code> <p>Array of cell indices</p> <code>boundary_points</code> <code>dict</code> <p>Dictionary of boundary point information</p> <code>cell_type</code> <code>str</code> <p>Type of finite element cell</p> <code>fe_order</code> <code>int</code> <p>Order of finite element approximation</p> <code>fe_type</code> <code>str</code> <p>Type of finite element basis</p> <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> <code>quad_type</code> <code>str</code> <p>Type of quadrature formula</p> <code>fe_transformation_type</code> <code>str</code> <p>Type of geometric transformation</p> <code>bound_function_dict</code> <code>dict</code> <p>Dictionary of boundary condition functions</p> <code>bound_condition_dict</code> <code>dict</code> <p>Dictionary of boundary condition types</p> <code>forcing_function</code> <code>callable</code> <p>Source term function</p> <code>output_path</code> <code>str</code> <p>Path for output files</p> Example <p>class MyFespace(Fespace): ...     def set_finite_elements(self): ...         # Implementation ...         pass ...     def generate_dirichlet_boundary_data(self): ...         # Implementation ...         pass ...     # Implement other abstract methods</p> Notes <ul> <li>All coordinate transformations must be implemented</li> <li>Shape function values and gradients are available in both reference and physical spaces</li> <li>Supports both internal and external sensor data for inverse problems</li> <li>Boundary conditions must be properly specified through the boundary dictionaries</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>class Fespace:\n    \"\"\"\n    Abstract base class defining the interface for finite element spaces.\n\n    This class provides the foundation for implementing finite element spaces,\n    including mesh handling, element operations, and solution computations.\n\n    Attributes:\n        mesh: Mesh object containing geometric information\n        cells (ndarray): Array of cell indices\n        boundary_points (dict): Dictionary of boundary point information\n        cell_type (str): Type of finite element cell\n        fe_order (int): Order of finite element approximation\n        fe_type (str): Type of finite element basis\n        quad_order (int): Order of quadrature rule\n        quad_type (str): Type of quadrature formula\n        fe_transformation_type (str): Type of geometric transformation\n        bound_function_dict (dict): Dictionary of boundary condition functions\n        bound_condition_dict (dict): Dictionary of boundary condition types\n        forcing_function (callable): Source term function\n        output_path (str): Path for output files\n\n    Example:\n        &gt;&gt;&gt; class MyFespace(Fespace):\n        ...     def set_finite_elements(self):\n        ...         # Implementation\n        ...         pass\n        ...     def generate_dirichlet_boundary_data(self):\n        ...         # Implementation\n        ...         pass\n        ...     # Implement other abstract methods\n\n    Notes:\n        - All coordinate transformations must be implemented\n        - Shape function values and gradients are available in both\n        reference and physical spaces\n        - Supports both internal and external sensor data for\n        inverse problems\n        - Boundary conditions must be properly specified through\n        the boundary dictionaries\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n\n        Args:\n            mesh: The mesh object.\n            cells: The cells of the mesh.\n            boundary_points: The boundary points of the mesh.\n            cell_type: The type of the cell.\n            fe_order: The order of the finite element.\n            fe_type: The type of the finite element.\n            quad_order: The order of the quadrature.\n            quad_type: The type of the quadrature.\n            fe_transformation_type: The type of the finite element transformation.\n            bound_function_dict: The dictionary of the boundary functions.\n            bound_condition_dict: The dictionary of the boundary conditions.\n            forcing_function: The forcing function.\n            output_path: The path to the output directory.\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh = mesh\n        self.boundary_points = boundary_points\n        self.cells = cells\n        self.cell_type = cell_type\n        self.fe_order = fe_order\n        self.fe_type = fe_type\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n\n        self.fe_transformation_type = fe_transformation_type\n        self.output_path = output_path\n        self.bound_function_dict = bound_function_dict\n        self.bound_condition_dict = bound_condition_dict\n        self.forcing_function = forcing_function\n\n    @abstractmethod\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data.\n\n        This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            np.ndarray: The boundary points and their values.\n\n        Notes:\n            The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual values of the shape functions.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n\n    @abstractmethod\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n\n    @abstractmethod\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Notes:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n            object.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        Args:\n            exact_solution (ndarray): The exact solution values.\n            num_points (int): The number of points to sample from the domain.\n\n        Returns:\n            np.ndarray: The sensor data at the given points.\n\n        Notes:\n            This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n            Methodologies to obtain sensor data for problems from a file are not implemented yet.\n            It is also not implemented for external or complex meshes.\n        \"\"\"\n\n    @abstractmethod\n    def get_sensor_data_external(\n        self, exact_sol, num_points: int, file_name: str\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n        Args:\n            exact_sol: The exact solution values.\n            num_points: The number of points to sample from the domain.\n            file_name: The name of the file containing the sensor data.\n\n        Returns:\n            np.ndarray: The sensor data at the given points based on the external file.\n\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path)</code>","text":"<p>The constructor of the Fespace2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <p>The mesh object.</p> required <code>cells</code> <p>The cells of the mesh.</p> required <code>boundary_points</code> <p>The boundary points of the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell.</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element.</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature.</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation.</p> required <code>bound_function_dict</code> <code>dict</code> <p>The dictionary of the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>The dictionary of the boundary conditions.</p> required <code>forcing_function</code> <p>The forcing function.</p> required <code>output_path</code> <code>str</code> <p>The path to the output directory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n\n    Args:\n        mesh: The mesh object.\n        cells: The cells of the mesh.\n        boundary_points: The boundary points of the mesh.\n        cell_type: The type of the cell.\n        fe_order: The order of the finite element.\n        fe_type: The type of the finite element.\n        quad_order: The order of the quadrature.\n        quad_type: The type of the quadrature.\n        fe_transformation_type: The type of the finite element transformation.\n        bound_function_dict: The dictionary of the boundary functions.\n        bound_condition_dict: The dictionary of the boundary conditions.\n        forcing_function: The forcing function.\n        output_path: The path to the output directory.\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh = mesh\n    self.boundary_points = boundary_points\n    self.cells = cells\n    self.cell_type = cell_type\n    self.fe_order = fe_order\n    self.fe_type = fe_type\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n\n    self.fe_transformation_type = fe_transformation_type\n    self.output_path = output_path\n    self.bound_function_dict = bound_function_dict\n    self.bound_condition_dict = bound_condition_dict\n    self.forcing_function = forcing_function\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>  <code>abstractmethod</code>","text":"<p>Generate Dirichlet boundary data.</p> <p>This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The boundary points and their values.</p> Notes <p>The boundary points and values are stored in the <code>boundary_points</code> attribute of the <code>Fespace</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data.\n\n    This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        np.ndarray: The boundary points and their values.\n\n    Notes:\n        The boundary points and values are stored in the `boundary_points` attribute of the `Fespace` object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object. The forcing function is evaluated using the <code>forcing_function</code> method of the <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object. The forcing function is evaluated using the `forcing_function` method of the `fe_cell`\n        object.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>  <code>abstractmethod</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>ndarray</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points.</p> Notes <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data(self, exact_solution, num_points: int) -&gt; np.ndarray:\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    Args:\n        exact_solution (ndarray): The exact solution values.\n        num_points (int): The number of points to sample from the domain.\n\n    Returns:\n        np.ndarray: The sensor data at the given points.\n\n    Notes:\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>  <code>abstractmethod</code>","text":"<p>This method is used to obtain the sensor data from an external file when there is no analytical solution available.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <p>The exact solution values.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample from the domain.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sensor data at the given points based on the external file.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_sensor_data_external(\n    self, exact_sol, num_points: int, file_name: str\n) -&gt; np.ndarray:\n    \"\"\"\n    This method is used to obtain the sensor data from an external file when there is no analytical solution available.\n\n    Args:\n        exact_sol: The exact solution values.\n        num_points: The number of points to sample from the domain.\n        file_name: The name of the file containing the sensor data.\n\n    Returns:\n        np.ndarray: The sensor data at the given points based on the external file.\n\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the gradient of the shape function with respect to y.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Notes <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the gradient of the shape function with respect to y at the reference element.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Notes:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>  <code>abstractmethod</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual values of the shape functions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual values of the shape functions.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace/#scirex.core.sciml.fe.fespace.Fespace.set_finite_elements","title":"<code>set_finite_elements()</code>  <code>abstractmethod</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace.py</code> <pre><code>@abstractmethod\ndef set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/","title":"fespace2d","text":"<p>Finite Element Space Implementation for 2D Problems.</p> <p>This module implements finite element space functionality for 2D domains, providing a framework for handling mesh elements, boundary conditions, and numerical integration.</p> Key classes <ul> <li>Fespace2D: Main class for managing 2D finite element spaces</li> <li>FE2D_Cell: Implementation of individual finite element cells</li> </ul> Key functionalities <ul> <li>Finite element space construction and management</li> <li>Boundary condition handling (Dirichlet)</li> <li>Shape function and gradient computations</li> <li>Quadrature point and weight management</li> <li>Forcing function evaluation</li> <li>Sensor data generation for inverse problems</li> </ul> The implementation supports <ul> <li>Various element types (currently focused on quadrilateral elements)</li> <li>Different orders of finite elements</li> <li>Custom quadrature rules</li> <li>Multiple boundary conditions</li> <li>Forcing function integration</li> <li>Mesh visualization</li> </ul> Note <p>Triangle mesh support is currently not implemented.</p> Dependencies <ul> <li>numpy: For numerical computations</li> <li>meshio: For mesh handling</li> <li>matplotlib: For visualization</li> <li>tensorflow: For optimization tasks</li> <li>pyDOE: For Latin Hypercube Sampling</li> <li>pandas: For data handling</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D","title":"<code>Fespace2D</code>","text":"<p>               Bases: <code>Fespace</code></p> <p>Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces, including mesh generation, basis function evaluation, and boundary condition handling.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh object containing the mesh information.</p> required <code>cells</code> <code>ndarray</code> <p>The cell information from the mesh.</p> required <code>boundary_points</code> <code>dict</code> <p>The boundary points information from the mesh.</p> required <code>cell_type</code> <code>str</code> <p>The type of the cell (e.g., 'quadrilateral').</p> required <code>fe_order</code> <code>int</code> <p>The order of the finite element basis functions.</p> required <code>fe_type</code> <code>str</code> <p>The type of the finite element basis functions (e.g., 'legendre').</p> required <code>quad_order</code> <code>int</code> <p>The order of the quadrature rule.</p> required <code>quad_type</code> <code>str</code> <p>The type of the quadrature rule (e.g., 'gauss-legendre').</p> required <code>fe_transformation_type</code> <code>str</code> <p>The type of the finite element transformation (e.g., 'affine').</p> required <code>bound_function_dict</code> <code>dict</code> <p>A dictionary containing the boundary functions.</p> required <code>bound_condition_dict</code> <code>dict</code> <p>A dictionary containing the boundary conditions.</p> required <code>forcing_function</code> <code>function</code> <p>The forcing function for the problem.</p> required <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <code>generate_mesh_plot</code> <code>bool</code> <p>Flag to generate the mesh plot (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell type is not supported.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>class Fespace2D(Fespace):\n    \"\"\"\n    Represents a finite element space in 2D. This class provides functionality for handling 2D finite element spaces,\n    including mesh generation, basis function evaluation, and boundary condition handling.\n\n    Args:\n        mesh (meshio.Mesh): The mesh object containing the mesh information.\n        cells (np.ndarray): The cell information from the mesh.\n        boundary_points (dict): The boundary points information from the mesh.\n        cell_type (str): The type of the cell (e.g., 'quadrilateral').\n        fe_order (int): The order of the finite element basis functions.\n        fe_type (str): The type of the finite element basis functions (e.g., 'legendre').\n        quad_order (int): The order of the quadrature rule.\n        quad_type (str): The type of the quadrature rule (e.g., 'gauss-legendre').\n        fe_transformation_type (str): The type of the finite element transformation (e.g., 'affine').\n        bound_function_dict (dict): A dictionary containing the boundary functions.\n        bound_condition_dict (dict): A dictionary containing the boundary conditions.\n        forcing_function (function): The forcing function for the problem.\n        output_path (str): The path to save the output files.\n        generate_mesh_plot (bool): Flag to generate the mesh plot (default: False).\n\n    Raises:\n        ValueError: If the cell type is not supported.\n\n    Returns:\n        None\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh,\n        cells,\n        boundary_points,\n        cell_type: str,\n        fe_order: int,\n        fe_type: str,\n        quad_order: int,\n        quad_type: str,\n        fe_transformation_type: str,\n        bound_function_dict: dict,\n        bound_condition_dict: dict,\n        forcing_function,\n        output_path: str,\n        generate_mesh_plot: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        The constructor of the Fespace2D class.\n        \"\"\"\n        # call the constructor of the parent class\n        super().__init__(\n            mesh=mesh,\n            cells=cells,\n            boundary_points=boundary_points,\n            cell_type=cell_type,\n            fe_order=fe_order,\n            fe_type=fe_type,\n            quad_order=quad_order,\n            quad_type=quad_type,\n            fe_transformation_type=fe_transformation_type,\n            bound_function_dict=bound_function_dict,\n            bound_condition_dict=bound_condition_dict,\n            forcing_function=forcing_function,\n            output_path=output_path,\n        )\n\n        if self.cell_type == \"triangle\":\n            raise ValueError(\n                \"Triangle Mesh is not supported yet\"\n            )  # added by thivin - to remove support for triangular mesh\n\n        self.generate_mesh_plot = generate_mesh_plot\n\n        # to be calculated in the plot function\n        self.total_dofs = 0\n        self.total_boundary_dofs = 0\n\n        # to be calculated on get_boundary_data_dirichlet function\n        self.total_dirichlet_dofs = 0\n\n        # get the number of cells\n        self.n_cells = self.cells.shape[0]\n\n        self.fe_cell = []\n\n        # Function which assigns the fe_cell for each cell\n        self.set_finite_elements()\n\n        # generate the plot of the mesh\n        if self.generate_mesh_plot:\n            self.generate_plot(self.output_path)\n        # self.generate_plot(self.output_path)\n\n        # Obtain boundary Data\n        self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n        title = [\n            \"Number of Cells\",\n            \"Number of Quadrature Points\",\n            \"Number of Dirichlet Boundary Points\",\n            \"Quadrature Order\",\n            \"fe Order\",\n            \"fe Type\",\n            \"fe Transformation Type\",\n        ]\n        values = [\n            self.n_cells,\n            self.total_dofs,\n            self.total_dirichlet_dofs,\n            self.quad_order,\n            self.fe_order,\n            self.fe_type,\n            self.fe_transformation_type,\n        ]\n        # print the table\n        print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n\n    def set_finite_elements(self) -&gt; None:\n        \"\"\"\n        Assigns the finite elements to each cell.\n\n        This method initializes the finite element objects for each cell in the mesh.\n        It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n        The finite element objects store information about the basis functions, gradients, Jacobians,\n        quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n        After initializing the finite element objects, this method prints the shape details of various matrices\n        and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n        :return: None\n        \"\"\"\n        progress_bar = tqdm(\n            total=self.n_cells,\n            desc=\"Fe2D_cell Setup\",\n            unit=\"cells_assembled\",\n            bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n            colour=\"blue\",\n            ncols=100,\n        )\n\n        dof = 0\n        for i in range(self.n_cells):\n            self.fe_cell.append(\n                FE2D_Cell(\n                    self.cells[i],\n                    self.cell_type,\n                    self.fe_order,\n                    self.fe_type,\n                    self.quad_order,\n                    self.quad_type,\n                    self.fe_transformation_type,\n                    self.forcing_function,\n                )\n            )\n\n            # obtain the shape of the basis function (n_test, N_quad)\n            dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n            progress_bar.update(1)\n        # print the Shape details of all the matrices from cell 0 using print_table function\n        title = [\n            \"Shape function Matrix Shape\",\n            \"Shape function Gradient Matrix Shape\",\n            \"Jacobian Matrix Shape\",\n            \"Quadrature Points Shape\",\n            \"Quadrature Weights Shape\",\n            \"Quadrature Actual Coordinates Shape\",\n            \"Forcing Function Shape\",\n        ]\n        values = [\n            self.fe_cell[0].basis_at_quad.shape,\n            self.fe_cell[0].basis_gradx_at_quad.shape,\n            self.fe_cell[0].jacobian.shape,\n            self.fe_cell[0].quad_xi.shape,\n            self.fe_cell[0].quad_weight.shape,\n            self.fe_cell[0].quad_actual_coordinates.shape,\n            self.fe_cell[0].forcing_at_quad.shape,\n        ]\n        print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n        # update the total number of dofs\n        self.total_dofs = dof\n\n    def generate_plot(self, output_path) -&gt; None:\n        \"\"\"\n        Generate a plot of the mesh.\n\n        Args:\n            output_path (str): The path to save the output files.\n\n        Returns:\n            None\n        \"\"\"\n        total_quad = 0\n        marker_list = [\n            \"o\",\n            \".\",\n            \",\",\n            \"x\",\n            \"+\",\n            \"P\",\n            \"s\",\n            \"D\",\n            \"d\",\n            \"^\",\n            \"v\",\n            \"&lt;\",\n            \"&gt;\",\n            \"p\",\n            \"h\",\n            \"H\",\n        ]\n\n        print(f\"[INFO] : Generating the plot of the mesh\")\n        # Plot the mesh\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # label flag ( to add the label only once)\n        label_set = False\n\n        # plot every cell as a quadrilateral\n        # loop over all the cells\n        for i in range(self.n_cells):\n            # get the coordinates of the cell\n            x = self.fe_cell[i].cell_coordinates[:, 0]\n            y = self.fe_cell[i].cell_coordinates[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            plt.plot(x, y, \"k-\", linewidth=0.5)\n\n            # plot the quadrature points\n            x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n            y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n            total_quad += x_quad.shape[0]\n\n            if not label_set:\n                plt.scatter(\n                    x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n                )\n                label_set = True\n            else:\n                plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n        self.total_dofs = total_quad\n\n        bound_dof = 0\n        # plot the boundary points\n        # loop over all the boundary tags\n        for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n            # get the coordinates of the boundary points\n            x = bound_pts[:, 0]\n            y = bound_pts[:, 1]\n\n            # add the first point to the end of the array\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            bound_dof += x.shape[0]\n\n            plt.scatter(\n                x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n            )\n\n        self.total_boundary_dofs = bound_dof\n\n        plt.legend(bbox_to_anchor=(0.85, 1.02))\n        plt.axis(\"equal\")\n        plt.axis(\"off\")\n        plt.tight_layout()\n\n        plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n        plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n        # print the total number of quadrature points\n        print(f\"Plots generated\")\n        print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n        print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n        print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n\n    def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n        \"\"\"\n        Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n                ).reshape(-1, 1)\n                y.append(val)\n\n        print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n        self.total_dirichlet_dofs = len(x)\n        print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n        print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n        return x, y\n\n    def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n        \"\"\"\n        Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n        Args:\n            component (int): The component of the boundary data vector.\n\n        Returns:\n            tuple: The boundary points and their values as numpy arrays.\n        \"\"\"\n        x = []\n        y = []\n        for bound_id, bound_pts in self.boundary_points.items():\n            # get the coordinates of the boundary points\n            for pt in bound_pts:\n                pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n                x.append(pt_new)\n                val = np.array(\n                    self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                    dtype=np.float64,\n                ).reshape(-1, 1)\n                y.append(val)\n\n        return x, y\n\n    def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual values of the shape functions on a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_at_quad.copy()\n\n    def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n\n    def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n\n    def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the given cell index.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n\n    def get_shape_function_grad_y_ref(self, cell_index: int):\n        \"\"\"\n        Get the gradient of the shape function with respect to y at the reference element.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The actual values of the shape functions on the given cell.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function returns the gradient of the shape function with respect to y at the reference element\n            for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n            of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n            for which the shape function gradient is required. If the `cell_index` is greater than the total number\n            of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n\n    def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the actual coordinates of the quadrature points for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n\n    def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Return the quadrature weights for a given cell.\n\n        Args:\n            cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n        Returns:\n            np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n        Raises:\n            ValueError: If cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        return self.fe_cell[cell_index].mult.copy()\n\n    def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get the forcing function values at the quadrature points.\n\n        Args:\n            cell_index (int): The index of the cell.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n\n        Note:\n            This function computes the forcing function values at the quadrature points for a given cell.\n            It loops over all the basis functions and computes the integral using the actual coordinates\n            and the basis functions at the quadrature points. The resulting values are stored in the\n            `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n        # so that it can be used to handle multiple dimensions on a vector valud problem\n\n        # get number of shape functions\n        n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n        # Loop over all the basis functions and compute the integral\n        f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n        for i in range(n_shape_functions):\n            val = 0\n            for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n                x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n                y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n                # print(\"f_values[q] = \",f_values[q])\n\n                # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n                val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                    cell_index\n                ].forcing_function(x, y)\n                # print(\"val = \", val)\n\n            f_integral[i] = val\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_forcing_function_values_vector(\n        self, cell_index: int, component: int\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This function will return the forcing function values at the quadrature points\n        based on the Component of the RHS Needed, for vector valued problems\n\n        Args:\n            cell_index (int): The index of the cell.\n            component (int): The component of the forcing function.\n\n        Returns:\n            np.ndarray: The forcing function values at the quadrature points.\n\n        Raises:\n            ValueError: If the cell_index is greater than the number of cells.\n        \"\"\"\n        if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n            raise ValueError(\n                f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n            )\n\n        # get the coordinates\n        x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n        y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n        # compute the forcing function values\n        f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n        # compute the integral\n        f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n        self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n        return self.fe_cell[cell_index].forcing_at_quad.copy()\n\n    def get_sensor_data(self, exact_solution, num_points: int):\n        \"\"\"\n        Obtain sensor data (actual solution) at random points.\n\n        This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n        Currently, it only works for problems with an analytical solution.\n        Methodologies to obtain sensor data for problems from a file are not implemented yet.\n        It is also not implemented for external or complex meshes.\n\n        Args:\n            exact_solution (function): The exact solution function.\n            num_points (int): The number of points to sample.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n        \"\"\"\n        # generate random points within the bounds of the domain\n        # get the bounds of the domain\n        x_min = np.min(self.mesh.points[:, 0])\n        x_max = np.max(self.mesh.points[:, 0])\n        y_min = np.min(self.mesh.points[:, 1])\n        y_max = np.max(self.mesh.points[:, 1])\n        # sample n random points within the bounds of the domain\n        # Generate points in the unit square\n\n        num_internal_points = int(num_points * 0.9)\n\n        points = lhs(2, samples=num_internal_points)\n        points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n        points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n        # get the exact solution at the points\n        exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n        # print the shape of the points and the exact solution\n        print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n        print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n        # plot the points\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n        plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n        plt.axis(\"equal\")\n        plt.title(\"Sensor Points\")\n        plt.tight_layout()\n        plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n        return points, exact_sol\n\n    def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n        \"\"\"\n        This method is used to obtain the sensor data from an external file.\n\n        Args:\n            exact_sol (function): The exact solution function.\n            num_points (int): The number of points to sample.\n            file_name (str): The name of the file containing the sensor data.\n\n        Returns:\n            Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n        Note:\n            This method reads the sensor data from a file and samples `num_points` from the data.\n            The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n        \"\"\"\n        # use pandas to read the file\n        df = pd.read_csv(file_name)\n\n        x = df.iloc[:, 0].values\n        y = df.iloc[:, 1].values\n        exact_sol = df.iloc[:, 2].values\n\n        # now sample num_points from the data\n        indices = np.random.randint(0, x.shape[0], num_points)\n\n        x = x[indices]\n        y = y[indices]\n        exact_sol = exact_sol[indices]\n\n        # stack them together\n        points = np.stack((x, y), axis=1)\n\n        return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.__init__","title":"<code>__init__(mesh, cells, boundary_points, cell_type, fe_order, fe_type, quad_order, quad_type, fe_transformation_type, bound_function_dict, bound_condition_dict, forcing_function, output_path, generate_mesh_plot=False)</code>","text":"<p>The constructor of the Fespace2D class.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def __init__(\n    self,\n    mesh,\n    cells,\n    boundary_points,\n    cell_type: str,\n    fe_order: int,\n    fe_type: str,\n    quad_order: int,\n    quad_type: str,\n    fe_transformation_type: str,\n    bound_function_dict: dict,\n    bound_condition_dict: dict,\n    forcing_function,\n    output_path: str,\n    generate_mesh_plot: bool = False,\n) -&gt; None:\n    \"\"\"\n    The constructor of the Fespace2D class.\n    \"\"\"\n    # call the constructor of the parent class\n    super().__init__(\n        mesh=mesh,\n        cells=cells,\n        boundary_points=boundary_points,\n        cell_type=cell_type,\n        fe_order=fe_order,\n        fe_type=fe_type,\n        quad_order=quad_order,\n        quad_type=quad_type,\n        fe_transformation_type=fe_transformation_type,\n        bound_function_dict=bound_function_dict,\n        bound_condition_dict=bound_condition_dict,\n        forcing_function=forcing_function,\n        output_path=output_path,\n    )\n\n    if self.cell_type == \"triangle\":\n        raise ValueError(\n            \"Triangle Mesh is not supported yet\"\n        )  # added by thivin - to remove support for triangular mesh\n\n    self.generate_mesh_plot = generate_mesh_plot\n\n    # to be calculated in the plot function\n    self.total_dofs = 0\n    self.total_boundary_dofs = 0\n\n    # to be calculated on get_boundary_data_dirichlet function\n    self.total_dirichlet_dofs = 0\n\n    # get the number of cells\n    self.n_cells = self.cells.shape[0]\n\n    self.fe_cell = []\n\n    # Function which assigns the fe_cell for each cell\n    self.set_finite_elements()\n\n    # generate the plot of the mesh\n    if self.generate_mesh_plot:\n        self.generate_plot(self.output_path)\n    # self.generate_plot(self.output_path)\n\n    # Obtain boundary Data\n    self.dirichlet_boundary_data = self.generate_dirichlet_boundary_data()\n\n    title = [\n        \"Number of Cells\",\n        \"Number of Quadrature Points\",\n        \"Number of Dirichlet Boundary Points\",\n        \"Quadrature Order\",\n        \"fe Order\",\n        \"fe Type\",\n        \"fe Transformation Type\",\n    ]\n    values = [\n        self.n_cells,\n        self.total_dofs,\n        self.total_dirichlet_dofs,\n        self.quad_order,\n        self.fe_order,\n        self.fe_type,\n        self.fe_transformation_type,\n    ]\n    # print the table\n    print_table(\"fe Space Information\", [\"Property\", \"Value\"], title, values)\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.generate_dirichlet_boundary_data","title":"<code>generate_dirichlet_boundary_data()</code>","text":"<p>Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data(self) -&gt; np.ndarray:\n    \"\"\"\n    Generate Dirichlet boundary data. This function returns the boundary points and their corresponding values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1]), dtype=np.float64\n            ).reshape(-1, 1)\n            y.append(val)\n\n    print(f\"[INFO] : Total number of Dirichlet boundary points = {len(x)}\")\n    self.total_dirichlet_dofs = len(x)\n    print(f\"[INFO] : Shape of Dirichlet-X = {np.array(x).shape}\")\n    print(f\"[INFO] : Shape of Y = {np.array(y).shape}\")\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.generate_dirichlet_boundary_data_vector","title":"<code>generate_dirichlet_boundary_data_vector(component)</code>","text":"<p>Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>int</code> <p>The component of the boundary data vector.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>The boundary points and their values as numpy arrays.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_dirichlet_boundary_data_vector(self, component: int) -&gt; np.ndarray:\n    \"\"\"\n    Generate the boundary data vector for the Dirichlet boundary condition. This function returns the boundary points and their corresponding values for a specific component.\n\n    Args:\n        component (int): The component of the boundary data vector.\n\n    Returns:\n        tuple: The boundary points and their values as numpy arrays.\n    \"\"\"\n    x = []\n    y = []\n    for bound_id, bound_pts in self.boundary_points.items():\n        # get the coordinates of the boundary points\n        for pt in bound_pts:\n            pt_new = np.array([pt[0], pt[1]], dtype=np.float64)\n            x.append(pt_new)\n            val = np.array(\n                self.bound_function_dict[bound_id](pt[0], pt[1])[component],\n                dtype=np.float64,\n            ).reshape(-1, 1)\n            y.append(val)\n\n    return x, y\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.generate_plot","title":"<code>generate_plot(output_path)</code>","text":"<p>Generate a plot of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>The path to save the output files.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def generate_plot(self, output_path) -&gt; None:\n    \"\"\"\n    Generate a plot of the mesh.\n\n    Args:\n        output_path (str): The path to save the output files.\n\n    Returns:\n        None\n    \"\"\"\n    total_quad = 0\n    marker_list = [\n        \"o\",\n        \".\",\n        \",\",\n        \"x\",\n        \"+\",\n        \"P\",\n        \"s\",\n        \"D\",\n        \"d\",\n        \"^\",\n        \"v\",\n        \"&lt;\",\n        \"&gt;\",\n        \"p\",\n        \"h\",\n        \"H\",\n    ]\n\n    print(f\"[INFO] : Generating the plot of the mesh\")\n    # Plot the mesh\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # label flag ( to add the label only once)\n    label_set = False\n\n    # plot every cell as a quadrilateral\n    # loop over all the cells\n    for i in range(self.n_cells):\n        # get the coordinates of the cell\n        x = self.fe_cell[i].cell_coordinates[:, 0]\n        y = self.fe_cell[i].cell_coordinates[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        plt.plot(x, y, \"k-\", linewidth=0.5)\n\n        # plot the quadrature points\n        x_quad = self.fe_cell[i].quad_actual_coordinates[:, 0]\n        y_quad = self.fe_cell[i].quad_actual_coordinates[:, 1]\n\n        total_quad += x_quad.shape[0]\n\n        if not label_set:\n            plt.scatter(\n                x_quad, y_quad, marker=\"x\", color=\"b\", s=2, label=\"Quad Pts\"\n            )\n            label_set = True\n        else:\n            plt.scatter(x_quad, y_quad, marker=\"x\", color=\"b\", s=2)\n\n    self.total_dofs = total_quad\n\n    bound_dof = 0\n    # plot the boundary points\n    # loop over all the boundary tags\n    for i, (bound_id, bound_pts) in enumerate(self.boundary_points.items()):\n        # get the coordinates of the boundary points\n        x = bound_pts[:, 0]\n        y = bound_pts[:, 1]\n\n        # add the first point to the end of the array\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        bound_dof += x.shape[0]\n\n        plt.scatter(\n            x, y, marker=marker_list[i + 1], s=2, label=f\"Bd-id : {bound_id}\"\n        )\n\n    self.total_boundary_dofs = bound_dof\n\n    plt.legend(bbox_to_anchor=(0.85, 1.02))\n    plt.axis(\"equal\")\n    plt.axis(\"off\")\n    plt.tight_layout()\n\n    plt.savefig(str(Path(output_path) / \"mesh.png\"), bbox_inches=\"tight\")\n    plt.savefig(str(Path(output_path) / \"mesh.svg\"), bbox_inches=\"tight\")\n\n    # print the total number of quadrature points\n    print(f\"Plots generated\")\n    print(f\"[INFO] : Total number of cells = {self.n_cells}\")\n    print(f\"[INFO] : Total number of quadrature points = {self.total_dofs}\")\n    print(f\"[INFO] : Total number of boundary points = {self.total_boundary_dofs}\")\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_forcing_function_values","title":"<code>get_forcing_function_values(cell_index)</code>","text":"<p>Get the forcing function values at the quadrature points.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function computes the forcing function values at the quadrature points for a given cell. It loops over all the basis functions and computes the integral using the actual coordinates and the basis functions at the quadrature points. The resulting values are stored in the <code>forcing_at_quad</code> attribute of the corresponding <code>fe_cell</code> object.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the forcing function values at the quadrature points.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function computes the forcing function values at the quadrature points for a given cell.\n        It loops over all the basis functions and computes the integral using the actual coordinates\n        and the basis functions at the quadrature points. The resulting values are stored in the\n        `forcing_at_quad` attribute of the corresponding `fe_cell` object.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # Changed by Thivin: To assemble the forcing function at the quadrature points here in the fespace\n    # so that it can be used to handle multiple dimensions on a vector valud problem\n\n    # get number of shape functions\n    n_shape_functions = self.fe_cell[cell_index].basis_function.num_shape_functions\n\n    # Loop over all the basis functions and compute the integral\n    f_integral = np.zeros((n_shape_functions, 1), dtype=np.float64)\n\n    for i in range(n_shape_functions):\n        val = 0\n        for q in range(self.fe_cell[cell_index].basis_at_quad.shape[1]):\n            x = self.fe_cell[cell_index].quad_actual_coordinates[q, 0]\n            y = self.fe_cell[cell_index].quad_actual_coordinates[q, 1]\n            # print(\"f_values[q] = \",f_values[q])\n\n            # the Jacobian and the quadrature weights are pre multiplied to the basis functions\n            val += (self.fe_cell[cell_index].basis_at_quad[i, q]) * self.fe_cell[\n                cell_index\n            ].forcing_function(x, y)\n            # print(\"val = \", val)\n\n        f_integral[i] = val\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_forcing_function_values_vector","title":"<code>get_forcing_function_values_vector(cell_index, component)</code>","text":"<p>This function will return the forcing function values at the quadrature points based on the Component of the RHS Needed, for vector valued problems</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <code>component</code> <code>int</code> <p>The component of the forcing function.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The forcing function values at the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_forcing_function_values_vector(\n    self, cell_index: int, component: int\n) -&gt; np.ndarray:\n    \"\"\"\n    This function will return the forcing function values at the quadrature points\n    based on the Component of the RHS Needed, for vector valued problems\n\n    Args:\n        cell_index (int): The index of the cell.\n        component (int): The component of the forcing function.\n\n    Returns:\n        np.ndarray: The forcing function values at the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    # get the coordinates\n    x = self.fe_cell[cell_index].quad_actual_coordinates[:, 0]\n    y = self.fe_cell[cell_index].quad_actual_coordinates[:, 1]\n\n    # compute the forcing function values\n    f_values = self.fe_cell[cell_index].forcing_function(x, y)[component]\n\n    # compute the integral\n    f_integral = np.sum(self.fe_cell[cell_index].basis_at_quad * f_values, axis=1)\n\n    self.fe_cell[cell_index].forcing_at_quad = f_integral.reshape(-1, 1)\n\n    return self.fe_cell[cell_index].forcing_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_quadrature_actual_coordinates","title":"<code>get_quadrature_actual_coordinates(cell_index)</code>","text":"<p>Get the actual coordinates of the quadrature points for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the actual coordinates of the quadrature points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_actual_coordinates(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual coordinates of the quadrature points for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: An array containing the actual coordinates of the quadrature points.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].quad_actual_coordinates.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_quadrature_weights","title":"<code>get_quadrature_weights(cell_index)</code>","text":"<p>Return the quadrature weights for a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell for which the quadrature weights are needed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_quadrature_weights(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Return the quadrature weights for a given cell.\n\n    Args:\n        cell_index (int): The index of the cell for which the quadrature weights are needed.\n\n    Returns:\n        np.ndarray: The quadrature weights for the given cell  of dimension (N_Quad_Points, 1).\n\n    Raises:\n        ValueError: If cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].mult.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_sensor_data","title":"<code>get_sensor_data(exact_solution, num_points)</code>","text":"<p>Obtain sensor data (actual solution) at random points.</p> <p>This method is used in the inverse problem to obtain the sensor data at random points within the domain. Currently, it only works for problems with an analytical solution. Methodologies to obtain sensor data for problems from a file are not implemented yet. It is also not implemented for external or complex meshes.</p> <p>Parameters:</p> Name Type Description Default <code>exact_solution</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data(self, exact_solution, num_points: int):\n    \"\"\"\n    Obtain sensor data (actual solution) at random points.\n\n    This method is used in the inverse problem to obtain the sensor data at random points within the domain.\n    Currently, it only works for problems with an analytical solution.\n    Methodologies to obtain sensor data for problems from a file are not implemented yet.\n    It is also not implemented for external or complex meshes.\n\n    Args:\n        exact_solution (function): The exact solution function.\n        num_points (int): The number of points to sample.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n    \"\"\"\n    # generate random points within the bounds of the domain\n    # get the bounds of the domain\n    x_min = np.min(self.mesh.points[:, 0])\n    x_max = np.max(self.mesh.points[:, 0])\n    y_min = np.min(self.mesh.points[:, 1])\n    y_max = np.max(self.mesh.points[:, 1])\n    # sample n random points within the bounds of the domain\n    # Generate points in the unit square\n\n    num_internal_points = int(num_points * 0.9)\n\n    points = lhs(2, samples=num_internal_points)\n    points[:, 0] = x_min + (x_max - x_min) * points[:, 0]\n    points[:, 1] = y_min + (y_max - y_min) * points[:, 1]\n    # get the exact solution at the points\n    exact_sol = exact_solution(points[:, 0], points[:, 1])\n\n    # print the shape of the points and the exact solution\n    print(f\"[INFO] : Number of sensor points = {points.shape[0]}\")\n    print(f\"[INFO] : Shape of sensor points = {points.shape}\")\n\n    # plot the points\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n    plt.scatter(points[:, 0], points[:, 1], marker=\"x\", color=\"r\", s=2)\n    plt.axis(\"equal\")\n    plt.title(\"Sensor Points\")\n    plt.tight_layout()\n    plt.savefig(\"sensor_points.png\", bbox_inches=\"tight\")\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_sensor_data_external","title":"<code>get_sensor_data_external(exact_sol, num_points, file_name)</code>","text":"<p>This method is used to obtain the sensor data from an external file.</p> <p>Parameters:</p> Name Type Description Default <code>exact_sol</code> <code>function</code> <p>The exact solution function.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample.</p> required <code>file_name</code> <code>str</code> <p>The name of the file containing the sensor data.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple containing two arrays: sensor points and the exact solution values.</p> Note <p>This method reads the sensor data from a file and samples <code>num_points</code> from the data. The sensor data is then returned as a tuple containing the sensor points and the exact solution values.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_sensor_data_external(self, exact_sol, num_points: int, file_name: str):\n    \"\"\"\n    This method is used to obtain the sensor data from an external file.\n\n    Args:\n        exact_sol (function): The exact solution function.\n        num_points (int): The number of points to sample.\n        file_name (str): The name of the file containing the sensor data.\n\n    Returns:\n        Tuple: A tuple containing two arrays: sensor points and the exact solution values.\n\n    Note:\n        This method reads the sensor data from a file and samples `num_points` from the data.\n        The sensor data is then returned as a tuple containing the sensor points and the exact solution values.\n    \"\"\"\n    # use pandas to read the file\n    df = pd.read_csv(file_name)\n\n    x = df.iloc[:, 0].values\n    y = df.iloc[:, 1].values\n    exact_sol = df.iloc[:, 2].values\n\n    # now sample num_points from the data\n    indices = np.random.randint(0, x.shape[0], num_points)\n\n    x = x[indices]\n    y = y[indices]\n    exact_sol = exact_sol[indices]\n\n    # stack them together\n    points = np.stack((x, y), axis=1)\n\n    return points, exact_sol\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_x","title":"<code>get_shape_function_grad_x(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_x_ref","title":"<code>get_shape_function_grad_x_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to the x-coordinate on the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_x_ref(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to the x-coordinate on the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_gradx_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_y","title":"<code>get_shape_function_grad_y(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the given cell index.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the given cell index.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_grad_y_ref","title":"<code>get_shape_function_grad_y_ref(cell_index)</code>","text":"<p>Get the gradient of the shape function with respect to y at the reference element.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Note <p>This function returns the gradient of the shape function with respect to y at the reference element for a given cell. The shape function gradient values are stored in the <code>basis_grady_at_quad_ref</code> array of the corresponding finite element cell. The <code>cell_index</code> parameter specifies the index of the cell for which the shape function gradient is required. If the <code>cell_index</code> is greater than the total number of cells, a <code>ValueError</code> is raised. The returned gradient values are copied from the <code>basis_grady_at_quad_ref</code> array to ensure immutability.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_grad_y_ref(self, cell_index: int):\n    \"\"\"\n    Get the gradient of the shape function with respect to y at the reference element.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n\n    Note:\n        This function returns the gradient of the shape function with respect to y at the reference element\n        for a given cell. The shape function gradient values are stored in the `basis_grady_at_quad_ref` array\n        of the corresponding finite element cell. The `cell_index` parameter specifies the index of the cell\n        for which the shape function gradient is required. If the `cell_index` is greater than the total number\n        of cells, a `ValueError` is raised. The returned gradient values are copied from the `basis_grady_at_quad_ref` array to ensure immutability.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_grady_at_quad_ref.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.get_shape_function_val","title":"<code>get_shape_function_val(cell_index)</code>","text":"<p>Get the actual values of the shape functions on a given cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell_index</code> <code>int</code> <p>The index of the cell.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The actual values of the shape functions on the given cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cell_index is greater than the number of cells.</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def get_shape_function_val(self, cell_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get the actual values of the shape functions on a given cell.\n\n    Args:\n        cell_index (int): The index of the cell.\n\n    Returns:\n        np.ndarray: The actual values of the shape functions on the given cell.\n\n    Raises:\n        ValueError: If the cell_index is greater than the number of cells.\n    \"\"\"\n    if cell_index &gt;= len(self.fe_cell) or cell_index &lt; 0:\n        raise ValueError(\n            f\"cell_index should be less than {self.n_cells} and greater than or equal to 0\"\n        )\n\n    return self.fe_cell[cell_index].basis_at_quad.copy()\n</code></pre>"},{"location":"api/core/sciml/fe/fespace2d/#scirex.core.sciml.fe.fespace2d.Fespace2D.set_finite_elements","title":"<code>set_finite_elements()</code>","text":"<p>Assigns the finite elements to each cell.</p> <p>This method initializes the finite element objects for each cell in the mesh. It creates an instance of the <code>FE2D_Cell</code> class for each cell, passing the necessary parameters. The finite element objects store information about the basis functions, gradients, Jacobians, quadrature points, weights, actual coordinates, and forcing functions associated with each cell.</p> <p>After initializing the finite element objects, this method prints the shape details of various matrices and updates the total number of degrees of freedom (dofs) for the entire mesh.</p> <p>:return: None</p> Source code in <code>scirex\\core\\sciml\\fe\\fespace2d.py</code> <pre><code>def set_finite_elements(self) -&gt; None:\n    \"\"\"\n    Assigns the finite elements to each cell.\n\n    This method initializes the finite element objects for each cell in the mesh.\n    It creates an instance of the `FE2D_Cell` class for each cell, passing the necessary parameters.\n    The finite element objects store information about the basis functions, gradients, Jacobians,\n    quadrature points, weights, actual coordinates, and forcing functions associated with each cell.\n\n    After initializing the finite element objects, this method prints the shape details of various matrices\n    and updates the total number of degrees of freedom (dofs) for the entire mesh.\n\n    :return: None\n    \"\"\"\n    progress_bar = tqdm(\n        total=self.n_cells,\n        desc=\"Fe2D_cell Setup\",\n        unit=\"cells_assembled\",\n        bar_format=\"{l_bar}{bar:40}{r_bar}{bar:-10b}\",\n        colour=\"blue\",\n        ncols=100,\n    )\n\n    dof = 0\n    for i in range(self.n_cells):\n        self.fe_cell.append(\n            FE2D_Cell(\n                self.cells[i],\n                self.cell_type,\n                self.fe_order,\n                self.fe_type,\n                self.quad_order,\n                self.quad_type,\n                self.fe_transformation_type,\n                self.forcing_function,\n            )\n        )\n\n        # obtain the shape of the basis function (n_test, N_quad)\n        dof += self.fe_cell[i].basis_at_quad.shape[1]\n\n        progress_bar.update(1)\n    # print the Shape details of all the matrices from cell 0 using print_table function\n    title = [\n        \"Shape function Matrix Shape\",\n        \"Shape function Gradient Matrix Shape\",\n        \"Jacobian Matrix Shape\",\n        \"Quadrature Points Shape\",\n        \"Quadrature Weights Shape\",\n        \"Quadrature Actual Coordinates Shape\",\n        \"Forcing Function Shape\",\n    ]\n    values = [\n        self.fe_cell[0].basis_at_quad.shape,\n        self.fe_cell[0].basis_gradx_at_quad.shape,\n        self.fe_cell[0].jacobian.shape,\n        self.fe_cell[0].quad_xi.shape,\n        self.fe_cell[0].quad_weight.shape,\n        self.fe_cell[0].quad_actual_coordinates.shape,\n        self.fe_cell[0].forcing_at_quad.shape,\n    ]\n    print_table(\"fe Matrix Shapes\", [\"Matrix\", \"Shape\"], title, values)\n\n    # update the total number of dofs\n    self.total_dofs = dof\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/","title":"quad_affine","text":"<p>Implementation of Affine Transformation for Quadrilateral Elements.</p> <p>This module provides functionality for affine transformations of quadrilateral elements in finite element analysis. It implements mapping between reference and physical elements based on the ParMooN project's methodology.</p> Key functionalities <ul> <li>Reference to physical coordinate mapping</li> <li>Jacobian computation</li> <li>First-order derivatives transformation</li> <li>Second-order derivatives transformation</li> </ul> <p>The implementation follows standard finite element mapping techniques with focus on quadrilateral elements. The transformations maintain geometric consistency and numerical accuracy required for FEM computations.</p> Key classes <ul> <li>QuadAffin: Main class implementing affine transformation for quads</li> </ul> Note <p>This implementation is specifically referenced from ParMooN project's QuadAffine.C file with adaptations for Python and SciREX framework.</p> References <p>[1] ParMooN Project: ParMooN/FiniteElement/QuadAffine.C</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin","title":"<code>QuadAffin</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements affine transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using affine mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <code>(yc1, yc2)</code> <p>Determinant of the Jacobian</p> <code>rec_detjk</code> <code>(yc1, yc2)</code> <p>Reciprocal of Jacobian determinant</p> Example <p>coords = np.array([[0,0], [1,0], [1,1], [0,1]]) quad = QuadAffin(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <p>The implementation assumes counterclockwise vertex ordering and non-degenerate quadrilateral elements.</p> References <p>[1] ParMooN Project: QuadAffine.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>class QuadAffin(FETransforamtion2D):\n    \"\"\"\n    Implements affine transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using affine mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2: x-coordinate transformation coefficients\n        yc0, yc1, yc2: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian\n        rec_detjk: Reciprocal of Jacobian determinant\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1,1], [0,1]])\n        &gt;&gt;&gt; quad = QuadAffin(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        The implementation assumes counterclockwise vertex ordering and\n        non-degenerate quadrilateral elements.\n\n    References:\n        [1] ParMooN Project: QuadAffine.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadAffin class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.get_jacobian(\n            0, 0\n        )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x1 + self.x3) * 0.5\n        self.xc1 = (self.x1 - self.x0) * 0.5\n        self.xc2 = (self.x3 - self.x0) * 0.5\n\n        self.yc0 = (self.y1 + self.y3) * 0.5\n        self.yc1 = (self.y1 - self.y0) * 0.5\n        self.yc2 = (self.y3 - self.y0) * 0.5\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n        return np.array([x, y])\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The Jacobian of the transformation.\n        \"\"\"\n        self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n        self.rec_detjk = 1 / self.detjk\n\n        return abs(self.detjk)\n\n    def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n        \"\"\"\n        Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The reference gradient in the x-direction.\n            ref_grady (np.ndarray): The reference gradient in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        gradx_orig = np.zeros(ref_gradx.shape)\n        grady_orig = np.zeros(ref_grady.shape)\n\n        for i in range(ref_gradx.shape[0]):\n            gradx_orig[i] = (\n                self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n            ) * self.rec_detjk\n            grady_orig[i] = (\n                -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n            ) * self.rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n    ):\n        \"\"\"\n        Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n            grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n            grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n        \"\"\"\n        GeoData = np.zeros((3, 3))\n        Eye = np.identity(3)\n\n        # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n        GeoData[0, 0] = self.xc1 * self.xc1\n        GeoData[0, 1] = 2 * self.xc1 * self.yc1\n        GeoData[0, 2] = self.yc1 * self.yc1\n        GeoData[1, 0] = self.xc1 * self.xc2\n        GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n        GeoData[1, 2] = self.yc1 * self.yc2\n        GeoData[2, 0] = self.xc2 * self.xc2\n        GeoData[2, 1] = 2 * self.xc2 * self.yc2\n        GeoData[2, 2] = self.yc2 * self.yc2\n\n        # solve the linear system\n        solution = np.linalg.solve(GeoData, Eye)\n\n        # generate empty arrays for the original second derivatives\n        grad_xx_orig = np.zeros(grad_xx_ref.shape)\n        grad_xy_orig = np.zeros(grad_xy_ref.shape)\n        grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n        for j in range(grad_xx_ref.shape[0]):\n            r20 = grad_xx_ref[j]\n            r11 = grad_xy_ref[j]\n            r02 = grad_yy_ref[j]\n\n            grad_xx_orig[j] = (\n                solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n            )\n            grad_xy_orig[j] = (\n                solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n            )\n            grad_yy_orig[j] = (\n                solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n            )\n\n        return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadAffin class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadAffin class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.get_jacobian(\n        0, 0\n    )  # 0,0 is just a dummy value # this sets the jacobian and the inverse of the jacobian\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>Returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The Jacobian of the transformation.\n    \"\"\"\n    self.detjk = self.xc1 * self.yc2 - self.xc2 * self.yc1\n    self.rec_detjk = 1 / self.detjk\n\n    return abs(self.detjk)\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>Returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The reference gradient in the x-direction.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The reference gradient in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The derivatives of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_derivative(self, ref_gradx, ref_grady, xi, eta):\n    \"\"\"\n    Returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The reference gradient in the x-direction.\n        ref_grady (np.ndarray): The reference gradient in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The derivatives of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    gradx_orig = np.zeros(ref_gradx.shape)\n    grady_orig = np.zeros(ref_grady.shape)\n\n    for i in range(ref_gradx.shape[0]):\n        gradx_orig[i] = (\n            self.yc2 * ref_gradx[i] - self.yc1 * ref_grady[i]\n        ) * self.rec_detjk\n        grady_orig[i] = (\n            -self.xc2 * ref_gradx[i] + self.xc1 * ref_grady[i]\n        ) * self.rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The reference second derivative in the x-direction.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The reference second derivative in the xy-direction.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The reference second derivative in the y-direction.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self, grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta\n):\n    \"\"\"\n    Returns the second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The reference second derivative in the x-direction.\n        grad_xy_ref (np.ndarray): The reference second derivative in the xy-direction.\n        grad_yy_ref (np.ndarray): The reference second derivative in the y-direction.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        tuple: The second derivatives (xx, xy, yy) of the original coordinates with respect to the reference coordinates.\n    \"\"\"\n    GeoData = np.zeros((3, 3))\n    Eye = np.identity(3)\n\n    # Populate GeoData (assuming xc1, xc2, yc1, yc2 are defined)\n    GeoData[0, 0] = self.xc1 * self.xc1\n    GeoData[0, 1] = 2 * self.xc1 * self.yc1\n    GeoData[0, 2] = self.yc1 * self.yc1\n    GeoData[1, 0] = self.xc1 * self.xc2\n    GeoData[1, 1] = self.yc1 * self.xc2 + self.xc1 * self.yc2\n    GeoData[1, 2] = self.yc1 * self.yc2\n    GeoData[2, 0] = self.xc2 * self.xc2\n    GeoData[2, 1] = 2 * self.xc2 * self.yc2\n    GeoData[2, 2] = self.yc2 * self.yc2\n\n    # solve the linear system\n    solution = np.linalg.solve(GeoData, Eye)\n\n    # generate empty arrays for the original second derivatives\n    grad_xx_orig = np.zeros(grad_xx_ref.shape)\n    grad_xy_orig = np.zeros(grad_xy_ref.shape)\n    grad_yy_orig = np.zeros(grad_yy_ref.shape)\n\n    for j in range(grad_xx_ref.shape[0]):\n        r20 = grad_xx_ref[j]\n        r11 = grad_xy_ref[j]\n        r02 = grad_yy_ref[j]\n\n        grad_xx_orig[j] = (\n            solution[0, 0] * r20 + solution[0, 1] * r11 + solution[0, 2] * r02\n        )\n        grad_xy_orig[j] = (\n            solution[1, 0] * r20 + solution[1, 1] * r11 + solution[1, 2] * r02\n        )\n        grad_yy_orig[j] = (\n            solution[2, 0] * r20 + solution[2, 1] * r11 + solution[2, 2] * r02\n        )\n\n    return grad_xx_orig, grad_xy_orig, grad_yy_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>Returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta\n\n    return np.array([x, y])\n</code></pre>"},{"location":"api/core/sciml/fe/quad_affine/#scirex.core.sciml.fe.quad_affine.QuadAffin.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_affine.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x1 + self.x3) * 0.5\n    self.xc1 = (self.x1 - self.x0) * 0.5\n    self.xc2 = (self.x3 - self.x0) * 0.5\n\n    self.yc0 = (self.y1 + self.y3) * 0.5\n    self.yc1 = (self.y1 - self.y0) * 0.5\n    self.yc2 = (self.y3 - self.y0) * 0.5\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/","title":"quad_bilinear","text":"<p>Implementation of Bilinear Transformation for Quadrilateral Elements.</p> <p>This module provides functionality for bilinear transformations of quadrilateral  elements in finite element analysis. It implements mapping between reference and  physical elements based on the ParMooN project's methodology.</p> Key functionalities <ul> <li>Reference to physical coordinate mapping using bilinear transformation</li> <li>Jacobian computation for bilinear elements</li> <li>First-order derivatives transformation</li> <li>Limited second-order derivatives transformation</li> </ul> <p>The implementation allows for more general quadrilateral elements compared to affine transformations, by using bilinear mapping functions. This enables handling of non-parallelogram quadrilateral elements while maintaining  geometric consistency.</p> Key classes <ul> <li>QuadBilinear: Main class implementing bilinear transformation for quads</li> </ul> Note <p>Second derivative calculations are currently not fully implemented. This implementation is specifically referenced from ParMooN project's QuadBilineare.C file with adaptations for Python and SciREX framework.</p> References <p>[1] ParMooN Project: ParMooN/FiniteElement/QuadBilinear.C</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear","title":"<code>QuadBilinear</code>","text":"<p>               Bases: <code>FETransforamtion2D</code></p> <p>Implements bilinear transformation for quadrilateral elements.</p> <p>This class provides methods to transform between reference and physical quadrilateral elements using bilinear mapping. It handles coordinate transformations, Jacobian computations, and derivative mappings for more general quadrilateral elements than affine transformations.</p> <p>Attributes:</p> Name Type Description <code>co_ordinates</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> <code>x0,</code> <code>(x1, x2, x3)</code> <p>x-coordinates of vertices</p> <code>y0,</code> <code>(y1, y2, y3)</code> <p>y-coordinates of vertices</p> <code>xc0,</code> <code>(xc1, xc2, xc3)</code> <p>x-coordinate transformation coefficients</p> <code>yc0,</code> <code>(yc1, yc2, yc3)</code> <p>y-coordinate transformation coefficients</p> <code>detjk</code> <p>Determinant of the Jacobian matrix</p> Example <p>coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]]) quad = QuadBilinear(coords) ref_point = np.array([0.5, 0.5]) physical_point = quad.get_original_from_ref(*ref_point)</p> Note <ul> <li>Implementation assumes counterclockwise vertex ordering</li> <li>Second derivatives computation is not fully implemented</li> <li>Jacobian is computed point-wise due to non-constant nature of bilinear transformation</li> </ul> References <p>[1] ParMooN Project: QuadBilineare.C implementation</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>class QuadBilinear(FETransforamtion2D):\n    \"\"\"\n    Implements bilinear transformation for quadrilateral elements.\n\n    This class provides methods to transform between reference and physical\n    quadrilateral elements using bilinear mapping. It handles coordinate\n    transformations, Jacobian computations, and derivative mappings for more\n    general quadrilateral elements than affine transformations.\n\n    Attributes:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n        x0, x1, x2, x3: x-coordinates of vertices\n        y0, y1, y2, y3: y-coordinates of vertices\n        xc0, xc1, xc2, xc3: x-coordinate transformation coefficients\n        yc0, yc1, yc2, yc3: y-coordinate transformation coefficients\n        detjk: Determinant of the Jacobian matrix\n\n    Example:\n        &gt;&gt;&gt; coords = np.array([[0,0], [1,0], [1.2,1], [0.2,1.1]])\n        &gt;&gt;&gt; quad = QuadBilinear(coords)\n        &gt;&gt;&gt; ref_point = np.array([0.5, 0.5])\n        &gt;&gt;&gt; physical_point = quad.get_original_from_ref(*ref_point)\n\n    Note:\n        - Implementation assumes counterclockwise vertex ordering\n        - Second derivatives computation is not fully implemented\n        - Jacobian is computed point-wise due to non-constant nature\n        of bilinear transformation\n\n    References:\n        [1] ParMooN Project: QuadBilineare.C implementation\n    \"\"\"\n\n    def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n        \"\"\"\n        Constructor for the QuadBilinear class.\n\n        Args:\n            co_ordinates: Array of physical element vertex coordinates\n                Shape: (4, 2) for 2D quadrilateral\n\n        Returns:\n            None\n        \"\"\"\n        self.co_ordinates = co_ordinates\n        self.set_cell()\n        self.detjk = None  # Jacobian of the transformation\n\n    def set_cell(self):\n        \"\"\"\n        Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.x0 = self.co_ordinates[0][0]\n        self.x1 = self.co_ordinates[1][0]\n        self.x2 = self.co_ordinates[2][0]\n        self.x3 = self.co_ordinates[3][0]\n\n        # get the y-coordinates of the cell\n        self.y0 = self.co_ordinates[0][1]\n        self.y1 = self.co_ordinates[1][1]\n        self.y2 = self.co_ordinates[2][1]\n        self.y3 = self.co_ordinates[3][1]\n\n        self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n        self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n        self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n        self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n        self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n        self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n        self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n        self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n\n    def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the original coordinates from the reference coordinates.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n        \"\"\"\n        x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n        y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n        return np.array([x, y], dtype=np.float64)\n\n    def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the Jacobian of the transformation.\n\n        Args:\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: Returns the Jacobian of the transformation.\n        \"\"\"\n        self.detjk = abs(\n            (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n            - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n        )\n        return self.detjk\n\n    def get_orig_from_ref_derivative(\n        self,\n        ref_gradx: np.ndarray,\n        ref_grady: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n            ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Returns:\n            np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n        \"\"\"\n        n_test = ref_gradx.shape[0]\n        gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n        grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n        for j in range(n_test):\n            Xi = xi\n            Eta = eta\n            rec_detjk = 1 / (\n                (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n                - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n            )\n            gradx_orig[j] = (\n                (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n                - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n            grady_orig[j] = (\n                -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n                + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n            ) * rec_detjk\n\n        return gradx_orig, grady_orig\n\n    def get_orig_from_ref_second_derivative(\n        self,\n        grad_xx_ref: np.ndarray,\n        grad_xy_ref: np.ndarray,\n        grad_yy_ref: np.ndarray,\n        xi: np.ndarray,\n        eta: np.ndarray,\n    ):\n        \"\"\"\n        This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n        Args:\n            grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n            grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n            grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n            xi (np.ndarray): The xi coordinate.\n            eta (np.ndarray): The eta coordinate.\n\n        Note:\n            Second derivative calculations are not fully implemented in this method. Needs further development.\n        \"\"\"\n        # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n        return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.__init__","title":"<code>__init__(co_ordinates)</code>","text":"<p>Constructor for the QuadBilinear class.</p> <p>Parameters:</p> Name Type Description Default <code>co_ordinates</code> <code>ndarray</code> <p>Array of physical element vertex coordinates Shape: (4, 2) for 2D quadrilateral</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def __init__(self, co_ordinates: np.ndarray) -&gt; None:\n    \"\"\"\n    Constructor for the QuadBilinear class.\n\n    Args:\n        co_ordinates: Array of physical element vertex coordinates\n            Shape: (4, 2) for 2D quadrilateral\n\n    Returns:\n        None\n    \"\"\"\n    self.co_ordinates = co_ordinates\n    self.set_cell()\n    self.detjk = None  # Jacobian of the transformation\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_jacobian","title":"<code>get_jacobian(xi, eta)</code>","text":"<p>This method returns the Jacobian of the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the Jacobian of the transformation.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_jacobian(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the Jacobian of the transformation.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the Jacobian of the transformation.\n    \"\"\"\n    self.detjk = abs(\n        (self.xc1 + self.xc3 * eta) * (self.yc2 + self.yc3 * xi)\n        - (self.xc2 + self.xc3 * xi) * (self.yc1 + self.yc3 * eta)\n    )\n    return self.detjk\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_orig_from_ref_derivative","title":"<code>get_orig_from_ref_derivative(ref_gradx, ref_grady, xi, eta)</code>","text":"<p>This method returns the derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ref_gradx</code> <code>ndarray</code> <p>The derivative of the xi coordinate in the reference element.</p> required <code>ref_grady</code> <code>ndarray</code> <p>The derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_derivative(\n    self,\n    ref_gradx: np.ndarray,\n    ref_grady: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        ref_gradx (np.ndarray): The derivative of the xi coordinate in the reference element.\n        ref_grady (np.ndarray): The derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: The derivatives of the original coordinates [x, y] with respect to the reference coordinates.\n\n    \"\"\"\n    n_test = ref_gradx.shape[0]\n    gradx_orig = np.zeros(ref_gradx.shape, dtype=np.float64)\n    grady_orig = np.zeros(ref_grady.shape, dtype=np.float64)\n\n    for j in range(n_test):\n        Xi = xi\n        Eta = eta\n        rec_detjk = 1 / (\n            (self.xc1 + self.xc3 * Eta) * (self.yc2 + self.yc3 * Xi)\n            - (self.xc2 + self.xc3 * Xi) * (self.yc1 + self.yc3 * Eta)\n        )\n        gradx_orig[j] = (\n            (self.yc2 + self.yc3 * Xi) * ref_gradx[j]\n            - (self.yc1 + self.yc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n        grady_orig[j] = (\n            -(self.xc2 + self.xc3 * Xi) * ref_gradx[j]\n            + (self.xc1 + self.xc3 * Eta) * ref_grady[j]\n        ) * rec_detjk\n\n    return gradx_orig, grady_orig\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_orig_from_ref_second_derivative","title":"<code>get_orig_from_ref_second_derivative(grad_xx_ref, grad_xy_ref, grad_yy_ref, xi, eta)</code>","text":"<p>This method returns the second derivatives of the original coordinates with respect to the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>grad_xx_ref</code> <code>ndarray</code> <p>The second derivative of the xi coordinate in the reference element.</p> required <code>grad_xy_ref</code> <code>ndarray</code> <p>The second derivative of the xi and eta coordinates in the reference element.</p> required <code>grad_yy_ref</code> <code>ndarray</code> <p>The second derivative of the eta coordinate in the reference element.</p> required <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required Note <p>Second derivative calculations are not fully implemented in this method. Needs further development.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_orig_from_ref_second_derivative(\n    self,\n    grad_xx_ref: np.ndarray,\n    grad_xy_ref: np.ndarray,\n    grad_yy_ref: np.ndarray,\n    xi: np.ndarray,\n    eta: np.ndarray,\n):\n    \"\"\"\n    This method returns the second derivatives of the original coordinates with respect to the reference coordinates.\n\n    Args:\n        grad_xx_ref (np.ndarray): The second derivative of the xi coordinate in the reference element.\n        grad_xy_ref (np.ndarray): The second derivative of the xi and eta coordinates in the reference element.\n        grad_yy_ref (np.ndarray): The second derivative of the eta coordinate in the reference element.\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Note:\n        Second derivative calculations are not fully implemented in this method. Needs further development.\n    \"\"\"\n    # print(\" Error : Second Derivative not implemented -- Ignore this error, if second derivative is not required \")\n    return grad_xx_ref, grad_xy_ref, grad_yy_ref\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.get_original_from_ref","title":"<code>get_original_from_ref(xi, eta)</code>","text":"<p>This method returns the original coordinates from the reference coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xi</code> <code>ndarray</code> <p>The xi coordinate.</p> required <code>eta</code> <code>ndarray</code> <p>The eta coordinate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Returns the transformed original coordinates from the reference coordinates.</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def get_original_from_ref(self, xi: np.ndarray, eta: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    This method returns the original coordinates from the reference coordinates.\n\n    Args:\n        xi (np.ndarray): The xi coordinate.\n        eta (np.ndarray): The eta coordinate.\n\n    Returns:\n        np.ndarray: Returns the transformed original coordinates from the reference coordinates.\n    \"\"\"\n    x = self.xc0 + self.xc1 * xi + self.xc2 * eta + self.xc3 * xi * eta\n    y = self.yc0 + self.yc1 * xi + self.yc2 * eta + self.yc3 * xi * eta\n\n    return np.array([x, y], dtype=np.float64)\n</code></pre>"},{"location":"api/core/sciml/fe/quad_bilinear/#scirex.core.sciml.fe.quad_bilinear.QuadBilinear.set_cell","title":"<code>set_cell()</code>","text":"<p>Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quad_bilinear.py</code> <pre><code>def set_cell(self):\n    \"\"\"\n    Set the cell coordinates, which will be used as intermediate values to calculate the Jacobian and actual values.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.x0 = self.co_ordinates[0][0]\n    self.x1 = self.co_ordinates[1][0]\n    self.x2 = self.co_ordinates[2][0]\n    self.x3 = self.co_ordinates[3][0]\n\n    # get the y-coordinates of the cell\n    self.y0 = self.co_ordinates[0][1]\n    self.y1 = self.co_ordinates[1][1]\n    self.y2 = self.co_ordinates[2][1]\n    self.y3 = self.co_ordinates[3][1]\n\n    self.xc0 = (self.x0 + self.x1 + self.x2 + self.x3) * 0.25\n    self.xc1 = (-self.x0 + self.x1 + self.x2 - self.x3) * 0.25\n    self.xc2 = (-self.x0 - self.x1 + self.x2 + self.x3) * 0.25\n    self.xc3 = (self.x0 - self.x1 + self.x2 - self.x3) * 0.25\n\n    self.yc0 = (self.y0 + self.y1 + self.y2 + self.y3) * 0.25\n    self.yc1 = (-self.y0 + self.y1 + self.y2 - self.y3) * 0.25\n    self.yc2 = (-self.y0 - self.y1 + self.y2 + self.y3) * 0.25\n    self.yc3 = (self.y0 - self.y1 + self.y2 - self.y3) * 0.25\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/","title":"quadratureformulas","text":"<p>Abstract Base Class for Numerical Quadrature Formulas.</p> <p>This module provides the base interface for implementing various numerical  quadrature schemes. It defines the common structure and required methods  that all quadrature implementations must follow.</p> Key functionalities <ul> <li>Abstract interface for quadrature rule implementations</li> <li>Standard methods for accessing quadrature points and weights</li> <li>Flexible framework for different element types and dimensions</li> </ul> The module serves as a foundation for <ul> <li>Multiple quadrature rule implementations</li> <li>Different element type integrations</li> <li>Various quadrature orders and types</li> <li>Custom quadrature scheme implementations</li> </ul> Key classes <ul> <li>Quadratureformulas: Abstract base class for all quadrature implementations</li> </ul> Dependencies <ul> <li>abc: For abstract base class functionality</li> </ul> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version Info <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas","title":"<code>Quadratureformulas</code>","text":"<p>Abstract base class for numerical quadrature formulas.</p> <p>This class defines the interface that all quadrature implementations must follow. It provides the basic structure for implementing various quadrature rules while ensuring consistent access to quadrature data.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of the quadrature rule</p> <code>quad_type</code> <p>Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points</p> Example <p>class MyQuadrature(Quadratureformulas): ...     def init(self): ...         super().init(quad_order=3, ...                         quad_type='custom', ...                         num_quad_points=9) ...     def get_quad_values(self): ...         # Implementation ...         pass ...     def get_num_quad_points(self): ...         return self.num_quad_points</p> Note <p>This is an abstract base class. Concrete implementations must override: - get_quad_values() - get_num_quad_points()</p> <p>The implementation should ensure proper initialization of: - Quadrature points - Quadrature weights - Number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>class Quadratureformulas:\n    \"\"\"Abstract base class for numerical quadrature formulas.\n\n    This class defines the interface that all quadrature implementations must\n    follow. It provides the basic structure for implementing various quadrature\n    rules while ensuring consistent access to quadrature data.\n\n    Attributes:\n        quad_order: Order of the quadrature rule\n        quad_type: Type of quadrature (e.g., 'gauss-legendre', 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Example:\n        &gt;&gt;&gt; class MyQuadrature(Quadratureformulas):\n        ...     def __init__(self):\n        ...         super().__init__(quad_order=3,\n        ...                         quad_type='custom',\n        ...                         num_quad_points=9)\n        ...     def get_quad_values(self):\n        ...         # Implementation\n        ...         pass\n        ...     def get_num_quad_points(self):\n        ...         return self.num_quad_points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - get_quad_values()\n        - get_num_quad_points()\n\n        The implementation should ensure proper initialization of:\n        - Quadrature points\n        - Quadrature weights\n        - Number of quadrature points\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n            num_quad_points: Total number of quadrature points\n\n        Returns:\n            None\n        \"\"\"\n        self.quad_order = quad_order\n        self.quad_type = quad_type\n        self.num_quad_points = num_quad_points\n\n    @abstractmethod\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            weights: Weights for each quadrature point\n            xi: x-coordinates of quadrature points in reference element\n            eta: y-coordinates of quadrature points in reference element\n        \"\"\"\n\n    @abstractmethod\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            num_quad_points: Total number of quadrature points\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas.__init__","title":"<code>__init__(quad_order, quad_type, num_quad_points)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <code>num_quad_points</code> <code>int</code> <p>Total number of quadrature points</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str, num_quad_points: int):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points\n\n    Returns:\n        None\n    \"\"\"\n    self.quad_order = quad_order\n    self.quad_type = quad_type\n    self.num_quad_points = num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas.get_num_quad_points","title":"<code>get_num_quad_points()</code>  <code>abstractmethod</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>num_quad_points</code> <p>Total number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        num_quad_points: Total number of quadrature points\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas/#scirex.core.sciml.fe.quadratureformulas.Quadratureformulas.get_quad_values","title":"<code>get_quad_values()</code>  <code>abstractmethod</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>weights</code> <p>Weights for each quadrature point</p> <code>xi</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta</code> <p>y-coordinates of quadrature points in reference element</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas.py</code> <pre><code>@abstractmethod\ndef get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        weights: Weights for each quadrature point\n        xi: x-coordinates of quadrature points in reference element\n        eta: y-coordinates of quadrature points in reference element\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/","title":"quadratureformulas_quad2d","text":"<p>Quadrature Formula Implementation for 2D Quadrilateral Elements.</p> <p>This module implements numerical integration formulas for 2D quadrilateral elements, providing both Gauss-Legendre and Gauss-Jacobi quadrature schemes. The implementation focuses on accurate numerical integration required for finite element computations.</p> Key functionalities <ul> <li>Gauss-Legendre quadrature for quadrilateral elements</li> <li>Gauss-Jacobi quadrature with Lobatto points</li> <li>Tensor product based 2D quadrature point generation</li> <li>Weight computation for various quadrature orders</li> </ul> The implementation provides <ul> <li>Flexible quadrature order selection</li> <li>Multiple quadrature schemes</li> <li>Efficient tensor product based computations</li> <li>Automated weight and point generation</li> </ul> Key classes <ul> <li>Quadratureformulas_Quad2D: Main class for 2D quadrature computations</li> </ul> Dependencies <ul> <li>numpy: For numerical computations</li> <li>scipy.special: For special function evaluations (roots, weights)</li> <li>scipy.special.orthogonal: For orthogonal polynomial computations</li> </ul> Note <p>The implementation assumes tensor-product based quadrature rules for 2D elements. Specialized non-tensor product rules are not included.</p> References <p>[1] Karniadakis, G., &amp; Sherwin, S. (2013). Spectral/hp Element      Methods for Computational Fluid Dynamics. Oxford University Press.</p> <p>[2] Kharazmi - hp-VPINNs github repository</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D","title":"<code>Quadratureformulas_Quad2D</code>","text":"<p>               Bases: <code>Quadratureformulas</code></p> <p>Implements quadrature formulas for 2D quadrilateral elements.</p> <p>This class provides methods to compute quadrature points and weights for 2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi quadrature schemes. The implementation uses tensor products of 1D rules.</p> <p>Attributes:</p> Name Type Description <code>quad_order</code> <p>Order of quadrature rule</p> <code>quad_type</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> <code>num_quad_points</code> <p>Total number of quadrature points (quad_order^2)</p> <code>xi_quad</code> <p>x-coordinates of quadrature points in reference element</p> <code>eta_quad</code> <p>y-coordinates of quadrature points in reference element</p> <code>quad_weights</code> <p>Weights for each quadrature point</p> Example <p>quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre') weights, xi, eta = quad.get_quad_values() n_points = quad.get_num_quad_points()</p> Note <ul> <li>Gauss-Legendre points are optimal for polynomial integrands</li> <li>Gauss-Jacobi points include element vertices (useful for certain FEM applications)</li> <li>All computations are performed in the reference element [-1,1]\u00d7[-1,1]</li> </ul> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>class Quadratureformulas_Quad2D(Quadratureformulas):\n    \"\"\"Implements quadrature formulas for 2D quadrilateral elements.\n\n    This class provides methods to compute quadrature points and weights for\n    2D quadrilateral elements using either Gauss-Legendre or Gauss-Jacobi\n    quadrature schemes. The implementation uses tensor products of 1D rules.\n\n    Attributes:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n        num_quad_points: Total number of quadrature points (quad_order^2)\n        xi_quad: x-coordinates of quadrature points in reference element\n        eta_quad: y-coordinates of quadrature points in reference element\n        quad_weights: Weights for each quadrature point\n\n    Example:\n        &gt;&gt;&gt; quad = Quadratureformulas_Quad2D(quad_order=3, quad_type='gauss-legendre')\n        &gt;&gt;&gt; weights, xi, eta = quad.get_quad_values()\n        &gt;&gt;&gt; n_points = quad.get_num_quad_points()\n\n    Note:\n        - Gauss-Legendre points are optimal for polynomial integrands\n        - Gauss-Jacobi points include element vertices (useful for certain FEM applications)\n        - All computations are performed in the reference element [-1,1]\u00d7[-1,1]\n\n    \"\"\"\n\n    def __init__(self, quad_order: int, quad_type: str):\n        \"\"\"\n        Constructor for the Quadratureformulas_Quad2D class.\n\n        Args:\n            quad_order: Order of quadrature rule\n            quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the quadrature type is not supported.\n        \"\"\"\n        # initialize the super class\n        super().__init__(\n            quad_order=quad_order,\n            quad_type=quad_type,\n            num_quad_points=quad_order * quad_order,\n        )\n\n        # Calculate the Gauss-Legendre quadrature points and weights for 1D\n        # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n        quad_type = self.quad_type\n\n        if quad_type == \"gauss-legendre\":\n            # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n            # if quad_order == 2:\n            #     nodes_1d = np.array([-1, 1])\n            #     weights_1d = np.array([1, 1])\n            # else:\n            nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n                quad_order\n            )  # Interior points\n            # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n            # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        elif quad_type == \"gauss-jacobi\":\n\n            def GaussJacobiWeights(Q: int, a, b):\n                [X, W] = roots_jacobi(Q, a, b)\n                return [X, W]\n\n            def jacobi_wrapper(n, a, b, x):\n\n                x = np.array(x, dtype=np.float64)\n\n                return jacobi(n, a, b)(x)\n\n            # Weight coefficients\n            def GaussLobattoJacobiWeights(Q: int, a, b):\n                W = []\n                X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n                if a == 0 and b == 0:\n                    W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                    Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                    Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n                else:\n                    W = (\n                        2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                        )\n                    )\n                    Wl = (\n                        (b + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                        )\n                    )\n                    Wr = (\n                        (a + 1)\n                        * 2 ** (a + b + 1)\n                        * gamma(a + Q)\n                        * gamma(b + Q)\n                        / (\n                            (Q - 1)\n                            * gamma(Q)\n                            * gamma(a + b + Q + 1)\n                            * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                        )\n                    )\n                W = np.append(W, Wr)\n                W = np.append(Wl, W)\n                X = np.append(X, 1)\n                X = np.append(-1, X)\n                return [X, W]\n\n            # get quadrature points and weights in 1D\n            x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n            # Generate the tensor outer product of the nodes\n            xi_quad, eta_quad = np.meshgrid(x, x)\n            xi_quad = xi_quad.flatten()\n            eta_quad = eta_quad.flatten()\n\n            # Multiply the weights accordingly for 2D\n            quad_weights = (w[:, np.newaxis] * w).flatten()\n\n            # Assign the values\n            self.xi_quad = xi_quad\n            self.eta_quad = eta_quad\n            self.quad_weights = quad_weights\n\n        else:\n            print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n            print(\n                f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Quadrature type not supported.\")\n\n    def get_quad_values(self):\n        \"\"\"\n        Returns the quadrature weights, xi and eta values.\n\n        Args:\n            None\n\n        Returns:\n            tuple: The quadrature weights, xi and eta values in a numpy array format\n        \"\"\"\n        return self.quad_weights, self.xi_quad, self.eta_quad\n\n    def get_num_quad_points(self):\n        \"\"\"\n        Returns the number of quadrature points.\n\n        Args:\n            None\n\n        Returns:\n            int: The number of quadrature points\n        \"\"\"\n        return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D.__init__","title":"<code>__init__(quad_order, quad_type)</code>","text":"<p>Constructor for the Quadratureformulas_Quad2D class.</p> <p>Parameters:</p> Name Type Description Default <code>quad_order</code> <code>int</code> <p>Order of quadrature rule</p> required <code>quad_type</code> <code>str</code> <p>Type of quadrature ('gauss-legendre' or 'gauss-jacobi')</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quadrature type is not supported.</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def __init__(self, quad_order: int, quad_type: str):\n    \"\"\"\n    Constructor for the Quadratureformulas_Quad2D class.\n\n    Args:\n        quad_order: Order of quadrature rule\n        quad_type: Type of quadrature ('gauss-legendre' or 'gauss-jacobi')\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the quadrature type is not supported.\n    \"\"\"\n    # initialize the super class\n    super().__init__(\n        quad_order=quad_order,\n        quad_type=quad_type,\n        num_quad_points=quad_order * quad_order,\n    )\n\n    # Calculate the Gauss-Legendre quadrature points and weights for 1D\n    # nodes_1d, weights_1d = roots_jacobi(self.quad_order, 1, 1)\n\n    quad_type = self.quad_type\n\n    if quad_type == \"gauss-legendre\":\n        # Commented out by THIVIN -  to Just use legendre quadrature points as it is\n        # if quad_order == 2:\n        #     nodes_1d = np.array([-1, 1])\n        #     weights_1d = np.array([1, 1])\n        # else:\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(\n            quad_order\n        )  # Interior points\n        # nodes_1d = np.concatenate(([-1, 1], nodes_1d))\n        # weights_1d = np.concatenate(([1, 1], weights_1d))\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(nodes_1d, nodes_1d)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (weights_1d[:, np.newaxis] * weights_1d).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    elif quad_type == \"gauss-jacobi\":\n\n        def GaussJacobiWeights(Q: int, a, b):\n            [X, W] = roots_jacobi(Q, a, b)\n            return [X, W]\n\n        def jacobi_wrapper(n, a, b, x):\n\n            x = np.array(x, dtype=np.float64)\n\n            return jacobi(n, a, b)(x)\n\n        # Weight coefficients\n        def GaussLobattoJacobiWeights(Q: int, a, b):\n            W = []\n            X = roots_jacobi(Q - 2, a + 1, b + 1)[0]\n            if a == 0 and b == 0:\n                W = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, X) ** 2))\n                Wl = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, -1) ** 2))\n                Wr = 2 / ((Q - 1) * (Q) * (jacobi_wrapper(Q - 1, 0, 0, 1) ** 2))\n            else:\n                W = (\n                    2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, X) ** 2)\n                    )\n                )\n                Wl = (\n                    (b + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, -1) ** 2)\n                    )\n                )\n                Wr = (\n                    (a + 1)\n                    * 2 ** (a + b + 1)\n                    * gamma(a + Q)\n                    * gamma(b + Q)\n                    / (\n                        (Q - 1)\n                        * gamma(Q)\n                        * gamma(a + b + Q + 1)\n                        * (jacobi_wrapper(Q - 1, a, b, 1) ** 2)\n                    )\n                )\n            W = np.append(W, Wr)\n            W = np.append(Wl, W)\n            X = np.append(X, 1)\n            X = np.append(-1, X)\n            return [X, W]\n\n        # get quadrature points and weights in 1D\n        x, w = GaussLobattoJacobiWeights(self.quad_order, 0, 0)\n\n        # Generate the tensor outer product of the nodes\n        xi_quad, eta_quad = np.meshgrid(x, x)\n        xi_quad = xi_quad.flatten()\n        eta_quad = eta_quad.flatten()\n\n        # Multiply the weights accordingly for 2D\n        quad_weights = (w[:, np.newaxis] * w).flatten()\n\n        # Assign the values\n        self.xi_quad = xi_quad\n        self.eta_quad = eta_quad\n        self.quad_weights = quad_weights\n\n    else:\n        print(\"Supported quadrature types are: gauss-legendre, gauss-jacobi\")\n        print(\n            f\"Invalid quadrature type {quad_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Quadrature type not supported.\")\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D.get_num_quad_points","title":"<code>get_num_quad_points()</code>","text":"<p>Returns the number of quadrature points.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of quadrature points</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_num_quad_points(self):\n    \"\"\"\n    Returns the number of quadrature points.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of quadrature points\n    \"\"\"\n    return self.num_quad_points\n</code></pre>"},{"location":"api/core/sciml/fe/quadratureformulas_quad2d/#scirex.core.sciml.fe.quadratureformulas_quad2d.Quadratureformulas_Quad2D.get_quad_values","title":"<code>get_quad_values()</code>","text":"<p>Returns the quadrature weights, xi and eta values.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The quadrature weights, xi and eta values in a numpy array format</p> Source code in <code>scirex\\core\\sciml\\fe\\quadratureformulas_quad2d.py</code> <pre><code>def get_quad_values(self):\n    \"\"\"\n    Returns the quadrature weights, xi and eta values.\n\n    Args:\n        None\n\n    Returns:\n        tuple: The quadrature weights, xi and eta values in a numpy array format\n    \"\"\"\n    return self.quad_weights, self.xi_quad, self.eta_quad\n</code></pre>"},{"location":"api/core/sciml/fno/layers/fno_block/","title":"FNO block","text":"<p>Module: fno_block.py</p> <p>This module provides the implementation of a single block of the Fourier Neural Operator (FNO) model.</p> <p>Classes:</p> Name Description <code>FNOBlock1d</code> <p>Single block of the FNO model</p> Dependencies <ul> <li>jax: For array processing</li> <li>equinox: For neural network layers</li> </ul> Key Features <ul> <li>Spectral convolution</li> <li>Bypass convolution</li> <li>Activation function</li> </ul> Authors <p>Diya Nag Chaudhury</p> Version Info <p>29/Dec/2024: Initial version - Diya Nag Chaudhury</p> References <p>None</p> <p>Module: fno_block.py</p> <p>This module provides the implementation of a single block of the Fourier Neural Operator (FNO) model.</p> <p>Classes:</p> Name Description <code>FNOBlock1d</code> <p>Single block of the FNO model</p> Dependencies <ul> <li>jax: For array processing</li> <li>equinox: For neural network layers</li> </ul> Key Features <ul> <li>Spectral convolution</li> <li>Bypass convolution</li> <li>Activation function</li> </ul> Authors <p>Diya Nag Chaudhury</p> Version Info <p>29/Dec/2024: Initial version - Diya Nag Chaudhury</p> References <p>None</p>"},{"location":"api/core/sciml/fno/layers/fno_block/#scirex.core.sciml.fno.layers.fno_block.FNOBlock1d","title":"<code>FNOBlock1d</code>","text":"<p>               Bases: <code>Module</code></p> <p>A single block of the FNO model.</p> <p>This block consists of a spectral convolution followed by a bypass convolution and an activation function.</p> <p>Attributes: spectral_conv: SpectralConv1d bypass_conv: eqx.nn.Conv1d activation: Callable</p> <p>Methods: init: Initializes the FNOBlock1d object call: Calls the FNOBlock1d object</p> Source code in <code>scirex\\core\\sciml\\fno\\layers\\fno_block.py</code> <pre><code>class FNOBlock1d(eqx.Module):\n    \"\"\"\n    A single block of the FNO model.\n\n    This block consists of a spectral convolution followed by a bypass convolution\n    and an activation function.\n\n    Attributes:\n    spectral_conv: SpectralConv1d\n    bypass_conv: eqx.nn.Conv1d\n    activation: Callable\n\n    Methods:\n    __init__: Initializes the FNOBlock1d object\n    __call__: Calls the FNOBlock1d object\n    \"\"\"\n\n    spectral_conv: SpectralConv1d\n    bypass_conv: eqx.nn.Conv1d\n    activation: Callable\n\n    def __init__(\n        self,\n        in_channels,\n        out_channels,\n        modes,\n        activation,\n        *,\n        key,\n    ):\n        spectral_conv_key, bypass_conv_key = jax.random.split(key)\n        self.spectral_conv = SpectralConv1d(\n            in_channels,\n            out_channels,\n            modes,\n            key=spectral_conv_key,\n        )\n        self.bypass_conv = eqx.nn.Conv1d(\n            in_channels,\n            out_channels,\n            1,  # Kernel size is one\n            key=bypass_conv_key,\n        )\n        self.activation = activation\n\n    def __call__(\n        self,\n        x,\n    ):\n        return self.activation(self.spectral_conv(x) + self.bypass_conv(x))\n</code></pre>"},{"location":"api/core/sciml/fno/layers/fno_block/#scirex.core.sciml.fno.layers.fno_block.FNOBlock1d","title":"<code>FNOBlock1d</code>","text":"<p>               Bases: <code>Module</code></p> <p>A single block of the FNO model.</p> <p>This block consists of a spectral convolution followed by a bypass convolution and an activation function.</p> <p>Attributes: spectral_conv: SpectralConv1d bypass_conv: eqx.nn.Conv1d activation: Callable</p> <p>Methods: init: Initializes the FNOBlock1d object call: Calls the FNOBlock1d object</p> Source code in <code>scirex\\core\\sciml\\fno\\layers\\fno_block.py</code> <pre><code>class FNOBlock1d(eqx.Module):\n    \"\"\"\n    A single block of the FNO model.\n\n    This block consists of a spectral convolution followed by a bypass convolution\n    and an activation function.\n\n    Attributes:\n    spectral_conv: SpectralConv1d\n    bypass_conv: eqx.nn.Conv1d\n    activation: Callable\n\n    Methods:\n    __init__: Initializes the FNOBlock1d object\n    __call__: Calls the FNOBlock1d object\n    \"\"\"\n\n    spectral_conv: SpectralConv1d\n    bypass_conv: eqx.nn.Conv1d\n    activation: Callable\n\n    def __init__(\n        self,\n        in_channels,\n        out_channels,\n        modes,\n        activation,\n        *,\n        key,\n    ):\n        spectral_conv_key, bypass_conv_key = jax.random.split(key)\n        self.spectral_conv = SpectralConv1d(\n            in_channels,\n            out_channels,\n            modes,\n            key=spectral_conv_key,\n        )\n        self.bypass_conv = eqx.nn.Conv1d(\n            in_channels,\n            out_channels,\n            1,  # Kernel size is one\n            key=bypass_conv_key,\n        )\n        self.activation = activation\n\n    def __call__(\n        self,\n        x,\n    ):\n        return self.activation(self.spectral_conv(x) + self.bypass_conv(x))\n</code></pre>"},{"location":"api/core/sciml/fno/layers/spectral_conv/","title":"Spectral conv","text":"<p>Module: spectral_conv.py</p> <p>This module provides the implementation of a 1D spectral convolution layer.</p> <p>Classes:</p> Name Description <code>SpectralConv1d</code> <p>1D spectral convolution layer</p> Dependencies <ul> <li>jax: For array processing</li> <li>equinox: For neural network layers</li> </ul> Key Features <ul> <li>Complex multiplication</li> <li>Fourier domain convolution</li> <li>Real and imaginary weights</li> </ul> Authors <p>Diya Nag Chaudhury</p> Version Info <p>29/Dec/2024: Initial version - Diya Nag Chaudhury</p> References <p>None</p>"},{"location":"api/core/sciml/fno/layers/spectral_conv/#scirex.core.sciml.fno.layers.spectral_conv.SpectralConv1d","title":"<code>SpectralConv1d</code>","text":"<p>               Bases: <code>Module</code></p> <p>A 1D spectral convolution layer.</p> <p>This layer performs a 1D convolution in the Fourier domain.</p> <p>Attributes: real_weights: jax.Array imag_weights: jax.Array in_channels: int out_channels: int modes: int</p> <p>Methods: init: Initializes the SpectralConv1d object complex_mult1d: Performs complex multiplication in 1D call: Calls the SpectralConv1d object</p> Source code in <code>scirex\\core\\sciml\\fno\\layers\\spectral_conv.py</code> <pre><code>class SpectralConv1d(eqx.Module):\n    \"\"\"\n    A 1D spectral convolution layer.\n\n    This layer performs a 1D convolution in the Fourier domain.\n\n    Attributes:\n    real_weights: jax.Array\n    imag_weights: jax.Array\n    in_channels: int\n    out_channels: int\n    modes: int\n\n    Methods:\n    __init__: Initializes the SpectralConv1d object\n    complex_mult1d: Performs complex multiplication in 1D\n    __call__: Calls the SpectralConv1d object\n    \"\"\"\n\n    real_weights: jax.Array\n    imag_weights: jax.Array\n    in_channels: int\n    out_channels: int\n    modes: int\n\n    def __init__(\n        self,\n        in_channels,\n        out_channels,\n        modes,\n        *,\n        key,\n    ):\n        \"\"\"\n        Constructor for the SpectralConv1d class.\n\n        Parameters:\n        in_channels: int\n            Number of input channels\n        out_channels: int\n            Number of output channels\n        modes: int\n            Number of modes\n        key: jax.random.PRNGKey\n            Random key for initialization\n\n        Returns:\n        None\n\n        Usage:\n        spectral_conv = SpectralConv1d(\n            in_channels=1,\n            out_channels=1,\n            modes=64,\n            key=key,\n        )\n        \"\"\"\n\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.modes = modes\n\n        scale = 1.0 / (in_channels * out_channels)\n\n        real_key, imag_key = jax.random.split(key)\n        self.real_weights = jax.random.uniform(\n            real_key,\n            (in_channels, out_channels, modes),\n            minval=-scale,\n            maxval=+scale,\n        )\n        self.imag_weights = jax.random.uniform(\n            imag_key,\n            (in_channels, out_channels, modes),\n            minval=-scale,\n            maxval=+scale,\n        )\n\n    def complex_mult1d(\n        self,\n        x_hat,\n        w,\n    ):\n        \"\"\"\n        Returns the complex multiplication of x_hat and w.\n\n        Parameters:\n        x_hat: jax.Array\n            Input array in the Fourier domain\n        w: jax.Array\n            Weights in the Fourier domain\n\n        Returns:\n        jax.Array\n            Complex multiplication of x_hat and w\n\n        Usage:\n        y_hat = spectral_conv.complex_mult1d(x_hat, w)\n\n        \"\"\"\n        return jnp.einsum(\"iM,ioM-&gt;oM\", x_hat, w)\n\n    def __call__(\n        self,\n        x,\n    ):\n        \"\"\"\n        Forward pass of the SpectralConv1d layer.\n\n        Parameters:\n        x: jax.Array\n            Input array\n\n        Returns:\n        jax.Array\n            Output array\n\n        Usage:\n        y = spectral_conv(x)\n        \"\"\"\n        channels, spatial_points = x.shape\n\n        # shape of x_hat is (in_channels, spatial_points//2+1)\n        x_hat = jnp.fft.rfft(x)\n        # shape of x_hat_under_modes is (in_channels, self.modes)\n        x_hat_under_modes = x_hat[:, : self.modes]\n        weights = self.real_weights + 1j * self.imag_weights\n        # shape of out_hat_under_modes is (out_channels, self.modes)\n        out_hat_under_modes = self.complex_mult1d(x_hat_under_modes, weights)\n\n        # shape of out_hat is (out_channels, spatial_points//2+1)\n        out_hat = jnp.zeros((self.out_channels, x_hat.shape[-1]), dtype=x_hat.dtype)\n        out_hat = out_hat.at[:, : self.modes].set(out_hat_under_modes)\n\n        out = jnp.fft.irfft(out_hat, n=spatial_points)\n\n        return out\n</code></pre>"},{"location":"api/core/sciml/fno/layers/spectral_conv/#scirex.core.sciml.fno.layers.spectral_conv.SpectralConv1d.__call__","title":"<code>__call__(x)</code>","text":"<p>Forward pass of the SpectralConv1d layer.</p> <p>x: jax.Array     Input array</p> <p>jax.Array     Output array</p> <p>Usage: y = spectral_conv(x)</p> Source code in <code>scirex\\core\\sciml\\fno\\layers\\spectral_conv.py</code> <pre><code>def __call__(\n    self,\n    x,\n):\n    \"\"\"\n    Forward pass of the SpectralConv1d layer.\n\n    Parameters:\n    x: jax.Array\n        Input array\n\n    Returns:\n    jax.Array\n        Output array\n\n    Usage:\n    y = spectral_conv(x)\n    \"\"\"\n    channels, spatial_points = x.shape\n\n    # shape of x_hat is (in_channels, spatial_points//2+1)\n    x_hat = jnp.fft.rfft(x)\n    # shape of x_hat_under_modes is (in_channels, self.modes)\n    x_hat_under_modes = x_hat[:, : self.modes]\n    weights = self.real_weights + 1j * self.imag_weights\n    # shape of out_hat_under_modes is (out_channels, self.modes)\n    out_hat_under_modes = self.complex_mult1d(x_hat_under_modes, weights)\n\n    # shape of out_hat is (out_channels, spatial_points//2+1)\n    out_hat = jnp.zeros((self.out_channels, x_hat.shape[-1]), dtype=x_hat.dtype)\n    out_hat = out_hat.at[:, : self.modes].set(out_hat_under_modes)\n\n    out = jnp.fft.irfft(out_hat, n=spatial_points)\n\n    return out\n</code></pre>"},{"location":"api/core/sciml/fno/layers/spectral_conv/#scirex.core.sciml.fno.layers.spectral_conv.SpectralConv1d.__init__","title":"<code>__init__(in_channels, out_channels, modes, *, key)</code>","text":"<p>Constructor for the SpectralConv1d class.</p> <p>in_channels: int     Number of input channels out_channels: int     Number of output channels modes: int     Number of modes key: jax.random.PRNGKey     Random key for initialization</p> <p>Returns: None</p> <p>Usage: spectral_conv = SpectralConv1d(     in_channels=1,     out_channels=1,     modes=64,     key=key, )</p> Source code in <code>scirex\\core\\sciml\\fno\\layers\\spectral_conv.py</code> <pre><code>def __init__(\n    self,\n    in_channels,\n    out_channels,\n    modes,\n    *,\n    key,\n):\n    \"\"\"\n    Constructor for the SpectralConv1d class.\n\n    Parameters:\n    in_channels: int\n        Number of input channels\n    out_channels: int\n        Number of output channels\n    modes: int\n        Number of modes\n    key: jax.random.PRNGKey\n        Random key for initialization\n\n    Returns:\n    None\n\n    Usage:\n    spectral_conv = SpectralConv1d(\n        in_channels=1,\n        out_channels=1,\n        modes=64,\n        key=key,\n    )\n    \"\"\"\n\n    self.in_channels = in_channels\n    self.out_channels = out_channels\n    self.modes = modes\n\n    scale = 1.0 / (in_channels * out_channels)\n\n    real_key, imag_key = jax.random.split(key)\n    self.real_weights = jax.random.uniform(\n        real_key,\n        (in_channels, out_channels, modes),\n        minval=-scale,\n        maxval=+scale,\n    )\n    self.imag_weights = jax.random.uniform(\n        imag_key,\n        (in_channels, out_channels, modes),\n        minval=-scale,\n        maxval=+scale,\n    )\n</code></pre>"},{"location":"api/core/sciml/fno/layers/spectral_conv/#scirex.core.sciml.fno.layers.spectral_conv.SpectralConv1d.complex_mult1d","title":"<code>complex_mult1d(x_hat, w)</code>","text":"<p>Returns the complex multiplication of x_hat and w.</p> <p>x_hat: jax.Array     Input array in the Fourier domain w: jax.Array     Weights in the Fourier domain</p> <p>jax.Array     Complex multiplication of x_hat and w</p> <p>Usage: y_hat = spectral_conv.complex_mult1d(x_hat, w)</p> Source code in <code>scirex\\core\\sciml\\fno\\layers\\spectral_conv.py</code> <pre><code>def complex_mult1d(\n    self,\n    x_hat,\n    w,\n):\n    \"\"\"\n    Returns the complex multiplication of x_hat and w.\n\n    Parameters:\n    x_hat: jax.Array\n        Input array in the Fourier domain\n    w: jax.Array\n        Weights in the Fourier domain\n\n    Returns:\n    jax.Array\n        Complex multiplication of x_hat and w\n\n    Usage:\n    y_hat = spectral_conv.complex_mult1d(x_hat, w)\n\n    \"\"\"\n    return jnp.einsum(\"iM,ioM-&gt;oM\", x_hat, w)\n</code></pre>"},{"location":"api/core/sciml/fno/models/fno/","title":"Fno","text":"<p>Module: fno.py</p> <p>This module provides the implementation of the Fourier Neural Operator (FNO) model.</p> <p>Classes:</p> Name Description <code>FNO1d</code> <p>1D Fourier Neural Operator</p> Dependencies <ul> <li>jax: For array processing</li> <li>equinox: For neural network layers</li> </ul> Key Features <ul> <li>Lifting layer</li> <li>FNO blocks</li> <li>Projection layer</li> </ul> Authors <p>Diya Nag Chaudhury</p> Version Info <p>29/Dec/2024: Initial version - Diya Nag Chaudhury</p> References <p>None</p>"},{"location":"api/core/sciml/fno/models/fno/#scirex.core.sciml.fno.models.fno.FNO1d","title":"<code>FNO1d</code>","text":"<p>               Bases: <code>Module</code></p> <p>A 1D Fourier Neural Operator.</p> <p>This model consists of a lifting layer, followed by a series of FNO blocks, and a projection layer.</p> <p>Attributes: lifting: eqx.nn.Conv1d fno_blocks: List[FNOBlock1d] projection: eqx.nn.Conv1d</p> <p>Methods: init: Initializes the FNO1d object call: Calls the FNO1d object</p> Source code in <code>scirex\\core\\sciml\\fno\\models\\fno.py</code> <pre><code>class FNO1d(eqx.Module):\n    \"\"\"\n    A 1D Fourier Neural Operator.\n\n    This model consists of a lifting layer, followed by a series of FNO blocks,\n    and a projection layer.\n\n    Attributes:\n    lifting: eqx.nn.Conv1d\n    fno_blocks: List[FNOBlock1d]\n    projection: eqx.nn.Conv1d\n\n    Methods:\n    __init__: Initializes the FNO1d object\n    __call__: Calls the FNO1d object\n    \"\"\"\n\n    lifting: eqx.nn.Conv1d\n    fno_blocks: List[FNOBlock1d]\n    projection: eqx.nn.Conv1d\n\n    def __init__(\n        self,\n        in_channels,\n        out_channels,\n        modes,\n        width,\n        activation,\n        n_blocks,\n        *,\n        key,\n    ):\n        \"\"\"\n        Constructor for the FNO1d class.\n\n        Args:\n        in_channels: int\n        out_channels: int\n        modes: int\n        width: int\n        activation: Callable\n        n_blocks: int\n        key: jax.random.PRNGKey\n\n        Returns:\n        None\n\n        Raises:\n        None\n\n        Usage:\n        fno = FNO1d(in_channels, out_channels, modes, width, activation, n_blocks, key)\n\n        \"\"\"\n        key, lifting_key = jax.random.split(key)\n        self.lifting = eqx.nn.Conv1d(\n            in_channels,\n            width,\n            1,\n            key=lifting_key,\n        )\n\n        self.fno_blocks = []\n        for i in range(n_blocks):\n            key, subkey = jax.random.split(key)\n            self.fno_blocks.append(\n                FNOBlock1d(\n                    width,\n                    width,\n                    modes,\n                    activation,\n                    key=subkey,\n                )\n            )\n\n        key, projection_key = jax.random.split(key)\n        self.projection = eqx.nn.Conv1d(\n            width,\n            out_channels,\n            1,\n            key=projection_key,\n        )\n\n    def __call__(\n        self,\n        x,\n    ):\n        \"\"\"\n        Forward pass of the FNO1d model.\n\n        Args:\n        x: jnp.ndarray\n\n        Returns:\n        x: jnp.ndarray\n\n        Raises:\n        None\n\n        Usage:\n        x = fno(x)\n\n        \"\"\"\n\n        x = self.lifting(x)\n\n        for fno_block in self.fno_blocks:\n            x = fno_block(x)\n\n        x = self.projection(x)\n\n        return x\n</code></pre>"},{"location":"api/core/sciml/fno/models/fno/#scirex.core.sciml.fno.models.fno.FNO1d.__call__","title":"<code>__call__(x)</code>","text":"<p>Forward pass of the FNO1d model.</p> <p>Args: x: jnp.ndarray</p> <p>Returns: x: jnp.ndarray</p> <p>Raises: None</p> <p>Usage: x = fno(x)</p> Source code in <code>scirex\\core\\sciml\\fno\\models\\fno.py</code> <pre><code>def __call__(\n    self,\n    x,\n):\n    \"\"\"\n    Forward pass of the FNO1d model.\n\n    Args:\n    x: jnp.ndarray\n\n    Returns:\n    x: jnp.ndarray\n\n    Raises:\n    None\n\n    Usage:\n    x = fno(x)\n\n    \"\"\"\n\n    x = self.lifting(x)\n\n    for fno_block in self.fno_blocks:\n        x = fno_block(x)\n\n    x = self.projection(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/fno/models/fno/#scirex.core.sciml.fno.models.fno.FNO1d.__init__","title":"<code>__init__(in_channels, out_channels, modes, width, activation, n_blocks, *, key)</code>","text":"<p>Constructor for the FNO1d class.</p> <p>Args: in_channels: int out_channels: int modes: int width: int activation: Callable n_blocks: int key: jax.random.PRNGKey</p> <p>Returns: None</p> <p>Raises: None</p> <p>Usage: fno = FNO1d(in_channels, out_channels, modes, width, activation, n_blocks, key)</p> Source code in <code>scirex\\core\\sciml\\fno\\models\\fno.py</code> <pre><code>def __init__(\n    self,\n    in_channels,\n    out_channels,\n    modes,\n    width,\n    activation,\n    n_blocks,\n    *,\n    key,\n):\n    \"\"\"\n    Constructor for the FNO1d class.\n\n    Args:\n    in_channels: int\n    out_channels: int\n    modes: int\n    width: int\n    activation: Callable\n    n_blocks: int\n    key: jax.random.PRNGKey\n\n    Returns:\n    None\n\n    Raises:\n    None\n\n    Usage:\n    fno = FNO1d(in_channels, out_channels, modes, width, activation, n_blocks, key)\n\n    \"\"\"\n    key, lifting_key = jax.random.split(key)\n    self.lifting = eqx.nn.Conv1d(\n        in_channels,\n        width,\n        1,\n        key=lifting_key,\n    )\n\n    self.fno_blocks = []\n    for i in range(n_blocks):\n        key, subkey = jax.random.split(key)\n        self.fno_blocks.append(\n            FNOBlock1d(\n                width,\n                width,\n                modes,\n                activation,\n                key=subkey,\n            )\n        )\n\n    key, projection_key = jax.random.split(key)\n    self.projection = eqx.nn.Conv1d(\n        width,\n        out_channels,\n        1,\n        key=projection_key,\n    )\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/","title":"geometry","text":"<p>Abstract Base Interface for Geometry and Mesh Operations.</p> <p>This module provides the base interface for implementing geometry and mesh handling capabilities in both 2D and 3D. It defines the essential structure for mesh operations including reading, generation, and manipulation.</p> Key functionalities <ul> <li>Abstract interface for mesh reading operations</li> <li>Common mesh generation method definitions</li> <li>VTK file generation specifications</li> <li>Test point extraction framework</li> <li>Mesh type and generation method standardization</li> </ul> The module serves as a foundation for <ul> <li>Both 2D and 3D mesh implementations</li> <li>Various element type support</li> <li>Multiple mesh generation approaches</li> <li>Consistent mesh handling interface</li> </ul> Key classes <ul> <li>Geometry: Abstract base class for all geometry implementations</li> </ul> Dependencies <ul> <li>numpy: For numerical operations</li> <li>meshio: For mesh input/output operations</li> <li>gmsh: For mesh generation capabilities</li> <li>matplotlib: For visualization</li> <li>pyDOE: For sampling methods</li> <li>abc: For abstract base class functionality</li> </ul> Note <p>This module provides only the interface definitions. Concrete implementations must be provided by derived classes for specific dimensional and element type requirements.</p>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry","title":"<code>Geometry</code>","text":"<p>Abstract base class for geometry and mesh operations.</p> <p>This class defines the interface that all geometry implementations must follow, providing the basic structure for mesh handling operations in both 2D and 3D contexts.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> <code>mesh_generation_method</code> <p>Method for mesh generation ('internal'/'external')</p> Example <p>class Geometry2D(Geometry): ...     def init(self, mesh_type='quadrilateral', ...                  method='internal'): ...         super().init(mesh_type, method) ... ...     def read_mesh(self, mesh_file, boundary_level, ...                   sampling_method, refine_level): ...         # Implementation ...         pass ... ...     def generate_vtk_for_test(self): ...         # Implementation ...         pass ... ...     def get_test_points(self): ...         # Implementation ...         return points</p> Note <p>This is an abstract base class. Concrete implementations must override: - read_mesh() - generate_vtk_for_test() - get_test_points()</p> <p>Each implementation should provide appropriate mesh handling for its specific dimensional and element type requirements.</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>class Geometry:\n    \"\"\"Abstract base class for geometry and mesh operations.\n\n    This class defines the interface that all geometry implementations must\n    follow, providing the basic structure for mesh handling operations in\n    both 2D and 3D contexts.\n\n    Attributes:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Example:\n        &gt;&gt;&gt; class Geometry2D(Geometry):\n        ...     def __init__(self, mesh_type='quadrilateral',\n        ...                  method='internal'):\n        ...         super().__init__(mesh_type, method)\n        ...\n        ...     def read_mesh(self, mesh_file, boundary_level,\n        ...                   sampling_method, refine_level):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def generate_vtk_for_test(self):\n        ...         # Implementation\n        ...         pass\n        ...\n        ...     def get_test_points(self):\n        ...         # Implementation\n        ...         return points\n\n    Note:\n        This is an abstract base class. Concrete implementations must override:\n        - read_mesh()\n        - generate_vtk_for_test()\n        - get_test_points()\n\n        Each implementation should provide appropriate mesh handling for its\n        specific dimensional and element type requirements.\n    \"\"\"\n\n    def __init__(self, mesh_type: str, mesh_generation_method: str):\n        \"\"\"\n        Constructor for the Geometry class.\n\n        Args:\n            mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n            mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n        Returns:\n            None\n        \"\"\"\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n\n    @abstractmethod\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n        Args:\n            mesh_file (str): Path to the mesh file\n            boundary_point_refinement_level (int): Level of refinement for boundary points\n            bd_sampling_method (str): Sampling method for boundary points\n            refinement_level (int): Level of mesh refinement\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n        None\n\n        Returns:\n        None\n        \"\"\"\n\n    @abstractmethod\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            points (np.ndarray): Test points extracted from the mesh\n        \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.__init__","title":"<code>__init__(mesh_type, mesh_generation_method)</code>","text":"<p>Constructor for the Geometry class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements (e.g., 'quadrilateral', 'triangle')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method for mesh generation ('internal'/'external')</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>def __init__(self, mesh_type: str, mesh_generation_method: str):\n    \"\"\"\n    Constructor for the Geometry class.\n\n    Args:\n        mesh_type: Type of mesh elements (e.g., 'quadrilateral', 'triangle')\n        mesh_generation_method: Method for mesh generation ('internal'/'external')\n\n    Returns:\n        None\n    \"\"\"\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>  <code>abstractmethod</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Args: None</p> <p>Returns: None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n    None\n\n    Returns:\n    None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.get_test_points","title":"<code>get_test_points()</code>  <code>abstractmethod</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Test points extracted from the mesh</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        points (np.ndarray): Test points extracted from the mesh\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry/#scirex.core.sciml.geometry.geometry.Geometry.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of refinement for boundary points</p> required <code>bd_sampling_method</code> <code>str</code> <p>Sampling method for boundary points</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry.py</code> <pre><code>@abstractmethod\ndef read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Abstract method to read mesh from Gmsh. This method should be implemented by the derived classes.\n\n    Args:\n        mesh_file (str): Path to the mesh file\n        boundary_point_refinement_level (int): Level of refinement for boundary points\n        bd_sampling_method (str): Sampling method for boundary points\n        refinement_level (int): Level of mesh refinement\n\n    Returns:\n        None\n    \"\"\"\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/","title":"geometry_2d","text":"<p>Two-Dimensional Geometry and Mesh Management Implementation.</p> <p>This module provides functionality for handling 2D geometries and meshes, including both internal mesh generation and external mesh reading capabilities. It supports quadrilateral elements and various mesh manipulation operations.</p> Key functionalities <ul> <li>Internal mesh generation for rectangular domains</li> <li>External mesh reading from Gmsh format</li> <li>Boundary point generation and refinement</li> <li>VTK file generation and manipulation</li> <li>Mesh visualization and plotting</li> <li>Adaptive mesh refinement support</li> </ul> The module provides <ul> <li>Flexible mesh generation options</li> <li>Boundary point sampling methods (uniform/LHS)</li> <li>Test point generation</li> <li>Solution visualization tools</li> <li>Mesh quality assessment</li> </ul> Key classes <ul> <li>Geometry_2D: Main class for 2D geometry and mesh operations</li> </ul> Dependencies <ul> <li>numpy: For numerical computations</li> <li>meshio: For mesh I/O operations</li> <li>gmsh: For mesh generation</li> <li>matplotlib: For visualization</li> <li>pyDOE: For Latin Hypercube Sampling</li> </ul> Note <p>Currently supports quadrilateral elements only. The implementation focuses on both structured and unstructured mesh handling with emphasis on finite element applications.</p> Authors <p>Thivin Anandh D (https://thivinanandh.github.io)</p> Version <p>27/Dec/2024: Initial version - Thivin Anandh D</p>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D","title":"<code>Geometry_2D</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>Implements 2D geometry and mesh handling capabilities.</p> <p>This class provides comprehensive functionality for managing 2D meshes, including both internal generation and external mesh reading. It supports various mesh operations, boundary handling, and visualization capabilities.</p> <p>Attributes:</p> Name Type Description <code>mesh_type</code> <p>Type of mesh elements ('quadrilateral')</p> <code>mesh_generation_method</code> <p>Method of mesh generation ('internal'/'external')</p> <code>n_test_points_x</code> <p>Number of test points in x-direction</p> <code>n_test_points_y</code> <p>Number of test points in y-direction</p> <code>output_folder</code> <p>Path for output files</p> <code>is_optimized</code> <p>Flag for mesh optimization</p> <code>n_cells_x</code> <p>Number of cells in x-direction (internal mesh)</p> <code>n_cells_y</code> <p>Number of cells in y-direction (internal mesh)</p> <code>x_limits</code> <p>Domain limits in x-direction</p> <code>y_limits</code> <p>Domain limits in y-direction</p> <code>mesh_file_name</code> <p>Name of external mesh file</p> <code>mesh</code> <p>MeshIO mesh object</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <code>cell_points</code> <p>Array of cell vertices</p> <code>test_points</code> <p>Array of test points</p> Example <p>geometry = Geometry_2D( ...     mesh_type='quadrilateral', ...     mesh_generation_method='internal', ...     n_test_points_x=10, ...     n_test_points_y=10, ...     output_folder='./output' ... ) cells, bounds = geometry.generate_quad_mesh_internal( ...     x_limits=(0,1), ...     y_limits=(0,1), ...     n_cells_x=5, ...     n_cells_y=5, ...     num_boundary_points=40 ... )</p> Note <ul> <li>Only supports quadrilateral elements</li> <li>Internal mesh generation is limited to rectangular domains</li> <li>External mesh reading requires Gmsh format</li> <li>Boundary points can be sampled uniformly or using LHS</li> </ul> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>class Geometry_2D(Geometry):\n    \"\"\"Implements 2D geometry and mesh handling capabilities.\n\n    This class provides comprehensive functionality for managing 2D meshes,\n    including both internal generation and external mesh reading. It supports\n    various mesh operations, boundary handling, and visualization capabilities.\n\n    Attributes:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n        n_cells_x: Number of cells in x-direction (internal mesh)\n        n_cells_y: Number of cells in y-direction (internal mesh)\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        mesh_file_name: Name of external mesh file\n        mesh: MeshIO mesh object\n        bd_dict: Dictionary of boundary points\n        cell_points: Array of cell vertices\n        test_points: Array of test points\n\n    Example:\n        &gt;&gt;&gt; geometry = Geometry_2D(\n        ...     mesh_type='quadrilateral',\n        ...     mesh_generation_method='internal',\n        ...     n_test_points_x=10,\n        ...     n_test_points_y=10,\n        ...     output_folder='./output'\n        ... )\n        &gt;&gt;&gt; cells, bounds = geometry.generate_quad_mesh_internal(\n        ...     x_limits=(0,1),\n        ...     y_limits=(0,1),\n        ...     n_cells_x=5,\n        ...     n_cells_y=5,\n        ...     num_boundary_points=40\n        ... )\n\n    Note:\n        - Only supports quadrilateral elements\n        - Internal mesh generation is limited to rectangular domains\n        - External mesh reading requires Gmsh format\n        - Boundary points can be sampled uniformly or using LHS\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh_type: str,\n        mesh_generation_method: str,\n        n_test_points_x: int,\n        n_test_points_y: int,\n        output_folder: str,\n        is_optimized: bool = False,\n    ):\n        \"\"\"\n        Constructor for Geometry_2D class.\n\n        Args:\n            mesh_type: Type of mesh elements ('quadrilateral')\n            mesh_generation_method: Method of mesh generation ('internal'/'external')\n            n_test_points_x: Number of test points in x-direction\n            n_test_points_y: Number of test points in y-direction\n            output_folder: Path for output files\n            is_optimized: Flag for mesh optimization\n\n        Raises:\n            ValueError: If mesh type or generation method is invalid\n\n        Returns:\n            None\n        \"\"\"\n        # Call the super class constructor\n        super().__init__(mesh_type, mesh_generation_method)\n        self.mesh_type = mesh_type\n        self.mesh_generation_method = mesh_generation_method\n        self.n_test_points_x = n_test_points_x\n        self.n_test_points_y = n_test_points_y\n        self.output_folder = output_folder\n        self.is_optimized = is_optimized\n\n        if self.mesh_generation_method not in [\"internal\", \"external\"]:\n            print(\n                f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\n                \"Mesh generation method should be either internal or external.\"\n            )\n\n        if self.mesh_type not in [\"quadrilateral\"]:\n            print(\n                f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n        # To be filled - only when mesh is internal\n        self.n_cells_x = None\n        self.n_cells_y = None\n        self.x_limits = None\n        self.y_limits = None\n\n        # to be filled by external\n        self.mesh_file_name = None\n        self.mesh = None\n        self.bd_dict = None\n        self.cell_points = None\n        self.test_points = None\n\n    def read_mesh(\n        self,\n        mesh_file: str,\n        boundary_point_refinement_level: int,\n        bd_sampling_method: str,\n        refinement_level: int,\n    ):\n        \"\"\"\n        Reads mesh from a Gmsh .msh file and extracts cell information.\n\n        Args:\n            mesh_file: Path to the mesh file\n            boundary_point_refinement_level: Level of boundary point refinement\n            bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n            refinement_level: Level of mesh refinement\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n\n        Raises:\n            ValueError: If mesh file format is invalid\n        \"\"\"\n\n        self.mesh_file_name = mesh_file\n\n        # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n        file_extension = Path(mesh_file).suffix\n\n        if file_extension != \".mesh\":\n            raise ValueError(\"Mesh file should be in .mesh format.\")\n\n        # Read mesh using meshio\n        self.mesh = meshio.read(mesh_file)\n\n        if self.mesh_type == \"quadrilateral\":\n            # Extract cell information\n            cells = self.mesh.cells_dict[\"quad\"]\n\n        num_cells = cells.shape[0]\n        print(f\"[INFO] : Number of cells = {num_cells}\")\n        cell_points = self.mesh.points[cells][\n            :, :, 0:2\n        ]  # remove the z coordinate, which is 0 for all points\n\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(num_cells):\n            cell = cell_points[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cell_points[i] = cell[np.argsort(angles)]\n\n        # Extract number of points within each cell\n        print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n        # Collect the Boundary point id's within the domain\n        boundary_edges = self.mesh.cells_dict[\"line\"]\n\n        # Using the point id, collect the coordinates of the boundary points\n        boundary_coordinates = self.mesh.points[boundary_edges]\n\n        # Number of Existing Boundary points\n        print(\n            f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n        )\n\n        # now Get the physical tag of the boundary edges\n        boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n        # Generate a Dictionary of boundary tags and boundary coordinates\n        # Keys will be the boundary tags and values will be the list of coordinates\n        boundary_dict = {}\n\n        # refine the boundary points based on the number of boundary points needed\n        for i in range(boundary_coordinates.shape[0]):\n            p1 = boundary_coordinates[i, 0, :]\n            p2 = boundary_coordinates[i, 1, :]\n\n            if bd_sampling_method == \"uniform\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = np.linspace(\n                    p1, p2, pow(2, boundary_point_refinement_level) + 1\n                )\n            elif bd_sampling_method == \"lhs\":\n                # take the current point and next point and then perform a uniform sampling\n                new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n                new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n                new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n            else:\n                print(\n                    f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n                )\n                raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n            # get the boundary tag\n            tag = boundary_tags[i]\n\n            if tag not in boundary_dict:\n                boundary_dict[tag] = new_points\n            else:\n                current_val = new_points\n                prev_val = boundary_dict[tag]\n                final = np.vstack([prev_val, current_val])\n                boundary_dict[tag] = final\n\n        # get unique\n        for tag in boundary_dict.keys():\n            val = boundary_dict[tag]\n            val = np.unique(val, axis=0)\n            boundary_dict[tag] = val\n\n        self.bd_dict = boundary_dict\n        # print the new boundary points  on each boundary tag (key) in a tabular format\n\n        total_bound_points = 0\n        print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n        print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n        for k, v in self.bd_dict.items():\n            print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n            total_bound_points += v.shape[0]\n\n        print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n        # Assign to class values\n        self.cell_points = cell_points\n\n        # generate testvtk\n        self.generate_vtk_for_test()\n\n        return cell_points, self.bd_dict\n\n    def generate_quad_mesh_internal(\n        self,\n        x_limits: tuple,\n        y_limits: tuple,\n        n_cells_x: int,\n        n_cells_y: int,\n        num_boundary_points: int,\n    ):\n        \"\"\"\n        Generate and save a quadrilateral mesh with physical curves.\n\n        Args:\n            x_limits: Domain limits in x-direction\n            y_limits: Domain limits in y-direction\n            n_cells_x: Number of cells in x-direction\n            n_cells_y: Number of cells in y-direction\n            num_boundary_points: Number of boundary points\n\n        Returns:\n            cell_points: Array of cell vertices\n            bd_dict: Dictionary of boundary points\n        \"\"\"\n\n        self.n_cells_x = n_cells_x\n        self.n_cells_y = n_cells_y\n        self.x_limits = x_limits\n        self.y_limits = y_limits\n\n        # generate linspace of points in x and y direction\n        x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n        y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n        # Generate quad cells from the points\n        # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n        cells = []\n\n        for i in range(n_cells_x):\n            for j in range(n_cells_y):\n                # get the four points of the cell\n                p1 = [x[i], y[j]]\n                p2 = [x[i + 1], y[j]]\n                p3 = [x[i + 1], y[j + 1]]\n                p4 = [x[i], y[j + 1]]\n\n                # append the points to the cells\n                cells.append([p1, p2, p3, p4])\n\n        # convert to numpy array\n        cells = np.array(cells, dtype=np.float64)\n\n        # use arctan2 to sort the points in anticlockwise direction\n        # loop over all cells and rearrange the points in anticlockwise direction\n        for i in range(cells.shape[0]):\n            cell = cells[i]\n            # get the centroid of the cell\n            centroid = np.mean(cell, axis=0)\n            # get the angle of each point with respect to the centroid\n            angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n            # sort the points based on the angles\n            cells[i] = cell[np.argsort(angles)]\n\n        # generate a meshio mesh object using the cells\n        self.mesh = meshio.Mesh(\n            points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n        )\n\n        # lets generate the boundary points, this function will return a dictionary of boundary points\n        # the keys will be the boundary tags and values will be the list of boundary points\n        bd_points = {}\n\n        num_bound_per_side = int(num_boundary_points / 4)\n\n        def _temp_bd_func(start, end, num_pts):\n            \"\"\"\n            This function returns the boundary points between the start and end points\n            using lhs sampling.\n\n            Args:\n                start: Start point of the boundary\n                end: End point of the boundary\n                num_pts: Number of boundary points to be generated\n\n            Returns:\n                bd_pts: Array of boundary points\n            \"\"\"\n            # generate the boundary points using lhs as a np.float64 array\n            bd_pts = lhs(1, num_pts).astype(np.float64)\n            # scale the points\n            bd_pts = bd_pts * (end - start) + start\n\n            return bd_pts.reshape(-1)\n\n        # bottom boundary\n        y_bottom = (\n            np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n        ).reshape(-1)\n        x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n        # right boundary\n        x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n            -1\n        )\n        y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1001] = np.vstack([x_right, y_right]).T\n\n        # top boundary\n        y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n            -1\n        )\n        x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n        bd_points[1002] = np.vstack([x_top, y_top]).T\n\n        # left boundary\n        x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n            -1\n        )\n        y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n        bd_points[1003] = np.vstack([x_left, y_left]).T\n\n        self.cell_points = cells\n        self.bd_dict = bd_points\n\n        # generate vtk\n        if not self.is_optimized:\n            self.generate_vtk_for_test()\n\n        return self.cell_points, self.bd_dict\n\n    def generate_vtk_for_test(self):\n        \"\"\"\n        Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # initialise the mesh\n            gmsh.initialize()\n\n            # Now, lets generate the mesh with the points.\n            x_range = self.x_limits[1] - self.x_limits[0]\n            y_range = self.y_limits[1] - self.y_limits[0]\n\n            mesh_size_x = x_range / self.n_test_points_x\n            mesh_size_y = y_range / self.n_test_points_y\n\n            # generate a gmsh with the given parameters\n            Xmin = self.x_limits[0]\n            Xmax = self.x_limits[1]\n            Ymin = self.y_limits[0]\n            Ymax = self.y_limits[1]\n\n            point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n            point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n            point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n            point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n            line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n            line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n            line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n            line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n            face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n            gmsh.model.geo.add_plane_surface([face1])\n\n            # Create the relevant Gmsh data structures\n            # from Gmsh model.\n            gmsh.model.geo.synchronize()\n\n            # Generate mesh:\n            gmsh.model.mesh.generate()\n\n            mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n            gmsh.write(str(mesh_file_name))\n            print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n            # close the gmsh\n            gmsh.finalize()\n\n            # read the mesh using meshio\n            mesh = meshio.gmsh.read(str(mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for internal mesh file generated at \",\n                str(mesh_file_name),\n            )\n\n        elif self.mesh_generation_method == \"external\":\n\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n            # Use the internal mesh to generate the vtk file\n            mesh = meshio.read(str(self.mesh_file_name))\n            meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n            print(\n                \"[INFO] : VTK file for external mesh file generated at \",\n                str(vtk_file_name),\n            )\n\n    def get_test_points(self):\n        \"\"\"\n        This function is used to extract the test points from the given mesh\n\n        Args:\n            None\n\n        Returns:\n            test_points (np.ndarray): Array of test points\n        \"\"\"\n\n        if self.mesh_generation_method == \"internal\":\n            # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n            # code over written to plot from np.linspace instead of vtk file\n            # generate linspace of points in x and y direction based on x and y limits\n            x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n            y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n            # generate meshgrid\n            x_grid, y_grid = np.meshgrid(x, y)\n            # stack the points\n            self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n            return self.test_points\n\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        mesh = meshio.read(str(vtk_file_name))\n        points = mesh.points\n        return points[:, 0:2]  # return only first two columns\n\n    def write_vtk(\n        self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n    ):\n        \"\"\"\n        Writes the data to a VTK file.\n\n        Args:\n            solution: The solution data to be written\n            output_path: The output path for the VTK file\n            filename: The name of the output file\n            data_names: List of data names\n\n        Returns:\n            None\n        \"\"\"\n        # read the existing vtk into file\n        if self.mesh_generation_method == \"internal\":\n            vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n        elif self.mesh_generation_method == \"external\":\n            vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        data = []\n        with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n            for line in File:\n                data.append(line)\n\n        # get the output file name\n        output_file_name = Path(output_path) / filename\n\n        if solution.shape[1] != len(data_names):\n            print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n            print(\n                \"Num Columns in solution = \",\n                solution.shape[1],\n                \" Num of data names = \",\n                len(data_names),\n            )\n            raise ValueError(\"Number of data names and solution columns are not equal\")\n\n        # write the data to the output file\n        with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n            for line in data:\n                FN.write(line)\n                if \"POINT_DATA\" in line.strip():\n                    break\n\n            for i in range(solution.shape[1]):\n                FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n                FN.write(\"LOOKUP_TABLE default\\n\")\n                np.savetxt(FN, solution[:, i])\n                FN.write(\"\\n\")\n\n        # save the vtk file as image\n        # self.save_vtk_as_image(str(output_file_name), data_names)\n\n    def plot_adaptive_mesh(\n        self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n    ):\n        \"\"\"\n        Plots the residuals in each cell of the mesh.\n\n        Args:\n            cells_list: List of cell vertices\n            area_averaged_cell_loss_list: List of area averaged cell loss\n            epoch: The epoch number\n            filename: The output filename\n\n        Returns:\n            None\n        \"\"\"\n\n        plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n        # normalise colors\n        norm = mcolors.Normalize(\n            vmin=np.min(area_averaged_cell_loss_list),\n            vmax=np.max(area_averaged_cell_loss_list),\n        )\n\n        # Create a colormap\n        colormap = plt.cm.jet\n\n        for index, cell in enumerate(cells_list):\n            x = cell[:, 0]\n            y = cell[:, 1]\n\n            x = np.append(x, x[0])\n            y = np.append(y, y[0])\n\n            curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n            color = colormap(norm(curr_cell_loss))\n\n            plt.fill(x, y, color=color, alpha=0.9)\n\n            plt.plot(x, y, \"k\")\n\n            # # compute x_min, x_max, y_min, y_max\n            # x_min = np.min(x)\n            # x_max = np.max(x)\n            # y_min = np.min(y)\n            # y_max = np.max(y)\n\n            # # compute centroid of the cells\n            # centroid = np.array([np.mean(x), np.mean(y)])\n\n            # plot the loss text within the cell\n            # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n        sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n        sm.set_array([])\n        plt.colorbar(sm)\n\n        # output filename\n        output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n        plt.title(f\"Cell Residual\")\n        plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.__init__","title":"<code>__init__(mesh_type, mesh_generation_method, n_test_points_x, n_test_points_y, output_folder, is_optimized=False)</code>","text":"<p>Constructor for Geometry_2D class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_type</code> <code>str</code> <p>Type of mesh elements ('quadrilateral')</p> required <code>mesh_generation_method</code> <code>str</code> <p>Method of mesh generation ('internal'/'external')</p> required <code>n_test_points_x</code> <code>int</code> <p>Number of test points in x-direction</p> required <code>n_test_points_y</code> <code>int</code> <p>Number of test points in y-direction</p> required <code>output_folder</code> <code>str</code> <p>Path for output files</p> required <code>is_optimized</code> <code>bool</code> <p>Flag for mesh optimization</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh type or generation method is invalid</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def __init__(\n    self,\n    mesh_type: str,\n    mesh_generation_method: str,\n    n_test_points_x: int,\n    n_test_points_y: int,\n    output_folder: str,\n    is_optimized: bool = False,\n):\n    \"\"\"\n    Constructor for Geometry_2D class.\n\n    Args:\n        mesh_type: Type of mesh elements ('quadrilateral')\n        mesh_generation_method: Method of mesh generation ('internal'/'external')\n        n_test_points_x: Number of test points in x-direction\n        n_test_points_y: Number of test points in y-direction\n        output_folder: Path for output files\n        is_optimized: Flag for mesh optimization\n\n    Raises:\n        ValueError: If mesh type or generation method is invalid\n\n    Returns:\n        None\n    \"\"\"\n    # Call the super class constructor\n    super().__init__(mesh_type, mesh_generation_method)\n    self.mesh_type = mesh_type\n    self.mesh_generation_method = mesh_generation_method\n    self.n_test_points_x = n_test_points_x\n    self.n_test_points_y = n_test_points_y\n    self.output_folder = output_folder\n    self.is_optimized = is_optimized\n\n    if self.mesh_generation_method not in [\"internal\", \"external\"]:\n        print(\n            f\"Invalid mesh generation method {self.mesh_generation_method} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\n            \"Mesh generation method should be either internal or external.\"\n        )\n\n    if self.mesh_type not in [\"quadrilateral\"]:\n        print(\n            f\"Invalid mesh type {self.mesh_type} in {self.__class__.__name__} from {__name__}.\"\n        )\n        raise ValueError(\"Mesh type should be quadrilateral only.\")\n\n    # To be filled - only when mesh is internal\n    self.n_cells_x = None\n    self.n_cells_y = None\n    self.x_limits = None\n    self.y_limits = None\n\n    # to be filled by external\n    self.mesh_file_name = None\n    self.mesh = None\n    self.bd_dict = None\n    self.cell_points = None\n    self.test_points = None\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.generate_quad_mesh_internal","title":"<code>generate_quad_mesh_internal(x_limits, y_limits, n_cells_x, n_cells_y, num_boundary_points)</code>","text":"<p>Generate and save a quadrilateral mesh with physical curves.</p> <p>Parameters:</p> Name Type Description Default <code>x_limits</code> <code>tuple</code> <p>Domain limits in x-direction</p> required <code>y_limits</code> <code>tuple</code> <p>Domain limits in y-direction</p> required <code>n_cells_x</code> <code>int</code> <p>Number of cells in x-direction</p> required <code>n_cells_y</code> <code>int</code> <p>Number of cells in y-direction</p> required <code>num_boundary_points</code> <code>int</code> <p>Number of boundary points</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_quad_mesh_internal(\n    self,\n    x_limits: tuple,\n    y_limits: tuple,\n    n_cells_x: int,\n    n_cells_y: int,\n    num_boundary_points: int,\n):\n    \"\"\"\n    Generate and save a quadrilateral mesh with physical curves.\n\n    Args:\n        x_limits: Domain limits in x-direction\n        y_limits: Domain limits in y-direction\n        n_cells_x: Number of cells in x-direction\n        n_cells_y: Number of cells in y-direction\n        num_boundary_points: Number of boundary points\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n    \"\"\"\n\n    self.n_cells_x = n_cells_x\n    self.n_cells_y = n_cells_y\n    self.x_limits = x_limits\n    self.y_limits = y_limits\n\n    # generate linspace of points in x and y direction\n    x = np.linspace(x_limits[0], x_limits[1], n_cells_x + 1)\n    y = np.linspace(y_limits[0], y_limits[1], n_cells_y + 1)\n\n    # Generate quad cells from the points\n    # the output should be a list of 4 points for each cell , each being a list of 2 points [x,y]\n    cells = []\n\n    for i in range(n_cells_x):\n        for j in range(n_cells_y):\n            # get the four points of the cell\n            p1 = [x[i], y[j]]\n            p2 = [x[i + 1], y[j]]\n            p3 = [x[i + 1], y[j + 1]]\n            p4 = [x[i], y[j + 1]]\n\n            # append the points to the cells\n            cells.append([p1, p2, p3, p4])\n\n    # convert to numpy array\n    cells = np.array(cells, dtype=np.float64)\n\n    # use arctan2 to sort the points in anticlockwise direction\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(cells.shape[0]):\n        cell = cells[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cells[i] = cell[np.argsort(angles)]\n\n    # generate a meshio mesh object using the cells\n    self.mesh = meshio.Mesh(\n        points=cells.reshape(-1, 2), cells=[(\"quad\", cells.reshape(-1, 4))]\n    )\n\n    # lets generate the boundary points, this function will return a dictionary of boundary points\n    # the keys will be the boundary tags and values will be the list of boundary points\n    bd_points = {}\n\n    num_bound_per_side = int(num_boundary_points / 4)\n\n    def _temp_bd_func(start, end, num_pts):\n        \"\"\"\n        This function returns the boundary points between the start and end points\n        using lhs sampling.\n\n        Args:\n            start: Start point of the boundary\n            end: End point of the boundary\n            num_pts: Number of boundary points to be generated\n\n        Returns:\n            bd_pts: Array of boundary points\n        \"\"\"\n        # generate the boundary points using lhs as a np.float64 array\n        bd_pts = lhs(1, num_pts).astype(np.float64)\n        # scale the points\n        bd_pts = bd_pts * (end - start) + start\n\n        return bd_pts.reshape(-1)\n\n    # bottom boundary\n    y_bottom = (\n        np.ones(num_bound_per_side, dtype=np.float64) * y_limits[0]\n    ).reshape(-1)\n    x_bottom = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1000] = np.vstack([x_bottom, y_bottom]).T\n\n    # right boundary\n    x_right = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[1]).reshape(\n        -1\n    )\n    y_right = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1001] = np.vstack([x_right, y_right]).T\n\n    # top boundary\n    y_top = (np.ones(num_bound_per_side, dtype=np.float64) * y_limits[1]).reshape(\n        -1\n    )\n    x_top = _temp_bd_func(x_limits[0], x_limits[1], num_bound_per_side)\n    bd_points[1002] = np.vstack([x_top, y_top]).T\n\n    # left boundary\n    x_left = (np.ones(num_bound_per_side, dtype=np.float64) * x_limits[0]).reshape(\n        -1\n    )\n    y_left = _temp_bd_func(y_limits[0], y_limits[1], num_bound_per_side)\n    bd_points[1003] = np.vstack([x_left, y_left]).T\n\n    self.cell_points = cells\n    self.bd_dict = bd_points\n\n    # generate vtk\n    if not self.is_optimized:\n        self.generate_vtk_for_test()\n\n    return self.cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.generate_vtk_for_test","title":"<code>generate_vtk_for_test()</code>","text":"<p>Generates a VTK from Mesh file (External) or using gmsh (for Internal).</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def generate_vtk_for_test(self):\n    \"\"\"\n    Generates a VTK from Mesh file (External) or using gmsh (for Internal).\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # initialise the mesh\n        gmsh.initialize()\n\n        # Now, lets generate the mesh with the points.\n        x_range = self.x_limits[1] - self.x_limits[0]\n        y_range = self.y_limits[1] - self.y_limits[0]\n\n        mesh_size_x = x_range / self.n_test_points_x\n        mesh_size_y = y_range / self.n_test_points_y\n\n        # generate a gmsh with the given parameters\n        Xmin = self.x_limits[0]\n        Xmax = self.x_limits[1]\n        Ymin = self.y_limits[0]\n        Ymax = self.y_limits[1]\n\n        point1 = gmsh.model.geo.add_point(Xmin, Ymin, 0, mesh_size_x)\n        point2 = gmsh.model.geo.add_point(Xmax, Ymin, 0, mesh_size_x)\n        point3 = gmsh.model.geo.add_point(Xmax, Ymax, 0, mesh_size_y)\n        point4 = gmsh.model.geo.add_point(Xmin, Ymax, 0, mesh_size_y)\n\n        line1 = gmsh.model.geo.add_line(point1, point2, 1000)  ## Bottom\n        line2 = gmsh.model.geo.add_line(point2, point3, 1001)  ## Right\n        line3 = gmsh.model.geo.add_line(point3, point4, 1002)  ## Top\n        line4 = gmsh.model.geo.add_line(point4, point1, 1003)  ## Left\n\n        face1 = gmsh.model.geo.add_curve_loop([line1, line2, line3, line4])\n\n        gmsh.model.geo.add_plane_surface([face1])\n\n        # Create the relevant Gmsh data structures\n        # from Gmsh model.\n        gmsh.model.geo.synchronize()\n\n        # Generate mesh:\n        gmsh.model.mesh.generate()\n\n        mesh_file_name = Path(self.output_folder) / \"internal.msh\"\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n\n        gmsh.write(str(mesh_file_name))\n        print(\"[INFO] : Internal mesh file generated at \", str(mesh_file_name))\n\n        # close the gmsh\n        gmsh.finalize()\n\n        # read the mesh using meshio\n        mesh = meshio.gmsh.read(str(mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for internal mesh file generated at \",\n            str(mesh_file_name),\n        )\n\n    elif self.mesh_generation_method == \"external\":\n\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n        # Use the internal mesh to generate the vtk file\n        mesh = meshio.read(str(self.mesh_file_name))\n        meshio.vtk.write(str(vtk_file_name), mesh, binary=False, fmt_version=\"4.2\")\n\n        print(\n            \"[INFO] : VTK file for external mesh file generated at \",\n            str(vtk_file_name),\n        )\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.get_test_points","title":"<code>get_test_points()</code>","text":"<p>This function is used to extract the test points from the given mesh</p> <p>Returns:</p> Name Type Description <code>test_points</code> <code>ndarray</code> <p>Array of test points</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def get_test_points(self):\n    \"\"\"\n    This function is used to extract the test points from the given mesh\n\n    Args:\n        None\n\n    Returns:\n        test_points (np.ndarray): Array of test points\n    \"\"\"\n\n    if self.mesh_generation_method == \"internal\":\n        # vtk_file_name  = Path(self.output_folder) / \"internal.vtk\"\n        # code over written to plot from np.linspace instead of vtk file\n        # generate linspace of points in x and y direction based on x and y limits\n        x = np.linspace(self.x_limits[0], self.x_limits[1], self.n_test_points_x)\n        y = np.linspace(self.y_limits[0], self.y_limits[1], self.n_test_points_y)\n        # generate meshgrid\n        x_grid, y_grid = np.meshgrid(x, y)\n        # stack the points\n        self.test_points = np.vstack([x_grid.flatten(), y_grid.flatten()]).T\n\n        return self.test_points\n\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    mesh = meshio.read(str(vtk_file_name))\n    points = mesh.points\n    return points[:, 0:2]  # return only first two columns\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.plot_adaptive_mesh","title":"<code>plot_adaptive_mesh(cells_list, area_averaged_cell_loss_list, epoch, filename='cell_residual')</code>","text":"<p>Plots the residuals in each cell of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>cells_list</code> <p>List of cell vertices</p> required <code>area_averaged_cell_loss_list</code> <p>List of area averaged cell loss</p> required <code>epoch</code> <p>The epoch number</p> required <code>filename</code> <p>The output filename</p> <code>'cell_residual'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def plot_adaptive_mesh(\n    self, cells_list, area_averaged_cell_loss_list, epoch, filename=\"cell_residual\"\n):\n    \"\"\"\n    Plots the residuals in each cell of the mesh.\n\n    Args:\n        cells_list: List of cell vertices\n        area_averaged_cell_loss_list: List of area averaged cell loss\n        epoch: The epoch number\n        filename: The output filename\n\n    Returns:\n        None\n    \"\"\"\n\n    plt.figure(figsize=(6.4, 4.8), dpi=300)\n\n    # normalise colors\n    norm = mcolors.Normalize(\n        vmin=np.min(area_averaged_cell_loss_list),\n        vmax=np.max(area_averaged_cell_loss_list),\n    )\n\n    # Create a colormap\n    colormap = plt.cm.jet\n\n    for index, cell in enumerate(cells_list):\n        x = cell[:, 0]\n        y = cell[:, 1]\n\n        x = np.append(x, x[0])\n        y = np.append(y, y[0])\n\n        curr_cell_loss = float(area_averaged_cell_loss_list[index])\n\n        color = colormap(norm(curr_cell_loss))\n\n        plt.fill(x, y, color=color, alpha=0.9)\n\n        plt.plot(x, y, \"k\")\n\n        # # compute x_min, x_max, y_min, y_max\n        # x_min = np.min(x)\n        # x_max = np.max(x)\n        # y_min = np.min(y)\n        # y_max = np.max(y)\n\n        # # compute centroid of the cells\n        # centroid = np.array([np.mean(x), np.mean(y)])\n\n        # plot the loss text within the cell\n        # plt.text(centroid[0], centroid[1], f\"{curr_cell_loss:.3e}\", fontsize=16, horizontalalignment='center', verticalalignment='center')\n\n    sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n    sm.set_array([])\n    plt.colorbar(sm)\n\n    # output filename\n    output_filename = Path(f\"{self.output_folder}/{filename}_{epoch}.png\")\n    plt.title(f\"Cell Residual\")\n    plt.savefig(str(output_filename), dpi=300)\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.read_mesh","title":"<code>read_mesh(mesh_file, boundary_point_refinement_level, bd_sampling_method, refinement_level)</code>","text":"<p>Reads mesh from a Gmsh .msh file and extracts cell information.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_file</code> <code>str</code> <p>Path to the mesh file</p> required <code>boundary_point_refinement_level</code> <code>int</code> <p>Level of boundary point refinement</p> required <code>bd_sampling_method</code> <code>str</code> <p>Method for boundary point sampling ('uniform'/'lhs')</p> required <code>refinement_level</code> <code>int</code> <p>Level of mesh refinement</p> required <p>Returns:</p> Name Type Description <code>cell_points</code> <p>Array of cell vertices</p> <code>bd_dict</code> <p>Dictionary of boundary points</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mesh file format is invalid</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def read_mesh(\n    self,\n    mesh_file: str,\n    boundary_point_refinement_level: int,\n    bd_sampling_method: str,\n    refinement_level: int,\n):\n    \"\"\"\n    Reads mesh from a Gmsh .msh file and extracts cell information.\n\n    Args:\n        mesh_file: Path to the mesh file\n        boundary_point_refinement_level: Level of boundary point refinement\n        bd_sampling_method: Method for boundary point sampling ('uniform'/'lhs')\n        refinement_level: Level of mesh refinement\n\n    Returns:\n        cell_points: Array of cell vertices\n        bd_dict: Dictionary of boundary points\n\n    Raises:\n        ValueError: If mesh file format is invalid\n    \"\"\"\n\n    self.mesh_file_name = mesh_file\n\n    # bd_sampling_method = \"uniform\"  # \"uniform\" or \"lhs\"\n\n    file_extension = Path(mesh_file).suffix\n\n    if file_extension != \".mesh\":\n        raise ValueError(\"Mesh file should be in .mesh format.\")\n\n    # Read mesh using meshio\n    self.mesh = meshio.read(mesh_file)\n\n    if self.mesh_type == \"quadrilateral\":\n        # Extract cell information\n        cells = self.mesh.cells_dict[\"quad\"]\n\n    num_cells = cells.shape[0]\n    print(f\"[INFO] : Number of cells = {num_cells}\")\n    cell_points = self.mesh.points[cells][\n        :, :, 0:2\n    ]  # remove the z coordinate, which is 0 for all points\n\n    # loop over all cells and rearrange the points in anticlockwise direction\n    for i in range(num_cells):\n        cell = cell_points[i]\n        # get the centroid of the cell\n        centroid = np.mean(cell, axis=0)\n        # get the angle of each point with respect to the centroid\n        angles = np.arctan2(cell[:, 1] - centroid[1], cell[:, 0] - centroid[0])\n        # sort the points based on the angles\n        cell_points[i] = cell[np.argsort(angles)]\n\n    # Extract number of points within each cell\n    print(f\"[INFO] : Number of points per cell = {cell_points.shape}\")\n\n    # Collect the Boundary point id's within the domain\n    boundary_edges = self.mesh.cells_dict[\"line\"]\n\n    # Using the point id, collect the coordinates of the boundary points\n    boundary_coordinates = self.mesh.points[boundary_edges]\n\n    # Number of Existing Boundary points\n    print(\n        f\"[INFO] : Number of Bound points before refinement = {np.unique(boundary_coordinates.reshape(-1,3)).shape[0] * 0.5 + 1}\"\n    )\n\n    # now Get the physical tag of the boundary edges\n    boundary_tags = self.mesh.cell_data[\"medit:ref\"][0]\n\n    # Generate a Dictionary of boundary tags and boundary coordinates\n    # Keys will be the boundary tags and values will be the list of coordinates\n    boundary_dict = {}\n\n    # refine the boundary points based on the number of boundary points needed\n    for i in range(boundary_coordinates.shape[0]):\n        p1 = boundary_coordinates[i, 0, :]\n        p2 = boundary_coordinates[i, 1, :]\n\n        if bd_sampling_method == \"uniform\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = np.linspace(\n                p1, p2, pow(2, boundary_point_refinement_level) + 1\n            )\n        elif bd_sampling_method == \"lhs\":\n            # take the current point and next point and then perform a uniform sampling\n            new_points = lhs(2, pow(2, boundary_point_refinement_level) + 1)\n            new_points[:, 0] = new_points[:, 0] * (p2[0] - p1[0]) + p1[0]\n            new_points[:, 1] = new_points[:, 1] * (p2[1] - p1[1]) + p1[1]\n        else:\n            print(\n                f\"Invalid sampling method {bd_sampling_method} in {self.__class__.__name__} from {__name__}.\"\n            )\n            raise ValueError(\"Sampling method should be either uniform or lhs.\")\n\n        # get the boundary tag\n        tag = boundary_tags[i]\n\n        if tag not in boundary_dict:\n            boundary_dict[tag] = new_points\n        else:\n            current_val = new_points\n            prev_val = boundary_dict[tag]\n            final = np.vstack([prev_val, current_val])\n            boundary_dict[tag] = final\n\n    # get unique\n    for tag in boundary_dict.keys():\n        val = boundary_dict[tag]\n        val = np.unique(val, axis=0)\n        boundary_dict[tag] = val\n\n    self.bd_dict = boundary_dict\n    # print the new boundary points  on each boundary tag (key) in a tabular format\n\n    total_bound_points = 0\n    print(f\"| {'Boundary ID':&lt;12} | {'Number of Points':&lt;16} |\")\n    print(f\"| {'-'*12:&lt;12}---{'-'*16:&lt;16} |\")\n    for k, v in self.bd_dict.items():\n        print(f\"| {k:&lt;12} | {v.shape[0]:&lt;16} |\")\n        total_bound_points += v.shape[0]\n\n    print(f\"[INFO] : No of bound pts after refinement:  {total_bound_points}\")\n\n    # Assign to class values\n    self.cell_points = cell_points\n\n    # generate testvtk\n    self.generate_vtk_for_test()\n\n    return cell_points, self.bd_dict\n</code></pre>"},{"location":"api/core/sciml/geometry/geometry_2d/#scirex.core.sciml.geometry.geometry_2d.Geometry_2D.write_vtk","title":"<code>write_vtk(solution, output_path, filename, data_names)</code>","text":"<p>Writes the data to a VTK file.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>ndarray</code> <p>The solution data to be written</p> required <code>output_path</code> <code>str</code> <p>The output path for the VTK file</p> required <code>filename</code> <code>str</code> <p>The name of the output file</p> required <code>data_names</code> <code>list</code> <p>List of data names</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\geometry\\geometry_2d.py</code> <pre><code>def write_vtk(\n    self, solution: np.ndarray, output_path: str, filename: str, data_names: list\n):\n    \"\"\"\n    Writes the data to a VTK file.\n\n    Args:\n        solution: The solution data to be written\n        output_path: The output path for the VTK file\n        filename: The name of the output file\n        data_names: List of data names\n\n    Returns:\n        None\n    \"\"\"\n    # read the existing vtk into file\n    if self.mesh_generation_method == \"internal\":\n        vtk_file_name = Path(self.output_folder) / \"internal.vtk\"\n    elif self.mesh_generation_method == \"external\":\n        vtk_file_name = Path(self.output_folder) / \"external.vtk\"\n\n    data = []\n    with open(vtk_file_name, \"r\", encoding=\"utf-8\") as File:\n        for line in File:\n            data.append(line)\n\n    # get the output file name\n    output_file_name = Path(output_path) / filename\n\n    if solution.shape[1] != len(data_names):\n        print(\"[Error] : File : geometry_2d.py, Function: write_vtk\")\n        print(\n            \"Num Columns in solution = \",\n            solution.shape[1],\n            \" Num of data names = \",\n            len(data_names),\n        )\n        raise ValueError(\"Number of data names and solution columns are not equal\")\n\n    # write the data to the output file\n    with open(str(output_file_name), \"w\", encoding=\"utf-8\") as FN:\n        for line in data:\n            FN.write(line)\n            if \"POINT_DATA\" in line.strip():\n                break\n\n        for i in range(solution.shape[1]):\n            FN.write(\"SCALARS \" + data_names[i] + \" float\\n\")\n            FN.write(\"LOOKUP_TABLE default\\n\")\n            np.savetxt(FN, solution[:, i])\n            FN.write(\"\\n\")\n</code></pre>"},{"location":"api/core/sciml/pinns/model/model/","title":"Model","text":"<p>Neural Network Model Implementation for Physics-Informed Neural Networks.</p> <p>This module implements the neural network architecture and training loop for solving PDEs using physics-informed neural networks (VPINNs). It provides a flexible framework for handling various PDEs through custom loss functions.</p> The implementation supports <ul> <li>Flexible neural network architectures</li> <li>Dirichlet boundary conditions</li> <li>Custom loss function composition</li> <li>Adaptive learning rate scheduling</li> <li>Automatic differentiation for gradients</li> </ul> Key classes <ul> <li>DenseModel: Neural network model for VPINN implementation</li> </ul> Authors <ul> <li>Divij Ghose (https://divijghose.github.io/)</li> </ul> Versions <ul> <li>27-Dec-2024 (Version 0.1): Initial Implementation</li> </ul>"},{"location":"api/core/sciml/pinns/model/model/#scirex.core.sciml.pinns.model.model.DenseModel","title":"<code>DenseModel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network model for solving PDEs using PINNs.</p> <p>This class implements a custom neural network architecture for solving partial differential equations using Physics Informed Neural Networks. It supports flexible layer configurations and various loss components.</p> <p>Attributes:</p> Name Type Description <code>layer_dims</code> <p>List of neurons per layer including input/output</p> <code>learning_rate_dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> <code>params_dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> <code>loss_function</code> <p>Custom loss function for PDE residuals</p> <code>input_tensors_list</code> <p>List containing: [0]: input_tensor - Main computation points [1]: dirichlet_input - Boundary points [2]: dirichlet_actual - Boundary values</p> <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> <code>use_attention</code> <p>Whether to use attention mechanism</p> <code>activation</code> <p>Activation function for hidden layers</p> <code>optimizer</code> <p>Adam optimizer with optional learning rate schedule</p> Example <p>model = DenseModel( ...     layer_dims=[2, 64, 64, 1], ...     learning_rate_dict={'initial_learning_rate': 0.001}, ...     params_dict={'n_cells': 100}, ...     loss_function=custom_loss, ...     tensor_dtype=tf.float32 ... ) history = model.fit(x_train, epochs=1000)</p> Note <p>The training process balances PDE residuals and boundary conditions through a weighted loss function.</p> Source code in <code>scirex\\core\\sciml\\pinns\\model\\model.py</code> <pre><code>class DenseModel(tf.keras.Model):\n    \"\"\"Neural network model for solving PDEs using PINNs.\n\n    This class implements a custom neural network architecture for solving\n    partial differential equations using Physics Informed Neural Networks.\n    It supports flexible layer configurations and various loss components.\n\n    Attributes:\n        layer_dims: List of neurons per layer including input/output\n        learning_rate_dict: Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict: Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list: List containing:\n            [0]: input_tensor - Main computation points\n            [1]: dirichlet_input - Boundary points\n            [2]: dirichlet_actual - Boundary values\n        tensor_dtype: TensorFlow data type for computations\n        use_attention: Whether to use attention mechanism\n        activation: Activation function for hidden layers\n        optimizer: Adam optimizer with optional learning rate schedule\n\n    Example:\n        &gt;&gt;&gt; model = DenseModel(\n        ...     layer_dims=[2, 64, 64, 1],\n        ...     learning_rate_dict={'initial_learning_rate': 0.001},\n        ...     params_dict={'n_cells': 100},\n        ...     loss_function=custom_loss,\n        ...     tensor_dtype=tf.float32\n        ... )\n        &gt;&gt;&gt; history = model.fit(x_train, epochs=1000)\n\n    Note:\n        The training process balances PDE residuals and boundary conditions\n        through a weighted loss function.\n    \"\"\"\n\n    def __init__(\n        self,\n        layer_dims: list,\n        learning_rate_dict: dict,\n        params_dict: dict,\n        loss_function,\n        input_tensors_list: list,\n        force_function_list: list,\n        tensor_dtype,\n        use_attention=False,\n        activation=\"tanh\",\n        hessian=False,\n    ):\n        \"\"\"\n        Initialize the DenseModel class.\n\n        Args:\n            layer_dims (list): List of neurons per layer including input/output.\n            learning_rate_dict (dict): Learning rate configuration containing:\n                - initial_learning_rate: Starting learning rate\n                - use_lr_scheduler: Whether to use learning rate decay\n                - decay_steps: Steps between learning rate updates\n                - decay_rate: Factor for learning rate decay\n            params_dict (dict): Model parameters including:\n                - n_cells: Number of cells in the domain\n            loss_function: Custom loss function for PDE residuals\n            input_tensors_list: List containing:\n                [0]: input_tensor - Main computation points\n                [1]: dirichlet_input - Boundary points\n                [2]: dirichlet_actual - Boundary values\n            force_function_list: List containing:\n                - forcing_function: Forcing function values\n            tensor_dtype: TensorFlow data type for computations\n            use_attention (bool): Whether to use attention mechanism, defaults to False.\n            activation (str): Activation function for hidden layers, defaults to \"tanh\".\n            hessian (bool): Whether to compute Hessian matrix, defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        super(DenseModel, self).__init__()\n        self.layer_dims = layer_dims\n        self.use_attention = use_attention\n        self.activation = activation\n        self.layer_list = []\n        self.loss_function = loss_function\n        self.hessian = hessian\n\n        self.tensor_dtype = tensor_dtype\n\n        # if dtype is not a valid tensorflow dtype, raise an error\n        if not isinstance(self.tensor_dtype, tf.DType):\n            raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n        self.force_function_list = force_function_list\n\n        self.input_tensors_list = input_tensors_list\n        self.input_tensor = copy.deepcopy(input_tensors_list[0])\n        self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n        self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n        self.params_dict = params_dict\n\n        self.force_matrix = self.force_function_list\n\n        print(f\"{'-'*74}\")\n        print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n        print(f\"{'-'*74}\")\n        print(\n            f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n        )\n        print(\n            f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n        )\n        print(\n            f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n        )\n        print(f\"{'-'*74}\")\n\n        self.n_cells = params_dict[\"n_cells\"]\n\n        ## ----------------------------------------------------------------- ##\n        ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # parse the learning rate dictionary\n        self.learning_rate_dict = learning_rate_dict\n        initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n        use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n        decay_steps = learning_rate_dict[\"decay_steps\"]\n        decay_rate = learning_rate_dict[\"decay_rate\"]\n        # staircase = learning_rate_dict[\"staircase\"]\n\n        if use_lr_scheduler:\n            learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n                initial_learning_rate, decay_steps, decay_rate, staircase=True\n            )\n        else:\n            learning_rate_fn = initial_learning_rate\n\n        self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n        ## ----------------------------------------------------------------- ##\n        ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n        ## ----------------------------------------------------------------- ##\n\n        # Build dense layers based on the input list\n        for dim in range(len(self.layer_dims) - 2):\n            self.layer_list.append(\n                TensorflowDense.create_layer(\n                    units=self.layer_dims[dim],\n                    activation=self.activation,\n                    dtype=self.tensor_dtype,\n                    kernel_initializer=\"glorot_uniform\",\n                    bias_initializer=\"zeros\",\n                )\n            )\n\n        # Add a output layer with no activation\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[-1],\n                activation=None,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n        # Add attention layer if required\n        if self.use_attention:\n            self.attention_layer = layers.Attention()\n\n        # Compile the model\n        self.compile(optimizer=self.optimizer)\n        self.build(input_shape=(None, self.layer_dims[0]))\n\n        # print the summary of the model\n        self.summary()\n\n    # def build(self, input_shape):\n    #     super(DenseModel, self).build(input_shape)\n\n    def call(self, inputs) -&gt; tf.Tensor:\n        \"\"\"\n        The call method for the model.\n\n        Args:\n            inputs: The input tensor for the model.\n\n        Returns:\n            tf.Tensor: The output tensor from the model.\n        \"\"\"\n        x = inputs\n\n        # Apply attention layer after input if flag is True\n        if self.use_attention:\n            x = self.attention_layer([x, x])\n\n        # Loop through the dense layers\n        for layer in self.layer_list:\n            x = layer(x)\n\n        return x\n\n    def get_config(self) -&gt; dict:\n        \"\"\"\n        Get the configuration of the model.\n\n        Returns:\n            dict: The configuration of the model.\n        \"\"\"\n        # Get the base configuration\n        base_config = super().get_config()\n\n        # Add the non-serializable arguments to the configuration\n        base_config.update(\n            {\n                \"learning_rate_dict\": self.learning_rate_dict,\n                \"loss_function\": self.loss_function,\n                \"input_tensors_list\": self.input_tensors_list,\n                \"force_function_list\": self.force_function_list,\n                \"params_dict\": self.params_dict,\n                \"use_attention\": self.use_attention,\n                \"activation\": self.activation,\n                \"hessian\": self.hessian,\n                \"layer_dims\": self.layer_dims,\n                \"tensor_dtype\": self.tensor_dtype,\n            }\n        )\n\n        return base_config\n\n    @tf.function\n    def train_step(self, beta=10, bilinear_params_dict=None) -&gt; dict:\n        \"\"\"\n        The train step method for the model.\n\n        Args:\n            beta (int): The weight for the boundary loss, defaults to 10.\n            bilinear_params_dict (dict): The bilinear parameters dictionary, defaults to None.\n\n        Returns:\n            dict: The loss values for the model.\n        \"\"\"\n\n        with tf.GradientTape(persistent=True) as tape:\n            # Predict the values for dirichlet boundary conditions\n            predicted_values_dirichlet = self(self.dirichlet_input)\n\n            # initialize total loss as a tensor with shape (1,) and value 0.0\n            total_pde_loss = 0.0\n\n            with tf.GradientTape(persistent=True) as tape1:\n                # tape gradient\n                tape1.watch(self.input_tensor)\n\n                with tf.GradientTape(persistent=True) as tape2:\n                    tape2.watch(self.input_tensor)\n                    # Compute the predicted values from the model\n                    # Compute the predicted values from the model\n                    predicted_values = self(self.input_tensor)\n\n                    # compute the gradients of the predicted values wrt the input which is (x, y)\n                    gradients = tape2.gradient(predicted_values, self.input_tensor)\n                    pred_grad_x = gradients[:, 0]\n                    pred_grad_y = gradients[:, 1]\n\n                tape1.watch(gradients)\n\n            # Compute the second order derivatives\n            second_order_derivatives = tape1.gradient(gradients, self.input_tensor)\n            pred_grad_xx = second_order_derivatives[:, 0]\n            pred_grad_yy = second_order_derivatives[:, 1]\n\n            pde_residual = self.loss_function(\n                pred_nn=predicted_values,\n                pred_grad_x_nn=pred_grad_x,\n                pred_grad_y_nn=pred_grad_y,\n                pred_grad_xx_nn=pred_grad_xx,\n                pred_grad_yy_nn=pred_grad_yy,\n                forcing_function=self.force_matrix,\n                bilinear_params=bilinear_params_dict,\n            )\n\n            # Compute the total loss for the PDE\n            total_pde_loss = total_pde_loss + pde_residual\n\n            # print shapes of the predicted values and the actual values\n            boundary_loss = tf.reduce_mean(\n                tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n            )\n\n            # Compute Total Loss\n            total_loss = total_pde_loss + beta * boundary_loss\n\n        trainable_vars = self.trainable_variables\n        self.gradients = tape.gradient(total_loss, trainable_vars)\n        self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n        return {\n            \"loss_pde\": total_pde_loss,\n            \"loss_dirichlet\": boundary_loss,\n            \"loss\": total_loss,\n        }\n</code></pre>"},{"location":"api/core/sciml/pinns/model/model/#scirex.core.sciml.pinns.model.model.DenseModel.__init__","title":"<code>__init__(layer_dims, learning_rate_dict, params_dict, loss_function, input_tensors_list, force_function_list, tensor_dtype, use_attention=False, activation='tanh', hessian=False)</code>","text":"<p>Initialize the DenseModel class.</p> <p>Parameters:</p> Name Type Description Default <code>layer_dims</code> <code>list</code> <p>List of neurons per layer including input/output.</p> required <code>learning_rate_dict</code> <code>dict</code> <p>Learning rate configuration containing: - initial_learning_rate: Starting learning rate - use_lr_scheduler: Whether to use learning rate decay - decay_steps: Steps between learning rate updates - decay_rate: Factor for learning rate decay</p> required <code>params_dict</code> <code>dict</code> <p>Model parameters including: - n_cells: Number of cells in the domain</p> required <code>loss_function</code> <p>Custom loss function for PDE residuals</p> required <code>input_tensors_list</code> <code>list</code> <p>List containing: [0]: input_tensor - Main computation points [1]: dirichlet_input - Boundary points [2]: dirichlet_actual - Boundary values</p> required <code>force_function_list</code> <code>list</code> <p>List containing: - forcing_function: Forcing function values</p> required <code>tensor_dtype</code> <p>TensorFlow data type for computations</p> required <code>use_attention</code> <code>bool</code> <p>Whether to use attention mechanism, defaults to False.</p> <code>False</code> <code>activation</code> <code>str</code> <p>Activation function for hidden layers, defaults to \"tanh\".</p> <code>'tanh'</code> <code>hessian</code> <code>bool</code> <p>Whether to compute Hessian matrix, defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scirex\\core\\sciml\\pinns\\model\\model.py</code> <pre><code>def __init__(\n    self,\n    layer_dims: list,\n    learning_rate_dict: dict,\n    params_dict: dict,\n    loss_function,\n    input_tensors_list: list,\n    force_function_list: list,\n    tensor_dtype,\n    use_attention=False,\n    activation=\"tanh\",\n    hessian=False,\n):\n    \"\"\"\n    Initialize the DenseModel class.\n\n    Args:\n        layer_dims (list): List of neurons per layer including input/output.\n        learning_rate_dict (dict): Learning rate configuration containing:\n            - initial_learning_rate: Starting learning rate\n            - use_lr_scheduler: Whether to use learning rate decay\n            - decay_steps: Steps between learning rate updates\n            - decay_rate: Factor for learning rate decay\n        params_dict (dict): Model parameters including:\n            - n_cells: Number of cells in the domain\n        loss_function: Custom loss function for PDE residuals\n        input_tensors_list: List containing:\n            [0]: input_tensor - Main computation points\n            [1]: dirichlet_input - Boundary points\n            [2]: dirichlet_actual - Boundary values\n        force_function_list: List containing:\n            - forcing_function: Forcing function values\n        tensor_dtype: TensorFlow data type for computations\n        use_attention (bool): Whether to use attention mechanism, defaults to False.\n        activation (str): Activation function for hidden layers, defaults to \"tanh\".\n        hessian (bool): Whether to compute Hessian matrix, defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    super(DenseModel, self).__init__()\n    self.layer_dims = layer_dims\n    self.use_attention = use_attention\n    self.activation = activation\n    self.layer_list = []\n    self.loss_function = loss_function\n    self.hessian = hessian\n\n    self.tensor_dtype = tensor_dtype\n\n    # if dtype is not a valid tensorflow dtype, raise an error\n    if not isinstance(self.tensor_dtype, tf.DType):\n        raise TypeError(\"The given dtype is not a valid tensorflow dtype\")\n\n    self.force_function_list = force_function_list\n\n    self.input_tensors_list = input_tensors_list\n    self.input_tensor = copy.deepcopy(input_tensors_list[0])\n    self.dirichlet_input = copy.deepcopy(input_tensors_list[1])\n    self.dirichlet_actual = copy.deepcopy(input_tensors_list[2])\n\n    self.params_dict = params_dict\n\n    self.force_matrix = self.force_function_list\n\n    print(f\"{'-'*74}\")\n    print(f\"| {'PARAMETER':&lt;25} | {'SHAPE':&lt;25} |\")\n    print(f\"{'-'*74}\")\n    print(\n        f\"| {'input_tensor':&lt;25} | {str(self.input_tensor.shape):&lt;25} | {self.input_tensor.dtype}\"\n    )\n    print(\n        f\"| {'force_matrix':&lt;25} | {str(self.force_matrix.shape):&lt;25} | {self.force_matrix.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_input':&lt;25} | {str(self.dirichlet_input.shape):&lt;25} | {self.dirichlet_input.dtype}\"\n    )\n    print(\n        f\"| {'dirichlet_actual':&lt;25} | {str(self.dirichlet_actual.shape):&lt;25} | {self.dirichlet_actual.dtype}\"\n    )\n    print(f\"{'-'*74}\")\n\n    self.n_cells = params_dict[\"n_cells\"]\n\n    ## ----------------------------------------------------------------- ##\n    ## ---------- LEARNING RATE AND OPTIMISER FOR THE MODEL ------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # parse the learning rate dictionary\n    self.learning_rate_dict = learning_rate_dict\n    initial_learning_rate = learning_rate_dict[\"initial_learning_rate\"]\n    use_lr_scheduler = learning_rate_dict[\"use_lr_scheduler\"]\n    decay_steps = learning_rate_dict[\"decay_steps\"]\n    decay_rate = learning_rate_dict[\"decay_rate\"]\n    # staircase = learning_rate_dict[\"staircase\"]\n\n    if use_lr_scheduler:\n        learning_rate_fn = tf.keras.optimizers.schedules.ExponentialDecay(\n            initial_learning_rate, decay_steps, decay_rate, staircase=True\n        )\n    else:\n        learning_rate_fn = initial_learning_rate\n\n    self.optimizer = tf.keras.optimizers.Adam(learning_rate=learning_rate_fn)\n\n    ## ----------------------------------------------------------------- ##\n    ## --------------------- MODEL ARCHITECTURE ------------------------ ##\n    ## ----------------------------------------------------------------- ##\n\n    # Build dense layers based on the input list\n    for dim in range(len(self.layer_dims) - 2):\n        self.layer_list.append(\n            TensorflowDense.create_layer(\n                units=self.layer_dims[dim],\n                activation=self.activation,\n                dtype=self.tensor_dtype,\n                kernel_initializer=\"glorot_uniform\",\n                bias_initializer=\"zeros\",\n            )\n        )\n\n    # Add a output layer with no activation\n    self.layer_list.append(\n        TensorflowDense.create_layer(\n            units=self.layer_dims[-1],\n            activation=None,\n            dtype=self.tensor_dtype,\n            kernel_initializer=\"glorot_uniform\",\n            bias_initializer=\"zeros\",\n        )\n    )\n\n    # Add attention layer if required\n    if self.use_attention:\n        self.attention_layer = layers.Attention()\n\n    # Compile the model\n    self.compile(optimizer=self.optimizer)\n    self.build(input_shape=(None, self.layer_dims[0]))\n\n    # print the summary of the model\n    self.summary()\n</code></pre>"},{"location":"api/core/sciml/pinns/model/model/#scirex.core.sciml.pinns.model.model.DenseModel.call","title":"<code>call(inputs)</code>","text":"<p>The call method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>The input tensor for the model.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: The output tensor from the model.</p> Source code in <code>scirex\\core\\sciml\\pinns\\model\\model.py</code> <pre><code>def call(self, inputs) -&gt; tf.Tensor:\n    \"\"\"\n    The call method for the model.\n\n    Args:\n        inputs: The input tensor for the model.\n\n    Returns:\n        tf.Tensor: The output tensor from the model.\n    \"\"\"\n    x = inputs\n\n    # Apply attention layer after input if flag is True\n    if self.use_attention:\n        x = self.attention_layer([x, x])\n\n    # Loop through the dense layers\n    for layer in self.layer_list:\n        x = layer(x)\n\n    return x\n</code></pre>"},{"location":"api/core/sciml/pinns/model/model/#scirex.core.sciml.pinns.model.model.DenseModel.get_config","title":"<code>get_config()</code>","text":"<p>Get the configuration of the model.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The configuration of the model.</p> Source code in <code>scirex\\core\\sciml\\pinns\\model\\model.py</code> <pre><code>def get_config(self) -&gt; dict:\n    \"\"\"\n    Get the configuration of the model.\n\n    Returns:\n        dict: The configuration of the model.\n    \"\"\"\n    # Get the base configuration\n    base_config = super().get_config()\n\n    # Add the non-serializable arguments to the configuration\n    base_config.update(\n        {\n            \"learning_rate_dict\": self.learning_rate_dict,\n            \"loss_function\": self.loss_function,\n            \"input_tensors_list\": self.input_tensors_list,\n            \"force_function_list\": self.force_function_list,\n            \"params_dict\": self.params_dict,\n            \"use_attention\": self.use_attention,\n            \"activation\": self.activation,\n            \"hessian\": self.hessian,\n            \"layer_dims\": self.layer_dims,\n            \"tensor_dtype\": self.tensor_dtype,\n        }\n    )\n\n    return base_config\n</code></pre>"},{"location":"api/core/sciml/pinns/model/model/#scirex.core.sciml.pinns.model.model.DenseModel.train_step","title":"<code>train_step(beta=10, bilinear_params_dict=None)</code>","text":"<p>The train step method for the model.</p> <p>Parameters:</p> Name Type Description Default <code>beta</code> <code>int</code> <p>The weight for the boundary loss, defaults to 10.</p> <code>10</code> <code>bilinear_params_dict</code> <code>dict</code> <p>The bilinear parameters dictionary, defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loss values for the model.</p> Source code in <code>scirex\\core\\sciml\\pinns\\model\\model.py</code> <pre><code>@tf.function\ndef train_step(self, beta=10, bilinear_params_dict=None) -&gt; dict:\n    \"\"\"\n    The train step method for the model.\n\n    Args:\n        beta (int): The weight for the boundary loss, defaults to 10.\n        bilinear_params_dict (dict): The bilinear parameters dictionary, defaults to None.\n\n    Returns:\n        dict: The loss values for the model.\n    \"\"\"\n\n    with tf.GradientTape(persistent=True) as tape:\n        # Predict the values for dirichlet boundary conditions\n        predicted_values_dirichlet = self(self.dirichlet_input)\n\n        # initialize total loss as a tensor with shape (1,) and value 0.0\n        total_pde_loss = 0.0\n\n        with tf.GradientTape(persistent=True) as tape1:\n            # tape gradient\n            tape1.watch(self.input_tensor)\n\n            with tf.GradientTape(persistent=True) as tape2:\n                tape2.watch(self.input_tensor)\n                # Compute the predicted values from the model\n                # Compute the predicted values from the model\n                predicted_values = self(self.input_tensor)\n\n                # compute the gradients of the predicted values wrt the input which is (x, y)\n                gradients = tape2.gradient(predicted_values, self.input_tensor)\n                pred_grad_x = gradients[:, 0]\n                pred_grad_y = gradients[:, 1]\n\n            tape1.watch(gradients)\n\n        # Compute the second order derivatives\n        second_order_derivatives = tape1.gradient(gradients, self.input_tensor)\n        pred_grad_xx = second_order_derivatives[:, 0]\n        pred_grad_yy = second_order_derivatives[:, 1]\n\n        pde_residual = self.loss_function(\n            pred_nn=predicted_values,\n            pred_grad_x_nn=pred_grad_x,\n            pred_grad_y_nn=pred_grad_y,\n            pred_grad_xx_nn=pred_grad_xx,\n            pred_grad_yy_nn=pred_grad_yy,\n            forcing_function=self.force_matrix,\n            bilinear_params=bilinear_params_dict,\n        )\n\n        # Compute the total loss for the PDE\n        total_pde_loss = total_pde_loss + pde_residual\n\n        # print shapes of the predicted values and the actual values\n        boundary_loss = tf.reduce_mean(\n            tf.square(predicted_values_dirichlet - self.dirichlet_actual), axis=0\n        )\n\n        # Compute Total Loss\n        total_loss = total_pde_loss + beta * boundary_loss\n\n    trainable_vars = self.trainable_variables\n    self.gradients = tape.gradient(total_loss, trainable_vars)\n    self.optimizer.apply_gradients(zip(self.gradients, trainable_vars))\n\n    return {\n        \"loss_pde\": total_pde_loss,\n        \"loss_dirichlet\": boundary_loss,\n        \"loss\": total_loss,\n    }\n</code></pre>"},{"location":"api/core/sciml/pinns/physics/cd2d/","title":"Loss Function Implementation for 2D Convection-Diffusion Problem","text":""},{"location":"api/core/sciml/pinns/physics/cd2d/#overview","title":"Overview","text":"<p>This module implements the loss function for solving 2D convection-diffusion equations using Physics-Informed Neural Networks (PINNs). It focuses on computing residuals of the Partial Differential Equation (PDE) with known coefficients.</p>"},{"location":"api/core/sciml/pinns/physics/cd2d/#key-functions","title":"Key Functions","text":"<ul> <li><code>pde_loss_cd2d</code>: Computes the PDE loss for 2D convection-diffusion equations.</li> </ul>"},{"location":"api/core/sciml/pinns/physics/cd2d/#function-pde_loss_cd2d","title":"Function: <code>pde_loss_cd2d</code>","text":""},{"location":"api/core/sciml/pinns/physics/cd2d/#description","title":"Description","text":"<p>Calculates residuals for the 2D convection-diffusion problem using the PINNs methodology. The loss function includes: - Diffusion term: <code>-\u03b5\u2207\u00b2(u)</code> - Convection term: <code>b\u00b7\u2207u</code> - Reaction term: <code>cu</code> where <code>\u03b5</code>, <code>b</code>, and <code>c</code> are known coefficients.</p>"},{"location":"api/core/sciml/pinns/physics/cd2d/#arguments","title":"Arguments","text":"<ul> <li><code>pred_nn</code> (<code>tf.Tensor</code>): Neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_x_nn</code> (<code>tf.Tensor</code>): x-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_y_nn</code> (<code>tf.Tensor</code>): y-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_xx_nn</code> (<code>tf.Tensor</code>): Second-order x-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_yy_nn</code> (<code>tf.Tensor</code>): Second-order y-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>forcing_function</code> (<code>callable</code>): Right-hand side forcing term.</li> <li><code>bilinear_params</code> (<code>dict</code>): A dictionary containing:</li> <li><code>eps</code>: Diffusion coefficient.</li> <li><code>b_x</code>: x-direction convection coefficient.</li> <li><code>b_y</code>: y-direction convection coefficient.</li> <li><code>c</code>: Reaction coefficient.</li> </ul>"},{"location":"api/core/sciml/pinns/physics/cd2d/#returns","title":"Returns","text":"<ul> <li><code>tf.Tensor</code>: Cell-wise residuals averaged over test functions. Shape: <code>(1,)</code></li> </ul>"},{"location":"api/core/sciml/pinns/physics/cd2d/#notes","title":"Notes","text":"<ul> <li>The methodology combines the effects of diffusion, convection, and reaction in a unified residual formulation.</li> </ul>"},{"location":"api/core/sciml/pinns/physics/poisson2d/","title":"Tensor-Based Loss Calculation for 2D Poisson Equation","text":""},{"location":"api/core/sciml/pinns/physics/poisson2d/#overview","title":"Overview","text":"<p>This module implements an efficient tensor-based approach for calculating variational residuals in 2D Poisson problems. It leverages TensorFlow's tensor operations for fast computation of weak form terms.</p>"},{"location":"api/core/sciml/pinns/physics/poisson2d/#key-functions","title":"Key Functions","text":"<ul> <li><code>pde_loss_poisson2d</code>: Computes the domain-based PDE loss.</li> </ul> <p>Note: The implementation is based on the FastVPINNs methodology for efficient computation of variational residuals of PDEs.</p>"},{"location":"api/core/sciml/pinns/physics/poisson2d/#function-pde_loss_poisson2d","title":"Function: <code>pde_loss_poisson2d</code>","text":""},{"location":"api/core/sciml/pinns/physics/poisson2d/#description","title":"Description","text":"<p>Calculates residuals for the 2D Poisson problem using the Physics-Informed Neural Networks (PINNs) methodology. The weak form includes: - Diffusion term: <code>-\u03b5\u2207\u00b2(u)</code>   - where <code>\u03b5</code> is a known diffusion coefficient.</p>"},{"location":"api/core/sciml/pinns/physics/poisson2d/#arguments","title":"Arguments","text":"<ul> <li><code>pred_nn</code> (<code>tf.Tensor</code>): Neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_x_nn</code> (<code>tf.Tensor</code>): x-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_y_nn</code> (<code>tf.Tensor</code>): y-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_xx_nn</code> (<code>tf.Tensor</code>): Second-order x-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>pred_grad_yy_nn</code> (<code>tf.Tensor</code>): Second-order y-derivative of the neural network solution at quadrature points. Shape: <code>(N_points, 1)</code></li> <li><code>forcing_function</code> (<code>callable</code>): Right-hand side forcing term.</li> <li><code>bilinear_params</code> (<code>dict</code>): A dictionary containing:</li> <li><code>eps</code>: Diffusion coefficient.</li> </ul>"},{"location":"api/core/sciml/pinns/physics/poisson2d/#returns","title":"Returns","text":"<ul> <li><code>tf.Tensor</code>: Cell-wise residuals averaged over test functions. Shape: <code>(1,)</code></li> </ul>"},{"location":"api/core/sciml/pinns/physics/poisson2d/#notes","title":"Notes","text":"<ul> <li>The diffusion term is computed as <code>-\u03b5(\u2207\u00b2u)</code> using second-order derivatives in the x and y directions.</li> </ul>"}]}