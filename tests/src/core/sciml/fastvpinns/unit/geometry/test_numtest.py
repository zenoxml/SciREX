# Author : Thivin Anandh. D
# Routines to check the number of test points generated by the geometry class.

import pytest
import numpy as np
from pathlib import Path
import shutil
from scirex.core.sciml.geometry.geometry_2d import Geometry_2D
from scirex.core.sciml.fe.fespace2d import Fespace2D
from scirex.core.sciml.fastvpinns.data.datahandler2d import DataHandler2D


# Parametrize the test case for different combinations of n_test_x and n_test_y
@pytest.mark.parametrize(
    "n_test_x, n_test_y",
    [
        (4, 4),  # Equal values
        (4, 6),  # Different values
        (6, 4),  # Different values
        (6, 6),  # Equal values
    ],
)
def test_numtest_points_internal(n_test_x, n_test_y):
    """
    Parametrized test case for validating the number of test points.
    """
    """
    Test case for validating the number of test points.
    """
    Path("tests/dump").mkdir(parents=True, exist_ok=True)

    # Define the geometry
    domain = Geometry_2D("quadrilateral", "internal", n_test_x, n_test_y, "tests/dump")

    # Generate the mesh
    cells, boundary_points = domain.generate_quad_mesh_internal(
        x_limits=[0, 1],
        y_limits=[0, 1],
        n_cells_x=4,
        n_cells_y=4,
        num_boundary_points=100,
    )

    # Generate random values for the boundary conditions
    values = [np.random.rand() for _ in range(4)]

    # Define the boundary function dictionary
    bound_function_dict = {
        1000: lambda x, y: np.ones_like(x) * values[0],
        1001: lambda x, y: np.ones_like(x) * values[1],
        1002: lambda x, y: np.ones_like(x) * values[2],
        1003: lambda x, y: np.ones_like(x) * values[3],
    }

    # Define the boundary condition dictionary
    bound_condition_dict = {
        1000: "dirichlet",
        1001: "dirichlet",
        1002: "dirichlet",
        1003: "dirichlet",
    }

    # Define the right-hand side function
    rhs = lambda x, y: np.ones_like(x)

    # Get the test points
    test_points = domain.get_test_points()

    # Calculate the expected number of test points
    total_expected = n_test_x * n_test_y

    # Check if the number of test points is equal to the expected number
    assert len(test_points) == total_expected

    shutil.rmtree("tests/dump")


def test_numtest_points_external():
    """
    Parametrized test case for validating the number of test points.
    """
    """
    Test case for validating the number of test points.
    """
    Path("tests/dump").mkdir(parents=True, exist_ok=True)

    domain = Geometry_2D("quadrilateral", "external", 10, 10, "tests/dump")
    cells, boundary_points = domain.read_mesh(
        mesh_file="tests/support_files/circle_quad.mesh",
        boundary_point_refinement_level=2,
        bd_sampling_method="uniform",
        refinement_level=0,
    )

    val = np.random.rand()
    bound_function_dict = {1000: lambda x, y: np.ones_like(x) * val}

    bound_condition_dict = {1000: "dirichlet"}

    test_points = domain.get_test_points()

    assert len(test_points) == 1090

    shutil.rmtree("tests/dump")
